# 9. 非同期処理と通信

この章では、時間のかかる処理を効率的に実行する「非同期処理」と、サーバーとデータをやり取りする「通信」について学びます。非同期処理を理解することで、ユーザー体験を向上させたWebアプリケーションを作成できるようになります。

---

## 目次

- [同期処理と非同期処理](#同期処理と非同期処理)
- [コールバック関数と課題](#コールバック関数と課題)
- [Promise - 成功と失敗を扱う設計](#promise---成功と失敗を扱う設計)
- [async/await - Promiseをさらに直感的に書く](#asyncawait---promiseをさらに直感的に書く)
- [fetch APIによる実践例](#fetch-apiによる実践例)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## 同期処理と非同期処理

### 同期処理とは
同期処理は、**処理が順番に実行される**方式です。前の処理が終わるまで、次の処理は実行されません。

### 非同期処理とは
非同期処理は、**処理を待たずに次の処理を実行できる**方式です。時間のかかる処理を待っている間、他の処理を実行できます。

### 同期処理の例

```javascript
console.log('1: 開始');
console.log('2: 処理中...');
console.log('3: 終了');

// 実行順序: 1 → 2 → 3（順番に実行される）
```

### 非同期処理の例

```javascript
console.log('1: 開始');

setTimeout(() => {
    console.log('2: 非同期処理');
}, 1000);

console.log('3: 終了');

// 実行順序: 1 → 3 → 2（非同期処理は後で実行される）
```

### 実践例: 同期処理と非同期処理

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>同期処理と非同期処理</title>
</head>
<body>
    <h1>同期処理と非同期処理</h1>
    <button id="syncBtn">同期処理</button>
    <button id="asyncBtn">非同期処理</button>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        
        // 同期処理
        document.getElementById('syncBtn').addEventListener('click', function() {
            output.innerHTML = '';
            output.innerHTML += '<p>1: 開始</p>';
            
            // 時間のかかる処理（同期）
            const start = Date.now();
            while (Date.now() - start < 2000) {
                // 2秒間待機（ブロッキング）
            }
            
            output.innerHTML += '<p>2: 処理完了（2秒後）</p>';
            output.innerHTML += '<p>3: 終了</p>';
            output.innerHTML += '<p>→ 順番に実行される（ブロッキング）</p>';
        });
        
        // 非同期処理
        document.getElementById('asyncBtn').addEventListener('click', function() {
            output.innerHTML = '';
            output.innerHTML += '<p>1: 開始</p>';
            
            // 時間のかかる処理（非同期）
            setTimeout(() => {
                output.innerHTML += '<p>2: 非同期処理完了（2秒後）</p>';
            }, 2000);
            
            output.innerHTML += '<p>3: 終了</p>';
            output.innerHTML += '<p>→ 待たずに次の処理が実行される（ノンブロッキング）</p>';
        });
        
        // コンソールで確認
        console.log('=== 同期処理と非同期処理 ===');
        console.log('同期処理: 順番に実行される（ブロッキング）');
        console.log('非同期処理: 待たずに次の処理を実行できる（ノンブロッキング）');
    </script>
</body>
</html>
```

---

## コールバック関数と課題

### コールバック関数とは
コールバック関数は、**他の関数に渡される関数**です。非同期処理の結果を受け取るために使われます。

### コールバック関数の例

```javascript
setTimeout(function() {
    console.log('1秒後に実行');
}, 1000);
```

### コールバック地獄（Callback Hell）
コールバック関数を多用すると、コードが深くネストして読みにくくなります。

```javascript
// コールバック地獄の例
setTimeout(() => {
    console.log('1秒後');
    setTimeout(() => {
        console.log('2秒後');
        setTimeout(() => {
            console.log('3秒後');
        }, 1000);
    }, 1000);
}, 1000);
```

### 実践例: コールバック関数と課題

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>コールバック関数と課題</title>
</head>
<body>
    <h1>コールバック関数と課題</h1>
    <button id="callbackBtn">コールバック関数</button>
    <button id="hellBtn">コールバック地獄</button>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        
        // 基本的なコールバック関数
        document.getElementById('callbackBtn').addEventListener('click', function() {
            output.innerHTML = '';
            output.innerHTML += '<p>開始</p>';
            
            setTimeout(() => {
                output.innerHTML += '<p>1秒後: コールバック関数が実行されました</p>';
            }, 1000);
            
            output.innerHTML += '<p>待たずに次の処理が実行されます</p>';
        });
        
        // コールバック地獄
        document.getElementById('hellBtn').addEventListener('click', function() {
            output.innerHTML = '';
            output.innerHTML += '<p>コールバック地獄の例:</p>';
            output.innerHTML += '<pre>';
            output.innerHTML += 'setTimeout(() => {<br>';
            output.innerHTML += '  setTimeout(() => {<br>';
            output.innerHTML += '    setTimeout(() => {<br>';
            output.innerHTML += '      // 深くネストして読みにくい<br>';
            output.innerHTML += '    }, 1000);<br>';
            output.innerHTML += '  }, 1000);<br>';
            output.innerHTML += '}, 1000);';
            output.innerHTML += '</pre>';
            output.innerHTML += '<p>→ コードが深くネストして読みにくくなる</p>';
            
            // 実際のコールバック地獄の例
            setTimeout(() => {
                output.innerHTML += '<p>1秒後</p>';
                setTimeout(() => {
                    output.innerHTML += '<p>2秒後</p>';
                    setTimeout(() => {
                        output.innerHTML += '<p>3秒後</p>';
                        output.innerHTML += '<p>→ コールバック地獄の問題点が分かります</p>';
                    }, 1000);
                }, 1000);
            }, 1000);
        });
        
        // コンソールで確認
        console.log('=== コールバック関数と課題 ===');
        console.log('コールバック関数は非同期処理の結果を受け取るために使われます');
        console.log('コールバック地獄は読みにくいコードになります');
    </script>
</body>
</html>
```

---

## Promise - 成功と失敗を扱う設計

### Promiseとは
Promiseは、**非同期処理の結果を扱うオブジェクト**です。成功（resolve）と失敗（reject）を明確に扱えます。

### Promiseの基本構文

```javascript
const promise = new Promise((resolve, reject) => {
    // 非同期処理
    if (成功) {
        resolve(結果);
    } else {
        reject(エラー);
    }
});
```

### Promiseの使い方

```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功！');
    }, 1000);
});

promise.then((result) => {
    console.log(result); // '成功！'
}).catch((error) => {
    console.error(error);
});
```

### Promiseの特徴
1. **成功と失敗を明確に**: `resolve`と`reject`で分ける
2. **チェーン可能**: `.then().then()`で連続処理できる
3. **エラーハンドリング**: `.catch()`でエラーを処理できる

### 実践例: Promise

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Promise - 成功と失敗を扱う設計</title>
</head>
<body>
    <h1>Promise - 成功と失敗を扱う設計</h1>
    <button id="successBtn">成功するPromise</button>
    <button id="failBtn">失敗するPromise</button>
    <button id="chainBtn">Promiseチェーン</button>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        
        // 成功するPromise
        document.getElementById('successBtn').addEventListener('click', function() {
            output.innerHTML = '';
            
            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve('成功しました！');
                }, 1000);
            });
            
            promise.then((result) => {
                output.innerHTML = `<p>結果: ${result}</p>`;
            }).catch((error) => {
                output.innerHTML = `<p>エラー: ${error}</p>`;
            });
            
            output.innerHTML += '<p>Promiseを作成しました（1秒後に結果が表示されます）</p>';
        });
        
        // 失敗するPromise
        document.getElementById('failBtn').addEventListener('click', function() {
            output.innerHTML = '';
            
            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    reject('エラーが発生しました');
                }, 1000);
            });
            
            promise.then((result) => {
                output.innerHTML = `<p>結果: ${result}</p>`;
            }).catch((error) => {
                output.innerHTML = `<p>エラー: ${error}</p>`;
            });
            
            output.innerHTML += '<p>Promiseを作成しました（1秒後にエラーが表示されます）</p>';
        });
        
        // Promiseチェーン
        document.getElementById('chainBtn').addEventListener('click', function() {
            output.innerHTML = '';
            
            const promise = new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve(10);
                }, 1000);
            });
            
            promise
                .then((value) => {
                    output.innerHTML += `<p>1回目: ${value}</p>`;
                    return value * 2;
                })
                .then((value) => {
                    output.innerHTML += `<p>2回目: ${value}</p>`;
                    return value + 5;
                })
                .then((value) => {
                    output.innerHTML += `<p>3回目: ${value}</p>`;
                    output.innerHTML += `<p>最終結果: ${value}</p>`;
                })
                .catch((error) => {
                    output.innerHTML += `<p>エラー: ${error}</p>`;
                });
            
            output.innerHTML += '<p>Promiseチェーンを開始しました</p>';
        });
        
        // 実践例: データ取得のシミュレーション
        function fetchData() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const success = Math.random() > 0.3; // 70%の確率で成功
                    if (success) {
                        resolve({ data: 'データを取得しました' });
                    } else {
                        reject('データの取得に失敗しました');
                    }
                }, 1500);
            });
        }
        
        const fetchBtn = document.createElement('button');
        fetchBtn.textContent = 'データを取得';
        fetchBtn.style.marginTop = '10px';
        document.body.appendChild(fetchBtn);
        
        fetchBtn.addEventListener('click', function() {
            output.innerHTML = '<p>データを取得中...</p>';
            
            fetchData()
                .then((result) => {
                    output.innerHTML = `<p>✓ ${result.data}</p>`;
                })
                .catch((error) => {
                    output.innerHTML = `<p>✗ ${error}</p>`;
                });
        });
        
        // コンソールで確認
        console.log('=== Promise ===');
        console.log('Promiseは非同期処理の結果を扱うオブジェクトです');
        console.log('成功と失敗を明確に扱えます');
    </script>
</body>
</html>
```

---

## async/await - Promiseをさらに直感的に書く

### async/awaitとは
`async/await`は、**Promiseをより直感的に書くための構文**です。非同期処理を同期処理のように書けます。

### async関数の基本

```javascript
async function myFunction() {
    const result = await promise;
    return result;
}
```

### async/awaitの特徴
1. **読みやすい**: 同期処理のように書ける
2. **エラーハンドリング**: `try-catch`でエラーを処理できる
3. **Promiseを返す**: `async`関数は自動的にPromiseを返す

### 実践例: async/await

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>async/await - Promiseをさらに直感的に書く</title>
</head>
<body>
    <h1>async/await - Promiseをさらに直感的に書く</h1>
    <button id="asyncBtn">async/await</button>
    <button id="compareBtn">Promiseと比較</button>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        
        // 非同期処理を返す関数
        function delay(ms) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(`${ms}ms待機しました`);
                }, ms);
            });
        }
        
        // async/awaitの例
        document.getElementById('asyncBtn').addEventListener('click', async function() {
            output.innerHTML = '';
            output.innerHTML += '<p>開始</p>';
            
            try {
                const result1 = await delay(1000);
                output.innerHTML += `<p>1: ${result1}</p>`;
                
                const result2 = await delay(1000);
                output.innerHTML += `<p>2: ${result2}</p>`;
                
                const result3 = await delay(1000);
                output.innerHTML += `<p>3: ${result3}</p>`;
                
                output.innerHTML += '<p>→ 同期処理のように書けます</p>';
            } catch (error) {
                output.innerHTML += `<p>エラー: ${error}</p>`;
            }
        });
        
        // Promiseとasync/awaitの比較
        document.getElementById('compareBtn').addEventListener('click', function() {
            output.innerHTML = '';
            
            output.innerHTML += '<h2>Promise（従来の方法）</h2>';
            output.innerHTML += '<pre>';
            output.innerHTML += 'delay(1000)<br>';
            output.innerHTML += '  .then(result => {<br>';
            output.innerHTML += '    return delay(1000);<br>';
            output.innerHTML += '  })<br>';
            output.innerHTML += '  .then(result => {<br>';
            output.innerHTML += '    // 処理<br>';
            output.innerHTML += '  });';
            output.innerHTML += '</pre>';
            
            output.innerHTML += '<h2>async/await（新しい方法）</h2>';
            output.innerHTML += '<pre>';
            output.innerHTML += 'async function() {<br>';
            output.innerHTML += '  const result1 = await delay(1000);<br>';
            output.innerHTML += '  const result2 = await delay(1000);<br>';
            output.innerHTML += '  // 処理<br>';
            output.innerHTML += '}';
            output.innerHTML += '</pre>';
            output.innerHTML += '<p>→ async/awaitの方が読みやすい</p>';
        });
        
        // 実践例: エラーハンドリング
        function fetchDataWithError() {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    const success = Math.random() > 0.5;
                    if (success) {
                        resolve('データを取得しました');
                    } else {
                        reject('エラーが発生しました');
                    }
                }, 1000);
            });
        }
        
        const errorBtn = document.createElement('button');
        errorBtn.textContent = 'エラーハンドリング';
        errorBtn.style.marginTop = '10px';
        document.body.appendChild(errorBtn);
        
        errorBtn.addEventListener('click', async function() {
            output.innerHTML = '<p>データを取得中...</p>';
            
            try {
                const result = await fetchDataWithError();
                output.innerHTML = `<p>✓ ${result}</p>`;
            } catch (error) {
                output.innerHTML = `<p>✗ ${error}</p>`;
            }
        });
        
        // コンソールで確認
        console.log('=== async/await ===');
        console.log('async/awaitでPromiseをより直感的に書けます');
        console.log('同期処理のように書けるため、読みやすくなります');
    </script>
</body>
</html>
```

---

## fetch APIによる実践例

### fetch APIとは
`fetch` APIは、**サーバーとデータをやり取りする**ためのAPIです。

### fetchの基本構文

```javascript
fetch('URL')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));
```

### async/awaitでfetchを使う

```javascript
async function fetchData() {
    try {
        const response = await fetch('URL');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}
```

### 実践例: fetch APIによる実践例

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>fetch APIによる実践例</title>
</head>
<body>
    <h1>fetch APIによる実践例</h1>
    <button id="fetchBtn">データを取得</button>
    <button id="fetchAsyncBtn">async/awaitで取得</button>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        
        // fetch API（Promise）
        document.getElementById('fetchBtn').addEventListener('click', function() {
            output.innerHTML = '<p>データを取得中...</p>';
            
            // 公開APIの例（JSONPlaceholder）
            fetch('https://jsonplaceholder.typicode.com/posts/1')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('ネットワークエラー');
                    }
                    return response.json();
                })
                .then(data => {
                    output.innerHTML = `
                        <h2>取得したデータ</h2>
                        <p><strong>タイトル:</strong> ${data.title}</p>
                        <p><strong>本文:</strong> ${data.body}</p>
                    `;
                })
                .catch(error => {
                    output.innerHTML = `<p>エラー: ${error.message}</p>`;
                });
        });
        
        // fetch API（async/await）
        document.getElementById('fetchAsyncBtn').addEventListener('click', async function() {
            output.innerHTML = '<p>データを取得中...</p>';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts/2');
                
                if (!response.ok) {
                    throw new Error('ネットワークエラー');
                }
                
                const data = await response.json();
                
                output.innerHTML = `
                    <h2>取得したデータ（async/await）</h2>
                    <p><strong>ID:</strong> ${data.id}</p>
                    <p><strong>タイトル:</strong> ${data.title}</p>
                    <p><strong>本文:</strong> ${data.body}</p>
                `;
            } catch (error) {
                output.innerHTML = `<p>エラー: ${error.message}</p>`;
            }
        });
        
        // 実践例: 複数のデータを取得
        const multiFetchBtn = document.createElement('button');
        multiFetchBtn.textContent = '複数のデータを取得';
        multiFetchBtn.style.marginTop = '10px';
        document.body.appendChild(multiFetchBtn);
        
        multiFetchBtn.addEventListener('click', async function() {
            output.innerHTML = '<p>複数のデータを取得中...</p>';
            
            try {
                // 並列で取得
                const [post1, post2, post3] = await Promise.all([
                    fetch('https://jsonplaceholder.typicode.com/posts/1').then(r => r.json()),
                    fetch('https://jsonplaceholder.typicode.com/posts/2').then(r => r.json()),
                    fetch('https://jsonplaceholder.typicode.com/posts/3').then(r => r.json())
                ]);
                
                output.innerHTML = `
                    <h2>取得したデータ（複数）</h2>
                    <p><strong>投稿1:</strong> ${post1.title}</p>
                    <p><strong>投稿2:</strong> ${post2.title}</p>
                    <p><strong>投稿3:</strong> ${post3.title}</p>
                `;
            } catch (error) {
                output.innerHTML = `<p>エラー: ${error.message}</p>`;
            }
        });
        
        // 実践例: POSTリクエスト
        const postBtn = document.createElement('button');
        postBtn.textContent = 'データを送信（POST）';
        postBtn.style.marginTop = '10px';
        document.body.appendChild(postBtn);
        
        postBtn.addEventListener('click', async function() {
            output.innerHTML = '<p>データを送信中...</p>';
            
            try {
                const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: '新しい投稿',
                        body: 'これはテスト投稿です',
                        userId: 1
                    })
                });
                
                const data = await response.json();
                
                output.innerHTML = `
                    <h2>送信したデータ</h2>
                    <p><strong>ID:</strong> ${data.id}</p>
                    <p><strong>タイトル:</strong> ${data.title}</p>
                    <p><strong>本文:</strong> ${data.body}</p>
                `;
            } catch (error) {
                output.innerHTML = `<p>エラー: ${error.message}</p>`;
            }
        });
        
        // コンソールで確認
        console.log('=== fetch API ===');
        console.log('fetch APIでサーバーとデータをやり取りできます');
        console.log('Promiseとasync/awaitの両方で使えます');
    </script>
</body>
</html>
```

---

## まとめ

この章では、非同期処理と通信について学びました。

### 学んだこと
- 同期処理と非同期処理の違い
- コールバック関数とその課題
- Promise（成功と失敗を扱う設計）
- async/await（Promiseを直感的に書く）
- fetch API（サーバーとの通信）

### 重要なポイント
1. **非同期処理**: 時間のかかる処理を待たずに次の処理を実行できる
2. **Promise**: 非同期処理の結果を明確に扱える
3. **async/await**: Promiseをより直感的に書ける
4. **fetch API**: サーバーとデータをやり取りできる

### 次のステップ
次の章では、応用・便利な機能について詳しく学びます。

---

## 演習問題

### 問題1: Promiseの作成
1秒後に「成功しました」というメッセージを返すPromiseを作成してください。

<details>
<summary>解答例</summary>

```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('成功しました');
    }, 1000);
});

promise.then((result) => {
    console.log(result);
});
```
</details>

### 問題2: async/await
async/awaitを使って、上記のPromiseの結果を取得してください。

<details>
<summary>解答例</summary>

```javascript
async function getResult() {
    const promise = new Promise((resolve) => {
        setTimeout(() => {
            resolve('成功しました');
        }, 1000);
    });
    
    const result = await promise;
    console.log(result);
}

getResult();
```
</details>

### 問題3: fetch API
fetch APIを使って、データを取得してください（URLは任意）。

<details>
<summary>解答例</summary>

```javascript
fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error(error));
```
</details>

### 問題4: async/awaitでfetch
async/awaitを使って、fetch APIでデータを取得してください。

<details>
<summary>解答例</summary>

```javascript
async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}

fetchData();
```
</details>

### 問題5: エラーハンドリング
Promiseでエラーが発生した場合に、catchでエラーを処理してください。

<details>
<summary>解答例</summary>

```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject('エラーが発生しました');
    }, 1000);
});

promise
    .then((result) => {
        console.log(result);
    })
    .catch((error) => {
        console.error('エラー:', error);
    });
```
</details>

---

お疲れ様でした！次の章に進みましょう。

