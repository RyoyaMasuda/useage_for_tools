# 5-2. スコープ

この章では、変数が有効な範囲を決める「スコープ」について学びます。スコープを理解することで、変数の使い方を正しく理解し、エラーを防ぐことができます。

---

## 目次

- [スコープとは](#スコープとは)
- [スコープ - 変数が有効な範囲を理解する](#スコープ---変数が有効な範囲を理解する)
- [関数スコープ](#関数スコープ)
- [ブロックスコープ](#ブロックスコープ)
- [グローバルスコープ](#グローバルスコープ)
- [letとconstの再訪 - ブロックスコープ](#letとconstの再訪---ブロックスコープ)
- [クロージャ - スコープの鎖を理解する](#クロージャ---スコープの鎖を理解する)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## スコープとは

### スコープの概念
スコープ（scope）は、**変数が有効な範囲**のことです。変数は、宣言した場所によって、使える範囲が決まります。

### 日常生活での例
- **部屋の中のもの**: 部屋の中でのみ使える（ローカルスコープ）
- **家全体のもの**: 家の中ならどこでも使える（グローバルスコープ）

### プログラミングでの例
```javascript
// グローバルスコープ
const globalVar = 'グローバル変数';

function myFunction() {
    // 関数スコープ
    const localVar = 'ローカル変数';
    console.log(globalVar);  // 使える
    console.log(localVar);   // 使える
}

console.log(globalVar);  // 使える
// console.log(localVar); // エラー！関数の外では使えない
```

### スコープの種類
1. **グローバルスコープ**: どこからでも使える
2. **関数スコープ**: 関数の中でのみ使える
3. **ブロックスコープ**: `{}`で囲まれた範囲でのみ使える

### 実践例: スコープの基本概念

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>スコープとは</title>
</head>
<body>
    <h1>スコープの基本概念</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // グローバルスコープの変数
        const globalMessage = 'これはグローバル変数です';
        
        results.push('<h2>グローバルスコープ</h2>');
        results.push(`<p>${globalMessage}</p>`);
        
        // 関数スコープの変数
        function showLocalScope() {
            const localMessage = 'これはローカル変数です';
            results.push(`<p>関数内: ${localMessage}</p>`);
            results.push(`<p>関数内からグローバル変数: ${globalMessage}</p>`);
        }
        
        results.push('<h2>関数スコープ</h2>');
        showLocalScope();
        
        // 関数の外からローカル変数にアクセスしようとするとエラー
        // results.push(`<p>${localMessage}</p>`); // ReferenceError
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== スコープの基本 ===');
        console.log('変数は宣言した場所によって使える範囲が決まります');
    </script>
</body>
</html>
```

---

## スコープ - 変数が有効な範囲を理解する

変数は、宣言した場所によって、使える範囲（スコープ）が決まります。

### スコープの基本ルール

1. **内側から外側は見える**: 内側のスコープから外側のスコープの変数は使える
2. **外側から内側は見えない**: 外側のスコープから内側のスコープの変数は使えない
3. **同じスコープ内では使える**: 同じスコープ内で宣言した変数は使える

### スコープの階層

```javascript
// グローバルスコープ（最外側）
const global = 'グローバル';

function outerFunction() {
    // 関数スコープ（中間）
    const outer = '外側の関数';
    
    function innerFunction() {
        // 関数スコープ（内側）
        const inner = '内側の関数';
        
        console.log(global);  // 使える（外側を見られる）
        console.log(outer);   // 使える（外側を見られる）
        console.log(inner);   // 使える（同じスコープ内）
    }
    
    console.log(global);  // 使える（外側を見られる）
    console.log(outer);   // 使える（同じスコープ内）
    // console.log(inner); // エラー！内側は見られない
}
```

### 実践例: スコープの範囲を理解する

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>スコープの範囲</title>
</head>
<body>
    <h1>スコープ - 変数が有効な範囲</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // グローバルスコープ
        const globalVar = 'グローバル変数';
        
        results.push('<h2>スコープの階層</h2>');
        
        function level1() {
            const level1Var = 'レベル1の変数';
            results.push(`<p>レベル1: ${level1Var}</p>`);
            results.push(`<p>レベル1からグローバル: ${globalVar}</p>`);
            
            function level2() {
                const level2Var = 'レベル2の変数';
                results.push(`<p>レベル2: ${level2Var}</p>`);
                results.push(`<p>レベル2からレベル1: ${level1Var}</p>`);
                results.push(`<p>レベル2からグローバル: ${globalVar}</p>`);
            }
            
            level2();
            // results.push(`<p>${level2Var}</p>`); // エラー！内側は見られない
        }
        
        level1();
        results.push(`<p>グローバルから: ${globalVar}</p>`);
        
        // 実践例: 変数のシャドウイング
        results.push('<h2>変数のシャドウイング</h2>');
        
        const name = 'グローバル名前';
        
        function showName() {
            const name = 'ローカル名前';  // 同じ名前の変数を宣言
            results.push(`<p>関数内のname: ${name}</p>`);  // ローカル変数が優先
        }
        
        showName();
        results.push(`<p>グローバルのname: ${name}</p>`);  // グローバル変数
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== スコープの範囲 ===');
        console.log('内側から外側は見えるが、外側から内側は見えない');
    </script>
</body>
</html>
```

---

## 関数スコープ

関数スコープは、関数の中で宣言した変数が有効な範囲です。

### 関数スコープの基本

```javascript
function myFunction() {
    const localVar = 'ローカル変数';
    console.log(localVar);  // 使える
}

// console.log(localVar); // エラー！関数の外では使えない
```

### varと関数スコープ

`var`で宣言した変数は、関数スコープを持ちます。

```javascript
function test() {
    if (true) {
        var x = 10;  // 関数スコープ
    }
    console.log(x);  // 10（ブロックを超えて使える）
}
```

### let/constと関数スコープ

`let`と`const`で宣言した変数も、関数スコープを持ちます。

```javascript
function test() {
    if (true) {
        let y = 20;  // ブロックスコープ
    }
    // console.log(y); // エラー！ブロックの外では使えない
}
```

### 実践例: 関数スコープ

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>関数スコープ</title>
</head>
<body>
    <h1>関数スコープ</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // 基本的な関数スコープ
        results.push('<h2>基本的な関数スコープ</h2>');
        
        function function1() {
            const localVar = '関数1のローカル変数';
            results.push(`<p>関数1内: ${localVar}</p>`);
        }
        
        function function2() {
            const localVar = '関数2のローカル変数';
            results.push(`<p>関数2内: ${localVar}</p>`);
        }
        
        function1();
        function2();
        
        // 各関数の変数は独立している
        results.push('<p>各関数の変数は独立しています（同じ名前でも別物）</p>');
        
        // varと関数スコープ
        results.push('<h2>varと関数スコープ</h2>');
        
        function testVar() {
            if (true) {
                var varVar = 'varで宣言';
            }
            results.push(`<p>varは関数全体で有効: ${varVar}</p>`);
        }
        
        testVar();
        
        // let/constと関数スコープ
        results.push('<h2>let/constと関数スコープ</h2>');
        
        function testLet() {
            let letVar = 'letで宣言';
            if (true) {
                let blockVar = 'ブロック内のlet';
                results.push(`<p>ブロック内: ${blockVar}</p>`);
            }
            results.push(`<p>関数内: ${letVar}</p>`);
            // results.push(`<p>${blockVar}</p>`); // エラー！ブロックの外では使えない
        }
        
        testLet();
        
        // 実践例: 関数間での変数の共有
        results.push('<h2>実践例: 関数間での変数の共有</h2>');
        
        // グローバル変数を使う
        let counter = 0;
        
        function increment() {
            counter++;
            return counter;
        }
        
        function decrement() {
            counter--;
            return counter;
        }
        
        results.push(`<p>カウンター: ${increment()}</p>`);
        results.push(`<p>カウンター: ${increment()}</p>`);
        results.push(`<p>カウンター: ${decrement()}</p>`);
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== 関数スコープ ===');
        console.log('関数内で宣言した変数は、その関数内でのみ有効です');
    </script>
</body>
</html>
```

---

## ブロックスコープ

ブロックスコープは、`{}`で囲まれた範囲で変数が有効な範囲です。

### ブロックスコープの基本

```javascript
if (true) {
    const blockVar = 'ブロック内の変数';
    console.log(blockVar);  // 使える
}

// console.log(blockVar); // エラー！ブロックの外では使えない
```

### let/constとブロックスコープ

`let`と`const`で宣言した変数は、ブロックスコープを持ちます。

```javascript
if (true) {
    let x = 10;
    const y = 20;
    console.log(x, y);  // 使える
}

// console.log(x, y); // エラー！ブロックの外では使えない
```

### varとブロックスコープ

`var`で宣言した変数は、ブロックスコープを持ちません（関数スコープのみ）。

```javascript
if (true) {
    var z = 30;  // 関数スコープ
}

console.log(z);  // 30（ブロックを超えて使える）
```

### 実践例: ブロックスコープ

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ブロックスコープ</title>
</head>
<body>
    <h1>ブロックスコープ</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // let/constとブロックスコープ
        results.push('<h2>let/constとブロックスコープ</h2>');
        
        if (true) {
            let blockLet = 'ブロック内のlet';
            const blockConst = 'ブロック内のconst';
            results.push(`<p>ブロック内: ${blockLet}</p>`);
            results.push(`<p>ブロック内: ${blockConst}</p>`);
        }
        
        // results.push(`<p>${blockLet}</p>`); // エラー！
        // results.push(`<p>${blockConst}</p>`); // エラー！
        
        // varとブロックスコープ（ブロックスコープを持たない）
        results.push('<h2>varとブロックスコープ</h2>');
        
        if (true) {
            var blockVar = 'ブロック内のvar';
        }
        
        results.push(`<p>ブロック外からvar: ${blockVar}</p>`);
        results.push('<p>varはブロックスコープを持たない（関数スコープのみ）</p>');
        
        // ループとブロックスコープ
        results.push('<h2>ループとブロックスコープ</h2>');
        
        for (let i = 0; i < 3; i++) {
            const loopVar = `ループ${i}`;
            results.push(`<p>ループ内: ${loopVar}</p>`);
        }
        
        // results.push(`<p>${i}</p>`); // エラー！ループの外では使えない
        // results.push(`<p>${loopVar}</p>`); // エラー！
        
        // 実践例: 条件分岐とブロックスコープ
        results.push('<h2>実践例: 条件分岐とブロックスコープ</h2>');
        
        const age = 25;
        
        if (age >= 20) {
            const message = '成人です';
            results.push(`<p>${message}</p>`);
        } else {
            const message = '未成年です';
            results.push(`<p>${message}</p>`);
        }
        
        // 各ブロックの変数は独立している
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== ブロックスコープ ===');
        console.log('let/constはブロックスコープを持ちます');
        console.log('varはブロックスコープを持ちません');
    </script>
</body>
</html>
```

---

## グローバルスコープ

グローバルスコープは、どこからでも使える変数の範囲です。

### グローバルスコープの基本

```javascript
// グローバルスコープで宣言
const globalVar = 'グローバル変数';

function myFunction() {
    console.log(globalVar);  // 使える
}

console.log(globalVar);  // 使える
```

### グローバル変数の注意点

1. **どこからでもアクセスできる**: 便利だが、意図しない変更のリスクがある
2. **名前の衝突**: 同じ名前の変数が複数あると問題が起きる
3. **できるだけ避ける**: 必要な場合のみ使う

### 実践例: グローバルスコープ

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>グローバルスコープ</title>
</head>
<body>
    <h1>グローバルスコープ</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // グローバル変数の宣言
        const globalConst = 'グローバル定数';
        let globalLet = 'グローバル変数';
        var globalVar = 'グローバル変数（var）';
        
        results.push('<h2>グローバル変数の宣言</h2>');
        results.push(`<p>${globalConst}</p>`);
        results.push(`<p>${globalLet}</p>`);
        results.push(`<p>${globalVar}</p>`);
        
        // 関数内からグローバル変数にアクセス
        results.push('<h2>関数内からグローバル変数にアクセス</h2>');
        
        function accessGlobal() {
            results.push(`<p>関数内から: ${globalConst}</p>`);
            results.push(`<p>関数内から: ${globalLet}</p>`);
            results.push(`<p>関数内から: ${globalVar}</p>`);
        }
        
        accessGlobal();
        
        // グローバル変数の変更
        results.push('<h2>グローバル変数の変更</h2>');
        
        function changeGlobal() {
            // globalConst = '変更'; // エラー！constは変更不可
            globalLet = '変更されたグローバル変数';
            globalVar = '変更されたグローバル変数（var）';
        }
        
        changeGlobal();
        results.push(`<p>変更後: ${globalLet}</p>`);
        results.push(`<p>変更後: ${globalVar}</p>`);
        
        // 実践例: グローバル変数の問題点
        results.push('<h2>実践例: グローバル変数の問題点</h2>');
        
        // 名前の衝突の例
        let userName = '太郎';
        
        function function1() {
            userName = '花子';  // 意図しない変更
        }
        
        function function2() {
            userName = '次郎';  // 意図しない変更
        }
        
        results.push(`<p>初期値: ${userName}</p>`);
        function1();
        results.push(`<p>function1実行後: ${userName}</p>`);
        function2();
        results.push(`<p>function2実行後: ${userName}</p>`);
        results.push('<p>グローバル変数は意図しない変更のリスクがあります</p>');
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== グローバルスコープ ===');
        console.log('グローバル変数はどこからでもアクセスできます');
        console.log('できるだけ避けて、必要な場合のみ使いましょう');
    </script>
</body>
</html>
```

---

## letとconstの再訪 - ブロックスコープ

`let`と`const`は、ブロックスコープを持つ変数宣言です。

### let/constの特徴

1. **ブロックスコープ**: `{}`で囲まれた範囲でのみ有効
2. **再代入**: `let`は可能、`const`は不可
3. **ホイスティング**: 宣言前にアクセスできない（TDZ: Temporal Dead Zone）

### ブロックスコープの例

```javascript
if (true) {
    let x = 10;
    const y = 20;
    console.log(x, y);  // 使える
}

// console.log(x, y); // エラー！ブロックの外では使えない
```

### ループとブロックスコープ

```javascript
for (let i = 0; i < 3; i++) {
    console.log(i);  // 0, 1, 2
}

// console.log(i); // エラー！ループの外では使えない
```

### 実践例: letとconstの再訪

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>letとconstの再訪</title>
</head>
<body>
    <h1>letとconstの再訪 - ブロックスコープ</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // ブロックスコープの例
        results.push('<h2>ブロックスコープの例</h2>');
        
        if (true) {
            let blockLet = 'ブロック内のlet';
            const blockConst = 'ブロック内のconst';
            results.push(`<p>ブロック内: ${blockLet}</p>`);
            results.push(`<p>ブロック内: ${blockConst}</p>`);
        }
        
        // ブロックの外では使えない
        // results.push(`<p>${blockLet}</p>`); // エラー！
        
        // ループとブロックスコープ
        results.push('<h2>ループとブロックスコープ</h2>');
        
        for (let i = 0; i < 3; i++) {
            const loopConst = `ループ${i}`;
            results.push(`<p>ループ${i}: ${loopConst}</p>`);
        }
        
        // ループの外では使えない
        // results.push(`<p>${i}</p>`); // エラー！
        
        // 各反復で独立した変数
        results.push('<h2>各反復で独立した変数</h2>');
        
        const functions = [];
        for (let i = 0; i < 3; i++) {
            functions.push(function() {
                return i;  // 各反復で独立したi
            });
        }
        
        results.push(`<p>関数0: ${functions[0]()}</p>`);  // 0
        results.push(`<p>関数1: ${functions[1]()}</p>`);  // 1
        results.push(`<p>関数2: ${functions[2]()}</p>`);  // 2
        
        // varとの比較（問題のある例）
        results.push('<h2>varとの比較（問題のある例）</h2>');
        
        const varFunctions = [];
        for (var j = 0; j < 3; j++) {
            varFunctions.push(function() {
                return j;  // すべて同じjを参照
            });
        }
        
        results.push(`<p>var関数0: ${varFunctions[0]()}</p>`);  // 3（すべて3になる）
        results.push(`<p>var関数1: ${varFunctions[1]()}</p>`);  // 3
        results.push(`<p>var関数2: ${varFunctions[2]()}</p>`);  // 3
        results.push('<p>varはブロックスコープを持たないため、すべて同じ値を参照します</p>');
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== letとconstの再訪 ===');
        console.log('let/constはブロックスコープを持ちます');
        console.log('ループ内でletを使うと、各反復で独立した変数になります');
    </script>
</body>
</html>
```

---

## クロージャ - スコープの鎖を理解する

クロージャ（closure）は、**内側の関数が外側のスコープの変数を参照できる**仕組みです。

### クロージャの基本

```javascript
function outerFunction() {
    const outerVar = '外側の変数';
    
    function innerFunction() {
        console.log(outerVar);  // 外側の変数を参照
    }
    
    return innerFunction;
}

const myFunction = outerFunction();
myFunction(); // '外側の変数'が表示される
```

### クロージャの特徴

1. **スコープの保持**: 内側の関数は、外側のスコープの変数を「覚えている」
2. **プライベート変数**: 外側から直接アクセスできない変数を作れる
3. **データの保持**: 関数が実行された後も、変数の値を保持できる

### 実践例: クロージャ

```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>クロージャ</title>
</head>
<body>
    <h1>クロージャ - スコープの鎖を理解する</h1>
    <div id="output"></div>
    
    <script>
        const output = document.getElementById('output');
        let results = [];
        
        // 基本的なクロージャ
        results.push('<h2>基本的なクロージャ</h2>');
        
        function outerFunction() {
            const outerVar = '外側の変数';
            
            function innerFunction() {
                return outerVar;  // 外側の変数を参照
            }
            
            return innerFunction;
        }
        
        const myFunction = outerFunction();
        results.push(`<p>クロージャの結果: ${myFunction()}</p>`);
        
        // カウンターの例（データの保持）
        results.push('<h2>カウンターの例（データの保持）</h2>');
        
        function createCounter() {
            let count = 0;  // プライベート変数
            
            return {
                increment: function() {
                    count++;
                    return count;
                },
                decrement: function() {
                    count--;
                    return count;
                },
                getCount: function() {
                    return count;
                }
            };
        }
        
        const counter1 = createCounter();
        const counter2 = createCounter();
        
        results.push(`<p>カウンター1: ${counter1.increment()}</p>`);
        results.push(`<p>カウンター1: ${counter1.increment()}</p>`);
        results.push(`<p>カウンター2: ${counter2.increment()}</p>`);
        results.push(`<p>カウンター1の値: ${counter1.getCount()}</p>`);
        results.push(`<p>カウンター2の値: ${counter2.getCount()}</p>`);
        results.push('<p>各カウンターは独立したcount変数を持っています</p>');
        
        // 実践例: 関数の生成
        results.push('<h2>実践例: 関数の生成</h2>');
        
        function createMultiplier(multiplier) {
            return function(number) {
                return number * multiplier;
            };
        }
        
        const double = createMultiplier(2);
        const triple = createMultiplier(3);
        
        results.push(`<p>10の2倍: ${double(10)}</p>`);
        results.push(`<p>10の3倍: ${triple(10)}</p>`);
        
        // 実践例: プライベート変数
        results.push('<h2>実践例: プライベート変数</h2>');
        
        function createBankAccount(initialBalance) {
            let balance = initialBalance;  // プライベート変数
            
            return {
                deposit: function(amount) {
                    balance += amount;
                    return balance;
                },
                withdraw: function(amount) {
                    if (balance >= amount) {
                        balance -= amount;
                        return balance;
                    } else {
                        return '残高不足';
                    }
                },
                getBalance: function() {
                    return balance;
                }
            };
        }
        
        const account = createBankAccount(1000);
        results.push(`<p>初期残高: ${account.getBalance()}円</p>`);
        results.push(`<p>入金後: ${account.deposit(500)}円</p>`);
        results.push(`<p>出金後: ${account.withdraw(300)}円</p>`);
        results.push(`<p>現在の残高: ${account.getBalance()}円</p>`);
        results.push('<p>balance変数は外側から直接アクセスできません（プライベート変数）</p>');
        
        output.innerHTML = results.join('');
        
        // コンソールで確認
        console.log('=== クロージャ ===');
        console.log('内側の関数が外側のスコープの変数を参照できる仕組みです');
        console.log('データの保持やプライベート変数の実現に使えます');
    </script>
</body>
</html>
```

---

## まとめ

この章では、スコープについて学びました。

### 学んだこと
- スコープの概念（変数が有効な範囲）
- 関数スコープ（関数内でのみ有効）
- ブロックスコープ（`{}`内でのみ有効）
- グローバルスコープ（どこからでも有効）
- `let`と`const`のブロックスコープ
- クロージャ（スコープの鎖）

### 重要なポイント
1. **内側から外側は見える**: 内側のスコープから外側のスコープの変数は使える
2. **外側から内側は見えない**: 外側のスコープから内側のスコープの変数は使えない
3. **`let`と`const`はブロックスコープ**: `{}`で囲まれた範囲でのみ有効
4. **`var`は関数スコープのみ**: ブロックスコープを持たない
5. **クロージャでデータを保持**: 内側の関数が外側の変数を参照できる

### 次のステップ
次の章では、データ構造（配列・オブジェクト）について詳しく学びます。

---

## 演習問題

### 問題1: スコープの理解
以下のコードの実行結果を予想してください。

```javascript
const global = 'グローバル';

function test() {
    const local = 'ローカル';
    console.log(global);
    console.log(local);
}

test();
console.log(global);
// console.log(local); // どうなる？
```

<details>
<summary>解答例</summary>

```javascript
const global = 'グローバル';

function test() {
    const local = 'ローカル';
    console.log(global);  // 'グローバル'（使える）
    console.log(local);   // 'ローカル'（使える）
}

test();
console.log(global);      // 'グローバル'（使える）
console.log(local);       // ReferenceError（関数の外では使えない）
```
</details>

### 問題2: ブロックスコープ
以下のコードの実行結果を予想してください。

```javascript
if (true) {
    let x = 10;
    const y = 20;
}

console.log(x);
console.log(y);
```

<details>
<summary>解答例</summary>

```javascript
if (true) {
    let x = 10;
    const y = 20;
}

console.log(x);  // ReferenceError（ブロックの外では使えない）
console.log(y);  // ReferenceError（ブロックの外では使えない）
```
</details>

### 問題3: クロージャ
カウンターを作成する関数`createCounter`を作成してください。`increment`メソッドでカウントを増やし、`getCount`メソッドで現在の値を取得できるようにしてください。

<details>
<summary>解答例</summary>

```javascript
function createCounter() {
    let count = 0;
    
    return {
        increment: function() {
            count++;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
```
</details>

### 問題4: ループとスコープ
以下のコードの問題点を説明し、修正してください。

```javascript
for (var i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);
    }, 100);
}
```

<details>
<summary>解答例</summary>

```javascript
// 問題: varはブロックスコープを持たないため、すべての関数が同じiを参照する
// 結果: 3, 3, 3 が表示される

// 修正: letを使う
for (let i = 0; i < 3; i++) {
    setTimeout(function() {
        console.log(i);
    }, 100);
}
// 結果: 0, 1, 2 が表示される（各反復で独立したi）
```
</details>

### 問題5: プライベート変数
プライベート変数を持つオブジェクトを作成してください。`name`と`age`をプライベート変数として持ち、`getName`と`getAge`メソッドで値を取得できるようにしてください。

<details>
<summary>解答例</summary>

```javascript
function createPerson(name, age) {
    // プライベート変数
    let privateName = name;
    let privateAge = age;
    
    return {
        getName: function() {
            return privateName;
        },
        getAge: function() {
            return privateAge;
        },
        setName: function(newName) {
            privateName = newName;
        },
        setAge: function(newAge) {
            privateAge = newAge;
        }
    };
}

const person = createPerson('太郎', 25);
console.log(person.getName()); // '太郎'
console.log(person.getAge());  // 25
```
</details>

---

お疲れ様でした！次の章に進みましょう。

