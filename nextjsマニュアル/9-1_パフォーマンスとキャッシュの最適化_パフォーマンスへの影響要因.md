# 9-1. パフォーマンスとキャッシュの最適化（パフォーマンスへの影響要因）

この章では、Next.jsアプリケーションのパフォーマンスに影響を与える要因について学びます。コンポーネント構造とバンドルサイズを理解することで、より高速なアプリケーションを構築できるようになります。

---

## 目次

- [コンポーネント構造とパフォーマンス](#コンポーネント構造とパフォーマンス)
- [クライアントバンドルサイズの削減](#クライアントバンドルサイズの削減)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## コンポーネント構造とパフォーマンス

### パフォーマンスとは
パフォーマンスは、**アプリケーションの動作速度や応答性**です。適切なコンポーネント構造により、パフォーマンスを向上させられます。

### 日常生活での例
- **交通整理**: 効率的な道路設計（コンポーネント構造）により、交通がスムーズになる（パフォーマンス向上）
- **工場のライン**: 効率的な作業工程（コンポーネント構造）により、生産性が向上する（パフォーマンス向上）
- **図書館の分類**: 効率的な本の配置（コンポーネント構造）により、本を見つけやすくなる（パフォーマンス向上）

### コンポーネント構造がパフォーマンスに与える影響
1. **再レンダリング**: 不要な再レンダリングが発生すると、パフォーマンスが低下
2. **コンポーネントの分割**: 適切に分割することで、必要な部分だけを更新できる
3. **Server ComponentとClient Component**: 適切に使い分けることで、クライアントバンドルサイズを削減

### 実践例: 不要な再レンダリングの防止

```tsx
// ❌ 悪い例: 親コンポーネントが再レンダリングされると、子コンポーネントも再レンダリングされる
// app/components/BadExample.tsx
'use client';

import { useState } from 'react';

function ExpensiveComponent() {
    console.log('ExpensiveComponentが再レンダリングされました');
    // 重い処理をシミュレート
    return <div>高価なコンポーネント</div>;
}

export default function BadExample() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>カウント: {count}</button>
            <ExpensiveComponent /> {/* countが変更されると再レンダリングされる */}
        </div>
    );
}

// ✅ 良い例: React.memoを使用して再レンダリングを防止
// app/components/GoodExample.tsx
'use client';

import { useState, memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent() {
    console.log('ExpensiveComponentが再レンダリングされました');
    return <div>高価なコンポーネント</div>;
});

export default function GoodExample() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>カウント: {count}</button>
            <ExpensiveComponent /> {/* countが変更されても再レンダリングされない */}
        </div>
    );
}
```

### 実践例: Server ComponentとClient Componentの使い分け

```tsx
// ✅ 良い例: Server Componentを使用（クライアントバンドルに含まれない）
// app/components/ServerUserList.tsx
import { prisma } from '@/lib/prisma';

export default async function ServerUserList() {
    // サーバー側でデータを取得
    const users = await prisma.user.findMany();

    return (
        <ul>
            {users.map(user => (
                <li key={user.id}>{user.name}</li>
            ))}
        </ul>
    );
}

// ❌ 悪い例: Client Componentでデータ取得（クライアントバンドルに含まれる）
// app/components/ClientUserList.tsx
'use client';

import { useState, useEffect } from 'react';

export default function ClientUserList() {
    const [users, setUsers] = useState([]);

    useEffect(() => {
        fetch('/api/users')
            .then(res => res.json())
            .then(setUsers);
    }, []);

    return (
        <ul>
            {users.map(user => (
                <li key={user.id}>{user.name}</li>
            ))}
        </ul>
    );
}
```

### 実践例: コンポーネントの適切な分割

```tsx
// ✅ 良い例: コンポーネントを適切に分割
// app/components/UserCard.tsx
import { memo } from 'react';

interface UserCardProps {
    user: {
        id: string;
        name: string;
        email: string;
    };
}

export const UserCard = memo(function UserCard({ user }: UserCardProps) {
    return (
        <div style={{ border: '1px solid #ccc', padding: '16px', margin: '8px' }}>
            <h3>{user.name}</h3>
            <p>{user.email}</p>
        </div>
    );
});

// app/components/UserList.tsx
'use client';

import { useState } from 'react';
import { UserCard } from './UserCard';

export default function UserList({ initialUsers }: { initialUsers: any[] }) {
    const [filter, setFilter] = useState('');

    const filteredUsers = initialUsers.filter(user =>
        user.name.toLowerCase().includes(filter.toLowerCase())
    );

    return (
        <div>
            <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                placeholder="検索..."
            />
            {filteredUsers.map(user => (
                <UserCard key={user.id} user={user} />
            ))}
        </div>
    );
}
```

### 実践例: 動的インポートによる遅延読み込み

```tsx
// app/components/LazyComponent.tsx
'use client';

import { lazy, Suspense } from 'react';

// 動的インポート: 必要な時だけ読み込む
const HeavyComponent = lazy(() => import('./HeavyComponent'));

export default function LazyComponent() {
    const [showHeavy, setShowHeavy] = useState(false);

    return (
        <div>
            <button onClick={() => setShowHeavy(true)}>
                重いコンポーネントを表示
            </button>
            {showHeavy && (
                <Suspense fallback={<div>読み込み中...</div>}>
                    <HeavyComponent />
                </Suspense>
            )}
        </div>
    );
}
```

### 実践例: useMemoとuseCallbackの活用

```tsx
// app/components/OptimizedComponent.tsx
'use client';

import { useState, useMemo, useCallback, memo } from 'react';

interface User {
    id: string;
    name: string;
    age: number;
}

const UserItem = memo(function UserItem({ 
    user, 
    onDelete 
}: { 
    user: User; 
    onDelete: (id: string) => void;
}) {
    return (
        <div>
            <span>{user.name} ({user.age}歳)</span>
            <button onClick={() => onDelete(user.id)}>削除</button>
        </div>
    );
});

export default function OptimizedComponent({ users }: { users: User[] }) {
    const [filter, setFilter] = useState('');

    // useMemo: 計算結果をメモ化
    const filteredUsers = useMemo(() => {
        return users.filter(user =>
            user.name.toLowerCase().includes(filter.toLowerCase())
        );
    }, [users, filter]);

    // useCallback: 関数をメモ化
    const handleDelete = useCallback((id: string) => {
        console.log('削除:', id);
    }, []);

    return (
        <div>
            <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                placeholder="検索..."
            />
            {filteredUsers.map(user => (
                <UserItem 
                    key={user.id} 
                    user={user} 
                    onDelete={handleDelete}
                />
            ))}
        </div>
    );
}
```

---

## クライアントバンドルサイズの削減

### バンドルサイズとは
バンドルサイズは、**ブラウザに送信されるJavaScriptファイルのサイズ**です。バンドルサイズが大きいと、初回読み込みが遅くなります。

### 日常生活での例
- **荷物の量**: 荷物（バンドルサイズ）が少ないと、運搬（読み込み）が速くなる
- **本のページ数**: ページ数（バンドルサイズ）が少ないと、読み込みが速くなる
- **データの転送**: データ量（バンドルサイズ）が少ないと、転送が速くなる

### バンドルサイズがパフォーマンスに与える影響
1. **初回読み込み時間**: バンドルサイズが大きいと、初回読み込みが遅くなる
2. **ネットワーク使用量**: バンドルサイズが大きいと、ネットワーク使用量が増える
3. **メモリ使用量**: バンドルサイズが大きいと、メモリ使用量が増える

### 実践例: 動的インポートによるコード分割

```tsx
// ❌ 悪い例: すべてを静的にインポート
// app/components/AllImports.tsx
'use client';

import { Chart } from 'chart.js';
import { DatePicker } from 'react-datepicker';
import { Editor } from 'react-draft-wysiwyg';

export default function AllImports() {
    return (
        <div>
            {/* すべてのライブラリがバンドルに含まれる */}
        </div>
    );
}

// ✅ 良い例: 動的インポートを使用
// app/components/DynamicImports.tsx
'use client';

import { lazy, Suspense, useState } from 'react';

// 必要な時だけ読み込む
const Chart = lazy(() => import('chart.js').then(mod => ({ default: mod.Chart })));
const DatePicker = lazy(() => import('react-datepicker').then(mod => ({ default: mod.DatePicker })));
const Editor = lazy(() => import('react-draft-wysiwyg').then(mod => ({ default: mod.Editor })));

export default function DynamicImports() {
    const [showChart, setShowChart] = useState(false);
    const [showDatePicker, setShowDatePicker] = useState(false);
    const [showEditor, setShowEditor] = useState(false);

    return (
        <div>
            <button onClick={() => setShowChart(true)}>チャートを表示</button>
            {showChart && (
                <Suspense fallback={<div>読み込み中...</div>}>
                    <Chart />
                </Suspense>
            )}

            <button onClick={() => setShowDatePicker(true)}>日付選択を表示</button>
            {showDatePicker && (
                <Suspense fallback={<div>読み込み中...</div>}>
                    <DatePicker />
                </Suspense>
            )}

            <button onClick={() => setShowEditor(true)}>エディタを表示</button>
            {showEditor && (
                <Suspense fallback={<div>読み込み中...</div>}>
                    <Editor />
                </Suspense>
            )}
        </div>
    );
}
```

### 実践例: Server Componentの活用

```tsx
// ✅ 良い例: Server Componentを使用（クライアントバンドルに含まれない）
// app/components/ServerDataDisplay.tsx
import { prisma } from '@/lib/prisma';

export default async function ServerDataDisplay() {
    // サーバー側でデータを取得（クライアントバンドルに含まれない）
    const data = await prisma.post.findMany();

    return (
        <div>
            <h2>投稿一覧</h2>
            <ul>
                {data.map(post => (
                    <li key={post.id}>{post.title}</li>
                ))}
            </ul>
        </div>
    );
}

// ❌ 悪い例: Client Componentでデータ取得（クライアントバンドルに含まれる）
// app/components/ClientDataDisplay.tsx
'use client';

import { useState, useEffect } from 'react';

export default function ClientDataDisplay() {
    const [data, setData] = useState([]);

    useEffect(() => {
        // fetch APIがクライアントバンドルに含まれる
        fetch('/api/posts')
            .then(res => res.json())
            .then(setData);
    }, []);

    return (
        <div>
            <h2>投稿一覧</h2>
            <ul>
                {data.map((post: any) => (
                    <li key={post.id}>{post.title}</li>
                ))}
            </ul>
        </div>
    );
}
```

### 実践例: 不要なライブラリの削除

```tsx
// ❌ 悪い例: 大きなライブラリを全体でインポート
// app/components/BadImport.tsx
'use client';

import _ from 'lodash'; // 大きなライブラリを全体でインポート

export default function BadImport() {
    const result = _.chunk([1, 2, 3, 4, 5], 2);
    return <div>{JSON.stringify(result)}</div>;
}

// ✅ 良い例: 必要な関数だけをインポート
// app/components/GoodImport.tsx
'use client';

import chunk from 'lodash/chunk'; // 必要な関数だけをインポート

export default function GoodImport() {
    const result = chunk([1, 2, 3, 4, 5], 2);
    return <div>{JSON.stringify(result)}</div>;
}
```

### 実践例: バンドルサイズの分析

```bash
# Next.jsのバンドルサイズを分析
npm run build

# ビルド後に、.next/analyze ディレクトリに分析結果が生成される
# または、@next/bundle-analyzer を使用

# @next/bundle-analyzerのインストール
npm install @next/bundle-analyzer

# next.config.jsの設定
const withBundleAnalyzer = require('@next/bundle-analyzer')({
    enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
    // Next.jsの設定
});

# 分析を実行
ANALYZE=true npm run build
```

### 実践例: ツリ-shakingの活用

```tsx
// ✅ 良い例: ツリ-shakingが効くインポート
// app/components/TreeShaking.tsx
'use client';

// 必要な関数だけをインポート（ツリ-shakingが効く）
import { format } from 'date-fns';
import { add } from 'date-fns';

export default function TreeShaking() {
    const date = new Date();
    const formatted = format(date, 'yyyy-MM-dd');
    const future = add(date, { days: 7 });

    return (
        <div>
            <p>現在: {formatted}</p>
            <p>1週間後: {format(future, 'yyyy-MM-dd')}</p>
        </div>
    );
}

// ❌ 悪い例: 全体をインポート（ツリ-shakingが効かない）
// app/components/NoTreeShaking.tsx
'use client';

import * as dateFns from 'date-fns'; // 全体をインポート

export default function NoTreeShaking() {
    const date = new Date();
    const formatted = dateFns.format(date, 'yyyy-MM-dd');

    return <div>{formatted}</div>;
}
```

### 実践例: 外部ライブラリの代替

```tsx
// ❌ 悪い例: 大きなライブラリを使用
// app/components/HeavyLibrary.tsx
'use client';

import moment from 'moment'; // 大きなライブラリ

export default function HeavyLibrary() {
    return <div>{moment().format('YYYY-MM-DD')}</div>;
}

// ✅ 良い例: 軽量な代替を使用
// app/components/LightAlternative.tsx
'use client';

import { format } from 'date-fns'; // 軽量なライブラリ

export default function LightAlternative() {
    return <div>{format(new Date(), 'yyyy-MM-dd')}</div>;
}
```

### 実践例: 画像の最適化

```tsx
// ✅ 良い例: next/imageを使用（自動最適化）
// app/components/OptimizedImage.tsx
import Image from 'next/image';

export default function OptimizedImage() {
    return (
        <Image
            src="/image.jpg"
            alt="画像"
            width={800}
            height={600}
            // 自動的に最適化される
        />
    );
}

// ❌ 悪い例: 通常のimgタグを使用（最適化されない）
// app/components/UnoptimizedImage.tsx
export default function UnoptimizedImage() {
    return (
        <img 
            src="/image.jpg" 
            alt="画像"
            // 最適化されない
        />
    );
}
```

### 実践例: フォントの最適化

```tsx
// ✅ 良い例: next/fontを使用（自動最適化）
// app/layout.tsx
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="ja" className={inter.className}>
            <body>{children}</body>
        </html>
    );
}

// ❌ 悪い例: CDNからフォントを読み込む（最適化されない）
// app/layout.tsx
export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html lang="ja">
            <head>
                <link
                    href="https://fonts.googleapis.com/css2?family=Inter&display=swap"
                    rel="stylesheet"
                />
            </head>
            <body>{children}</body>
        </html>
    );
}
```

---

## まとめ

この章では、パフォーマンスへの影響要因について以下のことを学びました。

### コンポーネント構造とパフォーマンス
- **再レンダリング**: 不要な再レンダリングを防止することで、パフォーマンスが向上
- **React.memo**: コンポーネントの再レンダリングを防止
- **Server ComponentとClient Component**: 適切に使い分けることで、クライアントバンドルサイズを削減
- **コンポーネントの分割**: 適切に分割することで、必要な部分だけを更新できる
- **動的インポート**: 必要な時だけコンポーネントを読み込む
- **useMemoとuseCallback**: 計算結果や関数をメモ化して、再計算を防止

### クライアントバンドルサイズの削減
- **動的インポート**: 必要な時だけライブラリを読み込む
- **Server Component**: サーバー側で処理することで、クライアントバンドルに含めない
- **ツリ-shaking**: 必要な関数だけをインポート
- **軽量な代替**: 大きなライブラリの代わりに軽量なライブラリを使用
- **画像の最適化**: `next/image`を使用して自動最適化
- **フォントの最適化**: `next/font`を使用して自動最適化

### パフォーマンス最適化のメリット
- **初回読み込み時間**: バンドルサイズを削減することで、初回読み込みが速くなる
- **ユーザー体験**: 高速なアプリケーションにより、ユーザー体験が向上
- **ネットワーク使用量**: バンドルサイズを削減することで、ネットワーク使用量が減る
- **メモリ使用量**: バンドルサイズを削減することで、メモリ使用量が減る

### 次のステップ
パフォーマンスへの影響要因を理解したら、次のトピックに進みましょう：
- Next.jsのキャッシュシステム（9-2）
- レンダリング戦略の最適化（9-3）
- アセットの最適化（9-4）

---

## 演習問題

以下の問題を解いて、パフォーマンスへの影響要因の理解を深めましょう。

### 問題1: React.memoの使用
再レンダリングを防止するために、`React.memo`を使用したコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/components/MemoizedComponent.tsx
'use client';

import { memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ 
    data 
}: { 
    data: string 
}) {
    return <div>{data}</div>;
});

export default function ParentComponent() {
    const [count, setCount] = useState(0);
    const data = '固定データ';

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>カウント: {count}</button>
            <ExpensiveComponent data={data} />
        </div>
    );
}
```
</details>

### 問題2: 動的インポート
重いコンポーネントを動的インポートで読み込むコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/components/LazyComponent.tsx
'use client';

import { lazy, Suspense, useState } from 'react';

const HeavyComponent = lazy(() => import('./HeavyComponent'));

export default function LazyComponent() {
    const [show, setShow] = useState(false);

    return (
        <div>
            <button onClick={() => setShow(true)}>表示</button>
            {show && (
                <Suspense fallback={<div>読み込み中...</div>}>
                    <HeavyComponent />
                </Suspense>
            )}
        </div>
    );
}
```
</details>

### 問題3: Server Componentの活用
Server Componentを使用して、データを表示するコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/components/ServerData.tsx
import { prisma } from '@/lib/prisma';

export default async function ServerData() {
    const posts = await prisma.post.findMany();

    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}
```
</details>

### 問題4: useMemoの使用
計算結果をメモ化するコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/components/MemoizedCalculation.tsx
'use client';

import { useState, useMemo } from 'react';

export default function MemoizedCalculation({ numbers }: { numbers: number[] }) {
    const [filter, setFilter] = useState('');

    const filteredNumbers = useMemo(() => {
        return numbers.filter(n => n.toString().includes(filter));
    }, [numbers, filter]);

    return (
        <div>
            <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
            />
            <ul>
                {filteredNumbers.map((n, i) => (
                    <li key={i}>{n}</li>
                ))}
            </ul>
        </div>
    );
}
```
</details>

### 問題5: next/imageの使用
`next/image`を使用して、画像を最適化して表示してください。

<details>
<summary>解答例</summary>

```tsx
// app/components/OptimizedImage.tsx
import Image from 'next/image';

export default function OptimizedImage() {
    return (
        <Image
            src="/image.jpg"
            alt="画像"
            width={800}
            height={600}
            priority={false}
        />
    );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。

