# 6-3. 高度なUIフィードバック

この章では、Server Actionを使った高度なUIフィードバックについて学びます。エラーハンドリング、Toast/Alert表示、楽観的UI更新、フォームバリデーションを理解することで、ユーザーフレンドリーなUIを実装できるようになります。

---

## 目次

- [Server Actionのエラーハンドリング](#server-actionのエラーハンドリング)
- [フィードバックUI表示 (Toast, Alert)](#フィードバックui表示-toast-alert)
- [`useOptimistic` による楽観的UI更新](#useoptimistic-による楽観的ui更新)
- [Server ActionのFormバリデーション](#server-actionのformバリデーション)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Server Actionのエラーハンドリング

### エラーハンドリングとは
エラーハンドリングは、**Server Actionで発生したエラーを適切に処理し、ユーザーに分かりやすく表示する**機能です。

### 日常生活での例
- **エラーメッセージ**: 操作が失敗したときに表示されるメッセージ
- **確認ダイアログ**: 操作を確認するためのダイアログ
- **通知**: 操作の結果を通知するメッセージ

### 基本的なエラーハンドリング

```tsx
// app/actions.ts
'use server';

export async function createPost(data: FormData) {
  try {
    const title = data.get('title') as string;
    const content = data.get('content') as string;
    
    if (!title || !content) {
      return {
        success: false,
        error: 'タイトルと内容は必須です',
      };
    }
    
    // データベースに保存
    // const post = await prisma.post.create({ ... });
    
    return {
      success: true,
      message: '投稿が作成されました',
    };
  } catch (error) {
    return {
      success: false,
      error: '投稿の作成に失敗しました',
    };
  }
}
```

### 実践例: Server Actionのエラーハンドリング

#### try-catchを使ったエラーハンドリング

```tsx
// app/actions.ts
'use server';

import { prisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';

export async function createPost(data: FormData) {
  try {
    const title = data.get('title') as string;
    const content = data.get('content') as string;
    const authorId = parseInt(data.get('authorId') as string);
    
    // バリデーション
    if (!title || title.trim().length === 0) {
      return {
        success: false,
        error: 'タイトルは必須です',
      };
    }
    
    if (!content || content.trim().length === 0) {
      return {
        success: false,
        error: '内容は必須です',
      };
    }
    
    // データベースに保存
    const post = await prisma.post.create({
      data: {
        title,
        content,
        authorId,
      },
    });
    
    revalidatePath('/posts');
    
    return {
      success: true,
      message: '投稿が作成されました',
      data: post,
    };
  } catch (error) {
    console.error('投稿作成エラー:', error);
    
    // エラーの種類に応じてメッセージを変更
    if (error instanceof Error) {
      return {
        success: false,
        error: error.message,
      };
    }
    
    return {
      success: false,
      error: '投稿の作成に失敗しました',
    };
  }
}

// app/posts/new/page.tsx
'use client';

import { useState } from 'react';
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (formData: FormData) => {
    setIsSubmitting(true);
    setError(null);
    setSuccess(null);
    
    const result = await createPost(formData);
    
    if (result.success) {
      setSuccess(result.message || '投稿が作成されました');
      // フォームをリセット
      const form = document.getElementById('post-form') as HTMLFormElement;
      form?.reset();
    } else {
      setError(result.error || 'エラーが発生しました');
    }
    
    setIsSubmitting(false);
  };
  
  return (
    <div>
      <h1>新規投稿</h1>
      
      {error && (
        <div className="error-message">
          {error}
        </div>
      )}
      
      {success && (
        <div className="success-message">
          {success}
        </div>
      )}
      
      <form id="post-form" action={handleSubmit}>
        <label>
          タイトル
          <input type="text" name="title" required />
        </label>
        <label>
          内容
          <textarea name="content" required />
        </label>
        <input type="hidden" name="authorId" value="1" />
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? '送信中...' : '投稿する'}
        </button>
      </form>
    </div>
  );
}
```

#### useFormStateを使ったエラーハンドリング

```tsx
// app/actions.ts
'use server';

import { prisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';

interface ActionResult {
  success: boolean;
  error?: string;
  message?: string;
}

export async function updatePost(
  prevState: ActionResult | null,
  formData: FormData
): Promise<ActionResult> {
  try {
    const id = parseInt(formData.get('id') as string);
    const title = formData.get('title') as string;
    const content = formData.get('content') as string;
    
    if (!title || title.trim().length === 0) {
      return {
        success: false,
        error: 'タイトルは必須です',
      };
    }
    
    const post = await prisma.post.update({
      where: { id },
      data: { title, content },
    });
    
    revalidatePath('/posts');
    revalidatePath(`/posts/${id}`);
    
    return {
      success: true,
      message: '投稿が更新されました',
    };
  } catch (error) {
    return {
      success: false,
      error: '投稿の更新に失敗しました',
    };
  }
}

// app/posts/[id]/edit/page.tsx
'use client';

import { useFormState } from 'react-dom';
import { updatePost } from '@/app/actions';

export default function EditPostPage({ id }: { id: number }) {
  const [state, formAction] = useFormState(updatePost, null);
  
  return (
    <div>
      <h1>投稿編集</h1>
      
      {state?.error && (
        <div className="error-message">
          {state.error}
        </div>
      )}
      
      {state?.success && (
        <div className="success-message">
          {state.message}
        </div>
      )}
      
      <form action={formAction}>
        <input type="hidden" name="id" value={id} />
        <label>
          タイトル
          <input type="text" name="title" required />
        </label>
        <label>
          内容
          <textarea name="content" required />
        </label>
        <button type="submit">更新</button>
      </form>
    </div>
  );
}
```

---

## フィードバックUI表示 (Toast, Alert)

### Toast/Alertとは
Toast/Alertは、**操作の結果を一時的に表示するUIコンポーネント**です。成功、エラー、警告などのメッセージを表示します。

### 実践例: Toast/Alertコンポーネント

#### 基本的なToastコンポーネント

```tsx
// components/ui/Toast.tsx
'use client';

import { useEffect, useState } from 'react';

type ToastType = 'success' | 'error' | 'warning' | 'info';

interface ToastProps {
  message: string;
  type: ToastType;
  duration?: number;
  onClose: () => void;
}

export default function Toast({
  message,
  type,
  duration = 3000,
  onClose,
}: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(() => {
      onClose();
    }, duration);
    
    return () => clearTimeout(timer);
  }, [duration, onClose]);
  
  return (
    <div className={`toast toast-${type}`}>
      <span>{message}</span>
      <button onClick={onClose} className="toast-close">
        ×
      </button>
    </div>
  );
}

// components/ui/ToastProvider.tsx
'use client';

import { createContext, useContext, useState, ReactNode } from 'react';
import Toast from './Toast';

type ToastType = 'success' | 'error' | 'warning' | 'info';

interface ToastItem {
  id: string;
  message: string;
  type: ToastType;
}

interface ToastContextType {
  showToast: (message: string, type: ToastType) => void;
}

const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function ToastProvider({ children }: { children: ReactNode }) {
  const [toasts, setToasts] = useState<ToastItem[]>([]);
  
  const showToast = (message: string, type: ToastType) => {
    const id = Math.random().toString(36).substring(7);
    setToasts(prev => [...prev, { id, message, type }]);
  };
  
  const removeToast = (id: string) => {
    setToasts(prev => prev.filter(toast => toast.id !== id));
  };
  
  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      <div className="toast-container">
        {toasts.map(toast => (
          <Toast
            key={toast.id}
            message={toast.message}
            type={toast.type}
            onClose={() => removeToast(toast.id)}
          />
        ))}
      </div>
    </ToastContext.Provider>
  );
}

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within ToastProvider');
  }
  return context;
}

// app/layout.tsx
import { ToastProvider } from '@/components/ui/ToastProvider';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html>
      <body>
        <ToastProvider>
          {children}
        </ToastProvider>
      </body>
    </html>
  );
}

// app/posts/new/page.tsx
'use client';

import { useToast } from '@/components/ui/ToastProvider';
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  const { showToast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (formData: FormData) => {
    setIsSubmitting(true);
    
    const result = await createPost(formData);
    
    if (result.success) {
      showToast(result.message || '投稿が作成されました', 'success');
    } else {
      showToast(result.error || 'エラーが発生しました', 'error');
    }
    
    setIsSubmitting(false);
  };
  
  return (
    <div>
      <h1>新規投稿</h1>
      <form action={handleSubmit}>
        <label>
          タイトル
          <input type="text" name="title" required />
        </label>
        <label>
          内容
          <textarea name="content" required />
        </label>
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? '送信中...' : '投稿する'}
        </button>
      </form>
    </div>
  );
}
```

#### Alertコンポーネント

```tsx
// components/ui/Alert.tsx
'use client';

type AlertType = 'success' | 'error' | 'warning' | 'info';

interface AlertProps {
  type: AlertType;
  title?: string;
  message: string;
  onClose?: () => void;
}

export default function Alert({
  type,
  title,
  message,
  onClose,
}: AlertProps) {
  return (
    <div className={`alert alert-${type}`}>
      {title && <h3>{title}</h3>}
      <p>{message}</p>
      {onClose && (
        <button onClick={onClose} className="alert-close">
          ×
        </button>
      )}
    </div>
  );
}

// 使用例
// app/posts/new/page.tsx
'use client';

import { useState } from 'react';
import Alert from '@/components/ui/Alert';
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  const [alert, setAlert] = useState<{
    type: AlertType;
    message: string;
  } | null>(null);
  
  const handleSubmit = async (formData: FormData) => {
    const result = await createPost(formData);
    
    if (result.success) {
      setAlert({
        type: 'success',
        message: result.message || '投稿が作成されました',
      });
    } else {
      setAlert({
        type: 'error',
        message: result.error || 'エラーが発生しました',
      });
    }
  };
  
  return (
    <div>
      <h1>新規投稿</h1>
      
      {alert && (
        <Alert
          type={alert.type}
          message={alert.message}
          onClose={() => setAlert(null)}
        />
      )}
      
      <form action={handleSubmit}>
        <label>
          タイトル
          <input type="text" name="title" required />
        </label>
        <label>
          内容
          <textarea name="content" required />
        </label>
        <button type="submit">投稿する</button>
      </form>
    </div>
  );
}
```

### Toast/Alertのスタイリング

```css
/* styles/toast.css */

.toast-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.toast {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  min-width: 300px;
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

.toast-success {
  background: #4caf50;
  color: white;
}

.toast-error {
  background: #f44336;
  color: white;
}

.toast-warning {
  background: #ff9800;
  color: white;
}

.toast-info {
  background: #2196f3;
  color: white;
}

.toast-close {
  background: none;
  border: none;
  color: inherit;
  font-size: 20px;
  cursor: pointer;
  margin-left: 8px;
}

/* styles/alert.css */

.alert {
  padding: 16px;
  border-radius: 4px;
  margin-bottom: 16px;
  position: relative;
}

.alert-success {
  background: #e8f5e9;
  border: 1px solid #4caf50;
  color: #2e7d32;
}

.alert-error {
  background: #ffebee;
  border: 1px solid #f44336;
  color: #c62828;
}

.alert-warning {
  background: #fff3e0;
  border: 1px solid #ff9800;
  color: #e65100;
}

.alert-info {
  background: #e3f2fd;
  border: 1px solid #2196f3;
  color: #1565c0;
}

.alert h3 {
  margin: 0 0 8px 0;
  font-size: 1.1rem;
}

.alert p {
  margin: 0;
}

.alert-close {
  position: absolute;
  top: 8px;
  right: 8px;
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: inherit;
}
```

---

## `useOptimistic` による楽観的UI更新

### useOptimisticとは
`useOptimistic`は、**Server Actionの完了を待たずに、UIを即座に更新する**Reactフックです。ユーザー体験を向上させます。

### 日常生活での例
- **いいねボタン**: クリックした瞬間にUIが更新される
- **コメント投稿**: 投稿した瞬間にコメントが表示される
- **フォロー**: フォローボタンをクリックした瞬間にUIが更新される

### 基本的なuseOptimistic

```tsx
// app/posts/[id]/page.tsx
'use client';

import { useOptimistic } from 'react';
import { likePost } from '@/app/actions';

export default function PostPage({ post }: { post: Post }) {
  const [optimisticPost, addOptimisticLike] = useOptimistic(
    post,
    (state, newLike: number) => ({
      ...state,
      likes: state.likes + newLike,
    })
  );
  
  const handleLike = async () => {
    addOptimisticLike(1);
    await likePost(post.id);
  };
  
  return (
    <div>
      <h1>{optimisticPost.title}</h1>
      <button onClick={handleLike}>
        いいね {optimisticPost.likes}
      </button>
    </div>
  );
}
```

### 実践例: useOptimistic

#### コメントの楽観的更新

```tsx
// app/actions.ts
'use server';

import { prisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';

export async function addComment(postId: number, content: string) {
  const comment = await prisma.comment.create({
    data: {
      postId,
      content,
      authorId: 1, // 実際の実装では認証から取得
    },
    include: {
      author: {
        select: {
          id: true,
          name: true,
        },
      },
    },
  });
  
  revalidatePath(`/posts/${postId}`);
  
  return comment;
}

// app/posts/[id]/page.tsx
'use client';

import { useOptimistic, useTransition } from 'react';
import { addComment } from '@/app/actions';

interface Comment {
  id: number;
  content: string;
  author: {
    id: number;
    name: string;
  };
  createdAt: Date;
}

interface Post {
  id: number;
  title: string;
  content: string;
  comments: Comment[];
}

export default function PostPage({ post }: { post: Post }) {
  const [isPending, startTransition] = useTransition();
  const [optimisticPost, addOptimisticComment] = useOptimistic(
    post,
    (state, newComment: Comment) => ({
      ...state,
      comments: [...state.comments, newComment],
    })
  );
  
  const handleSubmit = async (formData: FormData) => {
    const content = formData.get('content') as string;
    
    if (!content || content.trim().length === 0) {
      return;
    }
    
    // 楽観的更新
    const optimisticComment: Comment = {
      id: Date.now(), // 一時的なID
      content,
      author: {
        id: 1,
        name: 'あなた',
      },
      createdAt: new Date(),
    };
    
    addOptimisticComment(optimisticComment);
    
    // Server Actionを実行
    startTransition(async () => {
      await addComment(post.id, content);
    });
  };
  
  return (
    <div>
      <h1>{optimisticPost.title}</h1>
      <p>{optimisticPost.content}</p>
      
      <h2>コメント</h2>
      <ul>
        {optimisticPost.comments.map(comment => (
          <li key={comment.id}>
            <strong>{comment.author.name}</strong>
            <p>{comment.content}</p>
            <time>{comment.createdAt.toLocaleString()}</time>
          </li>
        ))}
      </ul>
      
      <form action={handleSubmit}>
        <textarea name="content" required />
        <button type="submit" disabled={isPending}>
          {isPending ? '送信中...' : 'コメントする'}
        </button>
      </form>
    </div>
  );
}
```

#### いいねの楽観的更新

```tsx
// app/actions.ts
'use server';

import { prisma } from '@/lib/prisma';
import { revalidatePath } from 'next/cache';

export async function toggleLike(postId: number) {
  // 実際の実装では、ユーザーIDと既存のいいねを確認
  const post = await prisma.post.findUnique({
    where: { id: postId },
  });
  
  if (!post) {
    throw new Error('投稿が見つかりません');
  }
  
  // いいねをトグル
  const updatedPost = await prisma.post.update({
    where: { id: postId },
    data: {
      likes: post.likes + 1,
    },
  });
  
  revalidatePath(`/posts/${postId}`);
  
  return updatedPost;
}

// app/posts/[id]/page.tsx
'use client';

import { useOptimistic, useTransition } from 'react';
import { toggleLike } from '@/app/actions';

interface Post {
  id: number;
  title: string;
  likes: number;
}

export default function PostPage({ post }: { post: Post }) {
  const [isPending, startTransition] = useTransition();
  const [optimisticPost, addOptimisticLike] = useOptimistic(
    post,
    (state, increment: number) => ({
      ...state,
      likes: state.likes + increment,
    })
  );
  
  const handleLike = () => {
    addOptimisticLike(1);
    
    startTransition(async () => {
      await toggleLike(post.id);
    });
  };
  
  return (
    <div>
      <h1>{optimisticPost.title}</h1>
      <button onClick={handleLike} disabled={isPending}>
        いいね {optimisticPost.likes}
      </button>
    </div>
  );
}
```

---

## Server ActionのFormバリデーション

### フォームバリデーションとは
フォームバリデーションは、**フォームの入力値を検証し、エラーを表示する**機能です。クライアントサイドとサーバーサイドの両方で実装します。

### 実践例: Server ActionのFormバリデーション

#### 基本的なバリデーション

```tsx
// app/actions.ts
'use server';

import { z } from 'zod';

const postSchema = z.object({
  title: z.string().min(1, 'タイトルは必須です').max(100, 'タイトルは100文字以内です'),
  content: z.string().min(1, '内容は必須です').max(1000, '内容は1000文字以内です'),
});

export async function createPost(data: FormData) {
  const title = data.get('title') as string;
  const content = data.get('content') as string;
  
  // バリデーション
  const result = postSchema.safeParse({ title, content });
  
  if (!result.success) {
    return {
      success: false,
      errors: result.error.flatten().fieldErrors,
    };
  }
  
  // データベースに保存
  // const post = await prisma.post.create({ ... });
  
  return {
    success: true,
    message: '投稿が作成されました',
  };
}

// app/posts/new/page.tsx
'use client';

import { useState } from 'react';
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  const [errors, setErrors] = useState<Record<string, string[]>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleSubmit = async (formData: FormData) => {
    setIsSubmitting(true);
    setErrors({});
    
    const result = await createPost(formData);
    
    if (!result.success && result.errors) {
      setErrors(result.errors);
    } else if (result.success) {
      // 成功時の処理
      alert(result.message);
    }
    
    setIsSubmitting(false);
  };
  
  return (
    <div>
      <h1>新規投稿</h1>
      
      <form action={handleSubmit}>
        <label>
          タイトル
          <input type="text" name="title" required />
          {errors.title && (
            <span className="error">{errors.title[0]}</span>
          )}
        </label>
        
        <label>
          内容
          <textarea name="content" required />
          {errors.content && (
            <span className="error">{errors.content[0]}</span>
          )}
        </label>
        
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? '送信中...' : '投稿する'}
        </button>
      </form>
    </div>
  );
}
```

#### useFormStateを使ったバリデーション

```tsx
// app/actions.ts
'use server';

import { z } from 'zod';

const postSchema = z.object({
  title: z.string().min(1, 'タイトルは必須です'),
  content: z.string().min(1, '内容は必須です'),
});

interface ActionResult {
  success: boolean;
  errors?: Record<string, string[]>;
  message?: string;
}

export async function createPost(
  prevState: ActionResult | null,
  formData: FormData
): Promise<ActionResult> {
  const title = formData.get('title') as string;
  const content = formData.get('content') as string;
  
  const result = postSchema.safeParse({ title, content });
  
  if (!result.success) {
    return {
      success: false,
      errors: result.error.flatten().fieldErrors,
    };
  }
  
  // データベースに保存
  // const post = await prisma.post.create({ ... });
  
  return {
    success: true,
    message: '投稿が作成されました',
  };
}

// app/posts/new/page.tsx
'use client';

import { useFormState } from 'react-dom';
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  const [state, formAction] = useFormState(createPost, null);
  
  return (
    <div>
      <h1>新規投稿</h1>
      
      {state?.success && (
        <div className="success-message">
          {state.message}
        </div>
      )}
      
      <form action={formAction}>
        <label>
          タイトル
          <input type="text" name="title" required />
          {state?.errors?.title && (
            <span className="error">{state.errors.title[0]}</span>
          )}
        </label>
        
        <label>
          内容
          <textarea name="content" required />
          {state?.errors?.content && (
            <span className="error">{state.errors.content[0]}</span>
          )}
        </label>
        
        <button type="submit">投稿する</button>
      </form>
    </div>
  );
}
```

---

## まとめ

この章では、Server Actionを使った高度なUIフィードバックについて学びました。

### 学んだこと
- **エラーハンドリング**: try-catch、useFormStateを使ったエラー処理
- **Toast/Alert**: 操作の結果を表示するUIコンポーネント
- **useOptimistic**: 楽観的UI更新によるUX向上
- **フォームバリデーション**: Zodを使ったバリデーション

### 重要なポイント
1. **エラーハンドリング**: 適切なエラーメッセージを表示
2. **Toast/Alert**: 操作の結果を分かりやすく表示
3. **useOptimistic**: 即座にUIを更新してUXを向上
4. **バリデーション**: クライアントとサーバーの両方で実装
5. **ユーザー体験**: フィードバックでユーザー体験を向上

### 使い分けの目安
- **エラーハンドリング**: エラーを適切に処理して表示
- **Toast**: 一時的な通知に使用
- **Alert**: 重要なメッセージに使用
- **useOptimistic**: 即座にUIを更新したい場合

### 次のステップ
高度なUIフィードバックを理解することで、ユーザーフレンドリーなUIを実装できるようになります。次の章では、Revalidate (再検証) の設計について詳しく学びます。

---

## 演習問題

### 問題1: エラーハンドリングの実装
Server Actionでエラーハンドリングを実装し、エラーメッセージを表示してください。

<details>
<summary>解答例</summary>

```tsx
// app/actions.ts
'use server';

export async function createPost(data: FormData) {
  try {
    const title = data.get('title') as string;
    
    if (!title) {
      return {
        success: false,
        error: 'タイトルは必須です',
      };
    }
    
    // データベースに保存
    return {
      success: true,
      message: '投稿が作成されました',
    };
  } catch (error) {
    return {
      success: false,
      error: '投稿の作成に失敗しました',
    };
  }
}
```
</details>

### 問題2: Toastコンポーネントの実装
Toastコンポーネントを実装し、成功・エラーメッセージを表示してください。

<details>
<summary>解答例</summary>

```tsx
// components/ui/Toast.tsx
'use client';

interface ToastProps {
  message: string;
  type: 'success' | 'error';
  onClose: () => void;
}

export default function Toast({ message, type, onClose }: ToastProps) {
  return (
    <div className={`toast toast-${type}`}>
      <span>{message}</span>
      <button onClick={onClose}>×</button>
    </div>
  );
}
```
</details>

### 問題3: useOptimisticの実装
useOptimisticを使って、いいねボタンの楽観的更新を実装してください。

<details>
<summary>解答例</summary>

```tsx
'use client';

import { useOptimistic } from 'react';

export default function LikeButton({ post }: { post: { id: number; likes: number } }) {
  const [optimisticPost, addOptimisticLike] = useOptimistic(
    post,
    (state, increment: number) => ({
      ...state,
      likes: state.likes + increment,
    })
  );
  
  const handleLike = () => {
    addOptimisticLike(1);
    // Server Actionを実行
  };
  
  return (
    <button onClick={handleLike}>
      いいね {optimisticPost.likes}
    </button>
  );
}
```
</details>

### 問題4: フォームバリデーションの実装
Zodを使って、フォームのバリデーションを実装してください。

<details>
<summary>解答例</summary>

```tsx
// app/actions.ts
'use server';

import { z } from 'zod';

const schema = z.object({
  title: z.string().min(1, 'タイトルは必須です'),
});

export async function createPost(data: FormData) {
  const title = data.get('title') as string;
  
  const result = schema.safeParse({ title });
  
  if (!result.success) {
    return {
      success: false,
      errors: result.error.flatten().fieldErrors,
    };
  }
  
  return { success: true };
}
```
</details>

### 問題5: useFormStateを使ったバリデーション
useFormStateを使って、フォームのバリデーションとエラー表示を実装してください。

<details>
<summary>解答例</summary>

```tsx
'use client';

import { useFormState } from 'react-dom';
import { createPost } from '@/app/actions';

export default function NewPostPage() {
  const [state, formAction] = useFormState(createPost, null);
  
  return (
    <form action={formAction}>
      <input type="text" name="title" />
      {state?.errors?.title && (
        <span>{state.errors.title[0]}</span>
      )}
      <button type="submit">投稿</button>
    </form>
  );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。

