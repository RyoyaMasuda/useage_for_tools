# 5-2. レンダリングと挙動

この章では、Next.jsのApp RouterにおけるRoute Handlerのレンダリングと挙動について学びます。Route Handlerが静的（Static）と動的（Dynamic）のどちらでレンダリングされるかを理解し、Request/Responseオブジェクトを適切に操作することで、効率的で柔軟なAPIエンドポイントを構築できるようになります。

---

## 目次

- [Route Handlerのレンダリング (Static vs Dynamic)](#route-handlerのレンダリング-static-vs-dynamic)
- [Request / Response オブジェクトの操作](#request--response-オブジェクトの操作)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Route Handlerのレンダリング (Static vs Dynamic)

### レンダリングモードとは
Route Handlerは、**静的（Static）と動的（Dynamic）の2つのレンダリングモード**を持ちます。どちらのモードでレンダリングされるかは、Route Handler内で使用される機能によって自動的に決定されます。

### Static Rendering（静的レンダリング）

Static Renderingは、**ビルド時にRoute Handlerを事前レンダリング**するモードです。同じリクエストに対して常に同じレスポンスを返します。

#### Static Renderingの特徴
- **ビルド時レンダリング**: ビルド時にRoute Handlerが実行される
- **キャッシュ可能**: レスポンスがキャッシュされる
- **高速**: 事前レンダリングされた結果を返すため高速
- **制限**: 動的なデータやリクエスト固有の情報は使用できない

#### 実践例: Static Route Handler

```tsx
// app/api/hello/route.ts
import { NextResponse } from 'next/server'

// このRoute Handlerは静的レンダリングされる
export async function GET() {
  return NextResponse.json({
    message: 'Hello, Next.js!',
    timestamp: new Date().toISOString(), // ビルド時のタイムスタンプ
  })
}
```

このRoute Handlerは静的レンダリングされ、ビルド時に実行されます。`timestamp`はビルド時の値が固定されます。

### Dynamic Rendering（動的レンダリング）

Dynamic Renderingは、**リクエストごとにRoute Handlerを実行**するモードです。リクエスト固有のデータや動的なデータを処理できます。

#### Dynamic Renderingが有効になる条件

Route Handlerが以下のいずれかを使用すると、動的レンダリングになります：

1. **Requestオブジェクトの使用**: `request`パラメータを使用
2. **動的関数の使用**: `cookies()`、`headers()`、`searchParams`など
3. **環境変数の動的読み込み**: `process.env`の動的な使用
4. **`export const dynamic = 'force-dynamic'`**: 明示的に動的レンダリングを指定

#### 実践例: Dynamic Route Handler

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

// Requestオブジェクトを使用しているため、動的レンダリングになる
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const page = searchParams.get('page') || '1'

  return NextResponse.json({
    page: parseInt(page),
    message: '動的レンダリング',
    timestamp: new Date().toISOString(), // リクエストごとに異なる値
  })
}
```

このRoute Handlerは動的レンダリングされ、リクエストごとに実行されます。

#### 実践例: 明示的な動的レンダリングの指定

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

// 明示的に動的レンダリングを指定
export const dynamic = 'force-dynamic'

export async function GET() {
  return NextResponse.json({
    message: '常に動的レンダリング',
    timestamp: new Date().toISOString(),
  })
}
```

`export const dynamic = 'force-dynamic'`を指定することで、常に動的レンダリングになります。

#### 実践例: 静的レンダリングの強制

```tsx
// app/api/static-data/route.ts
import { NextResponse } from 'next/server'

// 明示的に静的レンダリングを指定
export const dynamic = 'force-static'

export async function GET() {
  return NextResponse.json({
    message: '常に静的レンダリング',
    data: 'このデータはビルド時に固定されます',
  })
}
```

`export const dynamic = 'force-static'`を指定することで、常に静的レンダリングになります。

### 実践例: レンダリングモードの判定

```tsx
// app/api/status/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  // レンダリングモードを判定
  const isDynamic = process.env.NODE_ENV === 'development' || 
                    typeof window !== 'undefined'

  return NextResponse.json({
    mode: isDynamic ? 'dynamic' : 'static',
    timestamp: new Date().toISOString(),
  })
}
```

### 実践例: 条件付きレンダリング

```tsx
// app/api/data/route.ts
import { NextResponse } from 'next/server'

export const dynamic = 'force-dynamic' // 動的レンダリングを強制

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const type = searchParams.get('type')

  if (type === 'static') {
    // 静的データを返す
    return NextResponse.json({
      type: 'static',
      data: '静的データ',
    })
  }

  // 動的データを返す
  return NextResponse.json({
    type: 'dynamic',
    data: '動的データ',
    timestamp: new Date().toISOString(),
  })
}
```

### レンダリングモードの選択指針

#### 静的レンダリングを選択する場合
- データが変更されない、または変更頻度が低い
- パフォーマンスを最優先したい
- ビルド時にデータを取得できる

#### 動的レンダリングを選択する場合
- リクエストごとに異なるデータを返す必要がある
- ユーザー固有のデータを処理する
- リアルタイム性が重要

---

## Request / Response オブジェクトの操作

### Requestオブジェクト

Requestオブジェクトは、**HTTPリクエストの情報を含むオブジェクト**です。Route Handlerの関数の第一引数として受け取ります。

### Requestオブジェクトの主要なプロパティとメソッド

#### 1. URLとクエリパラメータ

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const url = new URL(request.url)
  const { searchParams } = url

  // クエリパラメータの取得
  const page = searchParams.get('page') || '1'
  const limit = searchParams.get('limit') || '10'
  const category = searchParams.getAll('category') // 複数の値を取得

  return NextResponse.json({
    page: parseInt(page),
    limit: parseInt(limit),
    category,
    pathname: url.pathname,
    origin: url.origin,
  })
}
```

#### 2. リクエストボディの取得

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  // JSONボディの取得
  const body = await request.json()

  return NextResponse.json({
    received: body,
    message: 'データを受信しました',
  })
}
```

#### 3. フォームデータの取得

```tsx
// app/api/upload/route.ts
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  const formData = await request.formData()
  const title = formData.get('title') as string
  const file = formData.get('file') as File | null

  if (file) {
    const bytes = await file.arrayBuffer()
    const buffer = Buffer.from(bytes)
    // ファイルを処理...
  }

  return NextResponse.json({
    title,
    fileSize: file?.size || 0,
  })
}
```

#### 4. ヘッダーの取得

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  // ヘッダーの取得
  const contentType = request.headers.get('content-type')
  const authorization = request.headers.get('authorization')
  const userAgent = request.headers.get('user-agent')

  return NextResponse.json({
    contentType,
    hasAuth: !!authorization,
    userAgent,
  })
}
```

#### 5. メソッドとURL情報

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function handler(request: Request) {
  const url = new URL(request.url)

  return NextResponse.json({
    method: request.method,
    url: request.url,
    pathname: url.pathname,
    search: url.search,
    hash: url.hash,
  })
}

export const GET = handler
export const POST = handler
```

### ResponseオブジェクトとNextResponse

Next.jsでは、**`NextResponse`を使用してレスポンスを作成**します。標準の`Response`オブジェクトの拡張版で、Next.js固有の機能を提供します。

### NextResponseの主要なメソッド

#### 1. JSONレスポンス

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json({
    posts: [
      { id: 1, title: '投稿1' },
      { id: 2, title: '投稿2' },
    ],
  })
}
```

#### 2. ステータスコードの設定

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  try {
    const body = await request.json()

    // バリデーション
    if (!body.title) {
      return NextResponse.json(
        { error: 'タイトルは必須です' },
        { status: 400 }
      )
    }

    // データの作成
    const newPost = {
      id: Date.now(),
      ...body,
    }

    return NextResponse.json(newPost, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { error: 'サーバーエラー' },
      { status: 500 }
    )
  }
}
```

#### 3. ヘッダーの設定

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json(
    { message: 'Hello' },
    {
      headers: {
        'Content-Type': 'application/json',
        'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300',
        'X-Custom-Header': 'custom-value',
      },
    }
  )
}
```

#### 4. リダイレクト

```tsx
// app/api/redirect/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.redirect(new URL('/posts', 'http://localhost:3000'))
}
```

#### 5. リライト

```tsx
// app/api/rewrite/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.rewrite(new URL('/internal', 'http://localhost:3000'))
}
```

#### 6. ストリーミングレスポンス

```tsx
// app/api/stream/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  const stream = new ReadableStream({
    async start(controller) {
      for (let i = 0; i < 10; i++) {
        const data = `data: ${i}\n\n`
        controller.enqueue(new TextEncoder().encode(data))
        await new Promise((resolve) => setTimeout(resolve, 1000))
      }
      controller.close()
    },
  })

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  })
}
```

### 実践例: 認証ヘッダーの処理

```tsx
// app/api/protected/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const authorization = request.headers.get('authorization')

  if (!authorization || !authorization.startsWith('Bearer ')) {
    return NextResponse.json(
      { error: '認証が必要です' },
      { status: 401 }
    )
  }

  const token = authorization.substring(7)

  // トークンの検証（例）
  // const isValid = await verifyToken(token)
  // if (!isValid) {
  //   return NextResponse.json(
  //     { error: '無効なトークンです' },
  //     { status: 401 }
  //   )
  // }

  return NextResponse.json({
    message: '認証成功',
    token,
  })
}
```

### 実践例: CORSヘッダーの設定

```tsx
// app/api/cors/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  return NextResponse.json(
    { message: 'CORS enabled' },
    {
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      },
    }
  )
}

export async function OPTIONS() {
  return NextResponse.json({}, {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  })
}
```

### 実践例: ファイルのダウンロード

```tsx
// app/api/download/route.ts
import { NextResponse } from 'next/server'
import { readFile } from 'fs/promises'
import { join } from 'path'

export async function GET() {
  try {
    const filePath = join(process.cwd(), 'public', 'sample.pdf')
    const fileBuffer = await readFile(filePath)

    return new NextResponse(fileBuffer, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': 'attachment; filename="sample.pdf"',
      },
    })
  } catch (error) {
    return NextResponse.json(
      { error: 'ファイルの読み込みに失敗しました' },
      { status: 500 }
    )
  }
}
```

### 実践例: 条件付きレスポンス

```tsx
// app/api/content/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const format = searchParams.get('format') || 'json'

  const data = {
    id: 1,
    title: 'コンテンツ',
    content: 'これはコンテンツです',
  }

  if (format === 'xml') {
    const xml = `<?xml version="1.0"?>
<content>
  <id>${data.id}</id>
  <title>${data.title}</title>
  <content>${data.content}</content>
</content>`

    return new NextResponse(xml, {
      headers: {
        'Content-Type': 'application/xml',
      },
    })
  }

  return NextResponse.json(data)
}
```

### 実践例: エラーハンドリングとロギング

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  try {
    const body = await request.json()

    // バリデーション
    if (!body.title) {
      return NextResponse.json(
        { error: 'タイトルは必須です' },
        { status: 400 }
      )
    }

    // データの処理
    const newPost = {
      id: Date.now(),
      title: body.title,
      content: body.content,
    }

    // ログ出力（本番環境では適切なロギングサービスを使用）
    console.log('New post created:', newPost)

    return NextResponse.json(newPost, { status: 201 })
  } catch (error) {
    // エラーログ
    console.error('Error creating post:', error)

    return NextResponse.json(
      { error: 'サーバーエラーが発生しました' },
      { status: 500 }
    )
  }
}
```

---

## まとめ

この章では、Next.jsのApp RouterにおけるRoute Handlerのレンダリングと挙動について学びました。

### 学んだこと
- Route Handlerのレンダリング: StaticとDynamicの2つのレンダリングモード
- Request / Response オブジェクトの操作: リクエストの処理とレスポンスの作成

### 重要なポイント
1. **Static Rendering**: ビルド時にレンダリングされ、キャッシュ可能
2. **Dynamic Rendering**: リクエストごとに実行され、動的なデータを処理可能
3. **Requestオブジェクト**: URL、クエリパラメータ、ヘッダー、ボディなどの情報を取得
4. **NextResponse**: JSON、ステータスコード、ヘッダー、リダイレクトなどのレスポンスを作成
5. **レンダリングモードの選択**: 用途に応じて適切なレンダリングモードを選択
6. **エラーハンドリング**: 適切なエラーハンドリングとロギングの実装

### 次のステップ
次の章では、Route Handlerの使用例について詳しく学びます。

---

## 演習問題

### 問題1: 動的レンダリングの実装
Requestオブジェクトを使用して、動的レンダリングされるRoute Handlerを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/api/dynamic/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const name = searchParams.get('name') || 'Guest'

  return NextResponse.json({
    message: `Hello, ${name}!`,
    timestamp: new Date().toISOString(),
  })
}
```
</details>

### 問題2: 静的レンダリングの強制
`force-static`を使用して、常に静的レンダリングされるRoute Handlerを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/api/static/route.ts
import { NextResponse } from 'next/server'

export const dynamic = 'force-static'

export async function GET() {
  return NextResponse.json({
    message: '静的レンダリング',
    data: 'このデータはビルド時に固定されます',
  })
}
```
</details>

### 問題3: クエリパラメータの処理
Requestオブジェクトからクエリパラメータを取得し、ページネーションを実装してください。

<details>
<summary>解答例</summary>

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const page = parseInt(searchParams.get('page') || '1')
  const limit = parseInt(searchParams.get('limit') || '10')

  const posts = [
    { id: 1, title: '投稿1' },
    { id: 2, title: '投稿2' },
    // ... より多くの投稿
  ]

  const startIndex = (page - 1) * limit
  const endIndex = startIndex + limit
  const paginatedPosts = posts.slice(startIndex, endIndex)

  return NextResponse.json({
    posts: paginatedPosts,
    page,
    limit,
    total: posts.length,
  })
}
```
</details>

### 問題4: ヘッダーの設定
NextResponseを使用して、カスタムヘッダーを設定したレスポンスを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function GET() {
  return NextResponse.json(
    { posts: [] },
    {
      headers: {
        'Cache-Control': 'public, s-maxage=60',
        'X-Custom-Header': 'custom-value',
      },
    }
  )
}
```
</details>

### 問題5: エラーハンドリング
適切なエラーハンドリングを実装し、異なるステータスコードを返すRoute Handlerを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/api/posts/route.ts
import { NextResponse } from 'next/server'

export async function POST(request: Request) {
  try {
    const body = await request.json()

    if (!body.title) {
      return NextResponse.json(
        { error: 'タイトルは必須です' },
        { status: 400 }
      )
    }

    const newPost = {
      id: Date.now(),
      title: body.title,
    }

    return NextResponse.json(newPost, { status: 201 })
  } catch (error) {
    return NextResponse.json(
      { error: 'サーバーエラー' },
      { status: 500 }
    )
  }
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。

