# 7-2. モーダル表示の実践

この章では、Next.jsでモーダル表示を実装する実践的な方法について学びます。汎用的なモーダルコンポーネントの作成、Intercepting Routesを用いたURL連動モーダル、モーダル内でのデータ連携を理解することで、ユーザーフレンドリーなモーダルUIを実装できるようになります。

---

## 目次

- [汎用的なモーダルコンポーネントの作成](#汎用的なモーダルコンポーネントの作成)
- [Intercepting Routesを用いたURL連動モーダルの実装](#intercepting-routesを用いたurl連動モーダルの実装)
- [モーダル内でのデータ連携](#モーダル内でのデータ連携)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## 汎用的なモーダルコンポーネントの作成

### モーダルコンポーネントとは
モーダルコンポーネントは、**ページの上に表示されるオーバーレイUI**です。ユーザーの注意を引くために使用され、確認ダイアログ、フォーム、詳細表示などに活用されます。

### 日常生活での例
- **ポップアップウィンドウ**: 重要な情報を表示
- **確認ダイアログ**: 操作の確認を求める
- **詳細表示**: 一覧から詳細を表示

### 基本的なモーダルコンポーネント

```tsx
// components/ui/Modal.tsx
'use client';

import { useEffect, useRef } from 'react';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title?: string;
    children: React.ReactNode;
    size?: 'small' | 'medium' | 'large' | 'full';
    closeOnOverlayClick?: boolean;
    closeOnEscape?: boolean;
}

export default function Modal({
    isOpen,
    onClose,
    title,
    children,
    size = 'medium',
    closeOnOverlayClick = true,
    closeOnEscape = true,
}: ModalProps) {
    const modalRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => {
        if (!isOpen) return;
        
        // ESCキーで閉じる
        if (closeOnEscape) {
            const handleEscape = (e: KeyboardEvent) => {
                if (e.key === 'Escape') {
                    onClose();
                }
            };
            document.addEventListener('keydown', handleEscape);
            return () => document.removeEventListener('keydown', handleEscape);
        }
    }, [isOpen, closeOnEscape, onClose]);
    
    useEffect(() => {
        if (isOpen) {
            // モーダル表示時にbodyのスクロールを無効化
            document.body.style.overflow = 'hidden';
        } else {
            document.body.style.overflow = '';
        }
        
        return () => {
            document.body.style.overflow = '';
        };
    }, [isOpen]);
    
    if (!isOpen) return null;
    
    const handleOverlayClick = (e: React.MouseEvent<HTMLDivElement>) => {
        if (closeOnOverlayClick && e.target === e.currentTarget) {
            onClose();
        }
    };
    
    return (
        <div className="modal-overlay" onClick={handleOverlayClick}>
            <div className={`modal-content modal-${size}`} ref={modalRef}>
                {title && (
                    <div className="modal-header">
                        <h2>{title}</h2>
                        <button onClick={onClose} className="modal-close">
                            ×
                        </button>
                    </div>
                )}
                <div className="modal-body">{children}</div>
            </div>
        </div>
    );
}
```

### 実践例: 汎用的なモーダルコンポーネント

#### 確認ダイアログモーダル

```tsx
// components/ui/ConfirmModal.tsx
'use client';

import Modal from './Modal';

interface ConfirmModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => void;
    title: string;
    message: string;
    confirmText?: string;
    cancelText?: string;
    variant?: 'default' | 'danger' | 'warning';
}

export default function ConfirmModal({
    isOpen,
    onClose,
    onConfirm,
    title,
    message,
    confirmText = '確認',
    cancelText = 'キャンセル',
    variant = 'default',
}: ConfirmModalProps) {
    const handleConfirm = () => {
        onConfirm();
        onClose();
    };
    
    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title={title}
            size="small"
            closeOnOverlayClick={false}
        >
            <div className="confirm-modal">
                <p>{message}</p>
                <div className="confirm-modal-actions">
                    <button
                        onClick={onClose}
                        className="confirm-modal-cancel"
                    >
                        {cancelText}
                    </button>
                    <button
                        onClick={handleConfirm}
                        className={`confirm-modal-confirm confirm-modal-${variant}`}
                    >
                        {confirmText}
                    </button>
                </div>
            </div>
        </Modal>
    );
}

// 使用例
// app/posts/page.tsx
'use client';

import { useState } from 'react';
import ConfirmModal from '@/components/ui/ConfirmModal';

export default function PostsPage() {
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [postIdToDelete, setPostIdToDelete] = useState<number | null>(null);
    
    const handleDeleteClick = (id: number) => {
        setPostIdToDelete(id);
        setIsModalOpen(true);
    };
    
    const handleConfirmDelete = () => {
        if (postIdToDelete) {
            // 削除処理
            console.log('削除:', postIdToDelete);
        }
    };
    
    return (
        <div>
            <h1>投稿一覧</h1>
            <button onClick={() => handleDeleteClick(1)}>
                削除
            </button>
            
            <ConfirmModal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                onConfirm={handleConfirmDelete}
                title="投稿の削除"
                message="この投稿を削除してもよろしいですか？"
                confirmText="削除"
                cancelText="キャンセル"
                variant="danger"
            />
        </div>
    );
}
```

#### フォームモーダル

```tsx
// components/ui/FormModal.tsx
'use client';

import { useState, FormEvent } from 'react';
import Modal from './Modal';

interface FormModalProps {
    isOpen: boolean;
    onClose: () => void;
    onSubmit: (data: FormData) => void;
    title: string;
    children: React.ReactNode;
}

export default function FormModal({
    isOpen,
    onClose,
    onSubmit,
    title,
    children,
}: FormModalProps) {
    const [isSubmitting, setIsSubmitting] = useState(false);
    
    const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        setIsSubmitting(true);
        
        const formData = new FormData(e.currentTarget);
        await onSubmit(formData);
        
        setIsSubmitting(false);
        onClose();
    };
    
    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title={title}
            size="medium"
            closeOnOverlayClick={false}
        >
            <form onSubmit={handleSubmit} className="form-modal">
                {children}
                <div className="form-modal-actions">
                    <button
                        type="button"
                        onClick={onClose}
                        disabled={isSubmitting}
                    >
                        キャンセル
                    </button>
                    <button type="submit" disabled={isSubmitting}>
                        {isSubmitting ? '送信中...' : '送信'}
                    </button>
                </div>
            </form>
        </Modal>
    );
}

// 使用例
// app/posts/page.tsx
'use client';

import { useState } from 'react';
import FormModal from '@/components/ui/FormModal';

export default function PostsPage() {
    const [isModalOpen, setIsModalOpen] = useState(false);
    
    const handleSubmit = async (formData: FormData) => {
        const title = formData.get('title') as string;
        const content = formData.get('content') as string;
        
        // 送信処理
        console.log('送信:', { title, content });
    };
    
    return (
        <div>
            <h1>投稿一覧</h1>
            <button onClick={() => setIsModalOpen(true)}>
                新規投稿
            </button>
            
            <FormModal
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                onSubmit={handleSubmit}
                title="新規投稿"
            >
                <div>
                    <label>
                        タイトル
                        <input type="text" name="title" required />
                    </label>
                    <label>
                        内容
                        <textarea name="content" required />
                    </label>
                </div>
            </FormModal>
        </div>
    );
}
```

#### 詳細表示モーダル

```tsx
// components/ui/DetailModal.tsx
'use client';

import Modal from './Modal';

interface DetailModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    data: Record<string, any>;
}

export default function DetailModal({
    isOpen,
    onClose,
    title,
    data,
}: DetailModalProps) {
    return (
        <Modal
            isOpen={isOpen}
            onClose={onClose}
            title={title}
            size="large"
        >
            <div className="detail-modal">
                <dl>
                    {Object.entries(data).map(([key, value]) => (
                        <div key={key} className="detail-modal-item">
                            <dt>{key}</dt>
                            <dd>{String(value)}</dd>
                        </div>
                    ))}
                </dl>
            </div>
        </Modal>
    );
}

// 使用例
// app/users/page.tsx
'use client';

import { useState } from 'react';
import DetailModal from '@/components/ui/DetailModal';

interface User {
    id: number;
    name: string;
    email: string;
    role: string;
}

export default function UsersPage() {
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [selectedUser, setSelectedUser] = useState<User | null>(null);
    
    const handleViewDetails = (user: User) => {
        setSelectedUser(user);
        setIsModalOpen(true);
    };
    
    return (
        <div>
            <h1>ユーザー一覧</h1>
            <button onClick={() => handleViewDetails({
                id: 1,
                name: '太郎',
                email: 'taro@example.com',
                role: 'admin'
            })}>
                詳細を見る
            </button>
            
            {selectedUser && (
                <DetailModal
                    isOpen={isModalOpen}
                    onClose={() => setIsModalOpen(false)}
                    title="ユーザー詳細"
                    data={{
                        ID: selectedUser.id,
                        名前: selectedUser.name,
                        メール: selectedUser.email,
                        役割: selectedUser.role,
                    }}
                />
            )}
        </div>
    );
}
```

### モーダルのスタイリング

```css
/* styles/modal.css */

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    animation: fadeIn 0.2s ease-in-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

.modal-content {
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    max-width: 90vw;
    max-height: 90vh;
    overflow: auto;
    animation: slideUp 0.3s ease-out;
}

@keyframes slideUp {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-small {
    width: 400px;
}

.modal-medium {
    width: 600px;
}

.modal-large {
    width: 800px;
}

.modal-full {
    width: 95vw;
    height: 95vh;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 16px;
    border-bottom: 1px solid #e0e0e0;
}

.modal-header h2 {
    margin: 0;
    font-size: 1.5rem;
}

.modal-close {
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: #666;
    padding: 0;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-close:hover {
    color: #000;
}

.modal-body {
    padding: 16px;
}

/* ConfirmModal */
.confirm-modal {
    padding: 16px;
}

.confirm-modal p {
    margin: 0 0 16px 0;
}

.confirm-modal-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
}

.confirm-modal-cancel,
.confirm-modal-confirm {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.confirm-modal-cancel {
    background: #e0e0e0;
    color: #333;
}

.confirm-modal-confirm {
    background: #2196f3;
    color: white;
}

.confirm-modal-danger {
    background: #f44336;
}

.confirm-modal-warning {
    background: #ff9800;
}

/* FormModal */
.form-modal {
    padding: 16px;
}

.form-modal label {
    display: block;
    margin-bottom: 16px;
}

.form-modal input,
.form-modal textarea {
    width: 100%;
    padding: 8px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    font-size: 14px;
}

.form-modal-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 16px;
}

.form-modal-actions button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
}

.form-modal-actions button[type="button"] {
    background: #e0e0e0;
    color: #333;
}

.form-modal-actions button[type="submit"] {
    background: #2196f3;
    color: white;
}

.form-modal-actions button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* DetailModal */
.detail-modal {
    padding: 16px;
}

.detail-modal-item {
    display: flex;
    padding: 8px 0;
    border-bottom: 1px solid #e0e0e0;
}

.detail-modal-item:last-child {
    border-bottom: none;
}

.detail-modal-item dt {
    font-weight: 600;
    width: 120px;
    flex-shrink: 0;
}

.detail-modal-item dd {
    margin: 0;
    flex: 1;
}
```

---

## Intercepting Routesを用いたURL連動モーダルの実装

### URL連動モーダルとは
URL連動モーダルは、**URLの変更に連動してモーダルを表示する**機能です。Intercepting Routesを使用することで、ページ遷移せずにモーダルでコンテンツを表示できます。

### 実践例: URL連動モーダル

#### 写真ギャラリーのモーダル

```tsx
// app/layout.tsx
export default function RootLayout({
    children,
    modal,
}: {
    children: React.ReactNode;
    modal: React.ReactNode;
}) {
    return (
        <html>
            <body>
                {children}
                {modal}
            </body>
        </html>
    );
}

// app/@modal/default.tsx
export default function Default() {
    return null;
}

// app/@modal/(.)photo/[id]/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useRef } from 'react';

interface PhotoModalProps {
    params: { id: string };
}

export default function PhotoModal({ params }: PhotoModalProps) {
    const router = useRouter();
    const modalRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => {
        // ESCキーで閉じる
        const handleEscape = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                router.back();
            }
        };
        
        // オーバーレイクリックで閉じる
        const handleClickOutside = (e: MouseEvent) => {
            if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
                router.back();
            }
        };
        
        // bodyのスクロールを無効化
        document.body.style.overflow = 'hidden';
        
        document.addEventListener('keydown', handleEscape);
        document.addEventListener('mousedown', handleClickOutside);
        
        return () => {
            document.body.style.overflow = '';
            document.removeEventListener('keydown', handleEscape);
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [router]);
    
    return (
        <div className="modal-overlay">
            <div className="modal-content modal-large" ref={modalRef}>
                <div className="modal-header">
                    <h2>写真 {params.id}</h2>
                    <button onClick={() => router.back()} className="modal-close">
                        ×
                    </button>
                </div>
                <div className="modal-body">
                    <img
                        src={`/photos/${params.id}.jpg`}
                        alt={`写真 ${params.id}`}
                        className="modal-image"
                    />
                </div>
            </div>
        </div>
    );
}

// app/photo/[id]/page.tsx
interface PhotoPageProps {
    params: { id: string };
}

export default function PhotoPage({ params }: PhotoPageProps) {
    return (
        <div>
            <h1>写真 {params.id}</h1>
            <img
                src={`/photos/${params.id}.jpg`}
                alt={`写真 ${params.id}`}
            />
        </div>
    );
}

// app/photo/page.tsx
interface Photo {
    id: string;
    title: string;
    url: string;
}

async function getPhotos(): Promise<Photo[]> {
    // データ取得処理
    return [
        { id: '1', title: '写真1', url: '/photos/1.jpg' },
        { id: '2', title: '写真2', url: '/photos/2.jpg' },
    ];
}

export default async function PhotosPage() {
    const photos = await getPhotos();
    
    return (
        <div>
            <h1>写真一覧</h1>
            <div className="photo-grid">
                {photos.map(photo => (
                    <a key={photo.id} href={`/photo/${photo.id}`}>
                        <img src={photo.url} alt={photo.title} />
                        <p>{photo.title}</p>
                    </a>
                ))}
            </div>
        </div>
    );
}
```

#### ユーザー詳細のモーダル

```tsx
// app/@modal/(.)user/[id]/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useEffect, useRef } from 'react';

interface UserModalProps {
    params: { id: string };
}

async function getUser(id: string) {
    const res = await fetch(`https://api.example.com/users/${id}`);
    return res.json();
}

export default async function UserModal({ params }: UserModalProps) {
    const router = useRouter();
    const modalRef = useRef<HTMLDivElement>(null);
    const user = await getUser(params.id);
    
    useEffect(() => {
        const handleEscape = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                router.back();
            }
        };
        
        const handleClickOutside = (e: MouseEvent) => {
            if (modalRef.current && !modalRef.current.contains(e.target as Node)) {
                router.back();
            }
        };
        
        document.body.style.overflow = 'hidden';
        document.addEventListener('keydown', handleEscape);
        document.addEventListener('mousedown', handleClickOutside);
        
        return () => {
            document.body.style.overflow = '';
            document.removeEventListener('keydown', handleEscape);
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [router]);
    
    return (
        <div className="modal-overlay">
            <div className="modal-content modal-medium" ref={modalRef}>
                <div className="modal-header">
                    <h2>{user.name}</h2>
                    <button onClick={() => router.back()} className="modal-close">
                        ×
                    </button>
                </div>
                <div className="modal-body">
                    <dl>
                        <dt>ID</dt>
                        <dd>{user.id}</dd>
                        <dt>メール</dt>
                        <dd>{user.email}</dd>
                        <dt>役割</dt>
                        <dd>{user.role}</dd>
                    </dl>
                </div>
            </div>
        </div>
    );
}

// app/user/[id]/page.tsx
interface UserPageProps {
    params: { id: string };
}

async function getUser(id: string) {
    const res = await fetch(`https://api.example.com/users/${id}`);
    return res.json();
}

export default async function UserPage({ params }: UserPageProps) {
    const user = await getUser(params.id);
    
    return (
        <div>
            <h1>{user.name}</h1>
            <dl>
                <dt>ID</dt>
                <dd>{user.id}</dd>
                <dt>メール</dt>
                <dd>{user.email}</dd>
                <dt>役割</dt>
                <dd>{user.role}</dd>
            </dl>
        </div>
    );
}
```

---

## モーダル内でのデータ連携

### モーダル内でのデータ連携とは
モーダル内でのデータ連携は、**モーダルと親コンポーネント間でデータを共有し、連携する**機能です。状態管理、Server Actions、Context APIなどを使用して実装します。

### 実践例: モーダル内でのデータ連携

#### Server Actionsを使ったデータ更新

```tsx
// app/actions.ts
'use server';

export async function updateUser(id: string, data: FormData) {
    const name = data.get('name') as string;
    const email = data.get('email') as string;
    
    // データベース更新処理
    // await db.user.update({ where: { id }, data: { name, email } });
    
    return { success: true };
}

// app/@modal/(.)user/[id]/edit/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useFormState } from 'react-dom';
import { updateUser } from '@/app/actions';

interface EditUserModalProps {
    params: { id: string };
    user: {
        id: string;
        name: string;
        email: string;
    };
}

export default function EditUserModal({ params, user }: EditUserModalProps) {
    const router = useRouter();
    const [state, formAction] = useFormState(updateUser, null);
    
    const handleSubmit = async (formData: FormData) => {
        formData.append('id', params.id);
        await formAction(formData);
        router.back();
    };
    
    return (
        <div className="modal-overlay">
            <div className="modal-content modal-medium">
                <div className="modal-header">
                    <h2>ユーザー編集</h2>
                    <button onClick={() => router.back()} className="modal-close">
                        ×
                    </button>
                </div>
                <div className="modal-body">
                    <form action={handleSubmit}>
                        <label>
                            名前
                            <input
                                type="text"
                                name="name"
                                defaultValue={user.name}
                                required
                            />
                        </label>
                        <label>
                            メール
                            <input
                                type="email"
                                name="email"
                                defaultValue={user.email}
                                required
                            />
                        </label>
                        <div className="form-actions">
                            <button type="button" onClick={() => router.back()}>
                                キャンセル
                            </button>
                            <button type="submit">保存</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    );
}

// app/user/[id]/edit/page.tsx
interface EditUserPageProps {
    params: { id: string };
}

async function getUser(id: string) {
    // データ取得処理
    return {
        id,
        name: '太郎',
        email: 'taro@example.com',
    };
}

export default async function EditUserPage({ params }: EditUserPageProps) {
    const user = await getUser(params.id);
    
    return (
        <div>
            <h1>ユーザー編集</h1>
            {/* 編集フォーム */}
        </div>
    );
}
```

#### Context APIを使った状態管理

```tsx
// contexts/ModalContext.tsx
'use client';

import { createContext, useContext, useState, ReactNode } from 'react';

interface ModalContextType {
    isOpen: boolean;
    openModal: () => void;
    closeModal: () => void;
    modalData: any;
    setModalData: (data: any) => void;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export function ModalProvider({ children }: { children: ReactNode }) {
    const [isOpen, setIsOpen] = useState(false);
    const [modalData, setModalData] = useState<any>(null);
    
    const openModal = () => setIsOpen(true);
    const closeModal = () => {
        setIsOpen(false);
        setModalData(null);
    };
    
    return (
        <ModalContext.Provider
            value={{
                isOpen,
                openModal,
                closeModal,
                modalData,
                setModalData,
            }}
        >
            {children}
        </ModalContext.Provider>
    );
}

export function useModal() {
    const context = useContext(ModalContext);
    if (!context) {
        throw new Error('useModal must be used within ModalProvider');
    }
    return context;
}

// app/layout.tsx
import { ModalProvider } from '@/contexts/ModalContext';

export default function RootLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    return (
        <html>
            <body>
                <ModalProvider>
                    {children}
                </ModalProvider>
            </body>
        </html>
    );
}

// app/posts/page.tsx
'use client';

import { useModal } from '@/contexts/ModalContext';
import Modal from '@/components/ui/Modal';

export default function PostsPage() {
    const { isOpen, openModal, closeModal, modalData } = useModal();
    
    const handleViewPost = (post: any) => {
        openModal();
        // setModalData(post);
    };
    
    return (
        <div>
            <h1>投稿一覧</h1>
            <button onClick={() => handleViewPost({ id: 1, title: '投稿1' })}>
                投稿を見る
            </button>
            
            <Modal isOpen={isOpen} onClose={closeModal} title="投稿詳細">
                {modalData && (
                    <div>
                        <h3>{modalData.title}</h3>
                        <p>{modalData.content}</p>
                    </div>
                )}
            </Modal>
        </div>
    );
}
```

#### モーダルからのデータ更新と親コンポーネントの再レンダリング

```tsx
// app/@modal/(.)post/[id]/edit/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { useFormState } from 'react-dom';
import { updatePost } from '@/app/actions';

interface EditPostModalProps {
    params: { id: string };
    post: {
        id: string;
        title: string;
        content: string;
    };
}

export default function EditPostModal({ params, post }: EditPostModalProps) {
    const router = useRouter();
    const [state, formAction] = useFormState(updatePost, null);
    
    const handleSubmit = async (formData: FormData) => {
        formData.append('id', params.id);
        await formAction(formData);
        router.refresh(); // 親コンポーネントを再レンダリング
        router.back();
    };
    
    return (
        <div className="modal-overlay">
            <div className="modal-content modal-medium">
                <div className="modal-header">
                    <h2>投稿編集</h2>
                    <button onClick={() => router.back()} className="modal-close">
                        ×
                    </button>
                </div>
                <div className="modal-body">
                    <form action={handleSubmit}>
                        <label>
                            タイトル
                            <input
                                type="text"
                                name="title"
                                defaultValue={post.title}
                                required
                            />
                        </label>
                        <label>
                            内容
                            <textarea
                                name="content"
                                defaultValue={post.content}
                                required
                            />
                        </label>
                        <div className="form-actions">
                            <button type="button" onClick={() => router.back()}>
                                キャンセル
                            </button>
                            <button type="submit">保存</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    );
}
```

---

## まとめ

この章では、モーダル表示の実践的な実装方法について学びました。

### 学んだこと
- **汎用的なモーダルコンポーネント**: 再利用可能なモーダルコンポーネントの作成
- **URL連動モーダル**: Intercepting Routesを使ったURL連動モーダルの実装
- **モーダル内でのデータ連携**: Server Actions、Context APIを使ったデータ連携
- **モーダルの種類**: 確認ダイアログ、フォーム、詳細表示など

### 重要なポイント
1. **汎用的なコンポーネント**: 様々な場面で使用できるモーダルコンポーネントを作成
2. **URL連動**: Intercepting RoutesでURLと連動したモーダルを実装
3. **データ連携**: Server ActionsやContext APIでモーダルと親コンポーネント間でデータを共有
4. **ユーザー体験**: ESCキー、オーバーレイクリック、スクロール無効化などでUXを向上
5. **スタイリング**: アニメーションやレスポンシブデザインで見た目を整える

### 使い分けの目安
- **汎用的なモーダル**: 様々な場面で使用する基本的なモーダル
- **URL連動モーダル**: ページ遷移せずにモーダルで表示したい場合
- **データ連携**: モーダルと親コンポーネント間でデータを共有する場合

### 次のステップ
モーダル表示を理解することで、ユーザーフレンドリーなUIを実装できるようになります。次の章では、認証機能 (NextAuth.js) について詳しく学びます。

---

## 演習問題

### 問題1: 基本的なモーダルコンポーネントの作成
ESCキーとオーバーレイクリックで閉じられる基本的なモーダルコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```tsx
// components/ui/Modal.tsx
'use client';

import { useEffect, useRef } from 'react';

interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    children: React.ReactNode;
}

export default function Modal({ isOpen, onClose, children }: ModalProps) {
    const modalRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => {
        if (!isOpen) return;
        
        const handleEscape = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                onClose();
            }
        };
        
        document.addEventListener('keydown', handleEscape);
        return () => document.removeEventListener('keydown', handleEscape);
    }, [isOpen, onClose]);
    
    if (!isOpen) return null;
    
    return (
        <div
            className="modal-overlay"
            onClick={(e) => {
                if (e.target === e.currentTarget) {
                    onClose();
                }
            }}
        >
            <div className="modal-content" ref={modalRef}>
                {children}
            </div>
        </div>
    );
}
```
</details>

### 問題2: URL連動モーダルの実装
Intercepting Routesを使って、写真一覧から写真をクリックしたときにモーダルで表示する機能を実装してください。

<details>
<summary>解答例</summary>

```tsx
// app/@modal/(.)photo/[id]/page.tsx
'use client';

import { useRouter } from 'next/navigation';

export default function PhotoModal({
    params,
}: {
    params: { id: string };
}) {
    const router = useRouter();
    
    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <button onClick={() => router.back()}>閉じる</button>
                <h2>写真 {params.id}</h2>
            </div>
        </div>
    );
}
```
</details>

### 問題3: 確認ダイアログモーダルの作成
削除確認用の確認ダイアログモーダルを作成してください。

<details>
<summary>解答例</summary>

```tsx
// components/ui/ConfirmModal.tsx
'use client';

import Modal from './Modal';

interface ConfirmModalProps {
    isOpen: boolean;
    onClose: () => void;
    onConfirm: () => void;
    message: string;
}

export default function ConfirmModal({
    isOpen,
    onClose,
    onConfirm,
    message,
}: ConfirmModalProps) {
    const handleConfirm = () => {
        onConfirm();
        onClose();
    };
    
    return (
        <Modal isOpen={isOpen} onClose={onClose}>
            <div>
                <p>{message}</p>
                <div>
                    <button onClick={onClose}>キャンセル</button>
                    <button onClick={handleConfirm}>確認</button>
                </div>
            </div>
        </Modal>
    );
}
```
</details>

### 問題4: Server Actionsを使ったモーダル内でのデータ更新
Server Actionsを使って、モーダル内でデータを更新し、親コンポーネントを再レンダリングする機能を実装してください。

<details>
<summary>解答例</summary>

```tsx
// app/actions.ts
'use server';

export async function updatePost(id: string, data: FormData) {
    const title = data.get('title') as string;
    // 更新処理
    return { success: true };
}

// app/@modal/(.)post/[id]/edit/page.tsx
'use client';

import { useRouter } from 'next/navigation';
import { updatePost } from '@/app/actions';

export default function EditPostModal({
    params,
}: {
    params: { id: string };
}) {
    const router = useRouter();
    
    const handleSubmit = async (formData: FormData) => {
        await updatePost(params.id, formData);
        router.refresh();
        router.back();
    };
    
    return (
        <div className="modal-overlay">
            <div className="modal-content">
                <form action={handleSubmit}>
                    <input type="text" name="title" />
                    <button type="submit">保存</button>
                </form>
            </div>
        </div>
    );
}
```
</details>

### 問題5: Context APIを使ったモーダルの状態管理
Context APIを使って、モーダルの開閉状態を管理する機能を実装してください。

<details>
<summary>解答例</summary>

```tsx
// contexts/ModalContext.tsx
'use client';

import { createContext, useContext, useState } from 'react';

const ModalContext = createContext<{
    isOpen: boolean;
    openModal: () => void;
    closeModal: () => void;
} | undefined>(undefined);

export function ModalProvider({ children }: { children: React.ReactNode }) {
    const [isOpen, setIsOpen] = useState(false);
    
    return (
        <ModalContext.Provider
            value={{
                isOpen,
                openModal: () => setIsOpen(true),
                closeModal: () => setIsOpen(false),
            }}
        >
            {children}
        </ModalContext.Provider>
    );
}

export function useModal() {
    const context = useContext(ModalContext);
    if (!context) {
        throw new Error('useModal must be used within ModalProvider');
    }
    return context;
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。

