# 9-3. パフォーマンスとキャッシュの最適化（レンダリング戦略の最適化）

この章では、Next.jsアプリケーションのレンダリング戦略について学びます。適切なレンダリング戦略を選択することで、パフォーマンスとユーザー体験を最適化できます。

---

## 目次

- [レンダリング戦略の種類](#レンダリング戦略の種類)
- [Static Rendering（静的レンダリング）](#static-rendering静的レンダリング)
- [Dynamic Rendering（動的レンダリング）](#dynamic-rendering動的レンダリング)
- [Streaming（ストリーミング）](#streamingストリーミング)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## レンダリング戦略の種類

### レンダリング戦略とは
レンダリング戦略は、**ページをいつ、どこで生成するか**を決定する方法です。Next.jsでは、複数のレンダリング戦略を選択できます。

### 日常生活での例
- **料理の準備**: 事前に準備（静的レンダリング）するか、注文を受けてから作る（動的レンダリング）か
- **商品の在庫**: 事前に在庫を確保（静的レンダリング）するか、注文を受けてから調達（動的レンダリング）するか
- **イベントの準備**: 事前に会場を準備（静的レンダリング）するか、当日に準備（動的レンダリング）するか

### Next.jsのレンダリング戦略
1. **Static Rendering（静的レンダリング）**: ビルド時にページを事前に生成
2. **Dynamic Rendering（動的レンダリング）**: リクエスト時にページを生成
3. **Streaming（ストリーミング）**: ページを段階的に生成して送信

### レンダリング戦略の比較

| 戦略 | 生成タイミング | パフォーマンス | 使用例 |
|------|---------------|---------------|--------|
| Static Rendering | ビルド時 | 最高 | ブログ、商品一覧 |
| Dynamic Rendering | リクエスト時 | 中 | ユーザー固有のページ |
| Streaming | リクエスト時（段階的） | 高 | データ取得に時間がかかるページ |

---

## Static Rendering（静的レンダリング）

### Static Renderingとは
Static Renderingは、**ビルド時にページを事前に生成する**レンダリング戦略です。すべてのページが事前に生成されるため、非常に高速です。

### 日常生活での例
- **印刷物**: 事前に印刷したチラシ（静的レンダリング）を配布する
- **商品カタログ**: 事前に作成したカタログ（静的レンダリング）を配布する
- **看板**: 事前に作成した看板（静的レンダリング）を設置する

### Static Renderingの特徴
1. **高速**: 事前に生成されているため、即座に表示される
2. **CDN配信**: CDNで配信できるため、世界中から高速にアクセス可能
3. **サーバー負荷が少ない**: リクエスト時に生成する必要がない

### 実践例: 基本的なStatic Rendering

```tsx
// app/posts/page.tsx
import { prisma } from '@/lib/prisma';

// 動的関数を使用していないため、自動的にStatic Renderingが適用される
export default async function PostsPage() {
    const posts = await prisma.post.findMany();

    return (
        <div>
            <h1>投稿一覧</h1>
            <ul>
                {posts.map(post => (
                    <li key={post.id}>{post.title}</li>
                ))}
            </ul>
        </div>
    );
}
```

### 実践例: 動的ルートでのStatic Rendering

```tsx
// app/posts/[id]/page.tsx
import { prisma } from '@/lib/prisma';

// generateStaticParamsを使用して、ビルド時に生成するページを指定
export async function generateStaticParams() {
    const posts = await prisma.post.findMany();
    
    return posts.map(post => ({
        id: post.id.toString(),
    }));
}

export default async function PostPage({ params }: { params: { id: string } }) {
    const post = await prisma.post.findUnique({
        where: { id: params.id },
    });

    if (!post) {
        return <div>投稿が見つかりません</div>;
    }

    return (
        <div>
            <h1>{post.title}</h1>
            <p>{post.content}</p>
        </div>
    );
}
```

### 実践例: 部分的にStatic Rendering

```tsx
// app/posts/[id]/page.tsx
import { prisma } from '@/lib/prisma';

// 一部のページのみを事前に生成
export async function generateStaticParams() {
    // 人気の投稿のみを事前に生成
    const popularPosts = await prisma.post.findMany({
        where: { views: { gte: 1000 } },
        take: 10,
    });
    
    return popularPosts.map(post => ({
        id: post.id.toString(),
    }));
}

// 事前に生成されていないページは、リクエスト時に生成される
export const dynamicParams = true; // デフォルト: true

export default async function PostPage({ params }: { params: { id: string } }) {
    const post = await prisma.post.findUnique({
        where: { id: params.id },
    });

    if (!post) {
        return <div>投稿が見つかりません</div>;
    }

    return (
        <div>
            <h1>{post.title}</h1>
            <p>{post.content}</p>
        </div>
    );
}
```

### 実践例: Static Renderingの強制

```tsx
// app/posts/page.tsx
// Static Renderingを強制
export const dynamic = 'force-static';

export default async function PostsPage() {
    const posts = await fetch('https://api.example.com/posts', {
        cache: 'force-cache', // キャッシュを有効化
    }).then(res => res.json());

    return (
        <div>
            <h1>投稿一覧</h1>
            <ul>
                {posts.map((post: any) => (
                    <li key={post.id}>{post.title}</li>
                ))}
            </ul>
        </div>
    );
}
```

---

## Dynamic Rendering（動的レンダリング）

### Dynamic Renderingとは
Dynamic Renderingは、**リクエスト時にページを生成する**レンダリング戦略です。ユーザー固有のデータや、リアルタイムで変更されるデータに適しています。

### 日常生活での例
- **注文確認**: 注文を受けてから確認ページ（動的レンダリング）を作成する
- **個人情報**: ユーザーごとに異なる情報（動的レンダリング）を表示する
- **在庫状況**: リアルタイムで変わる在庫（動的レンダリング）を表示する

### Dynamic Renderingの特徴
1. **リアルタイム**: 最新のデータを表示できる
2. **ユーザー固有**: ユーザーごとに異なるコンテンツを表示できる
3. **サーバー負荷**: リクエストごとに生成するため、サーバー負荷がかかる

### 実践例: 基本的なDynamic Rendering

```tsx
// app/profile/page.tsx
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

// cookies()などの動的関数を使用しているため、自動的にDynamic Renderingが適用される
export const dynamic = 'force-dynamic'; // 動的レンダリングを強制

export default async function ProfilePage() {
    const session = await getServerSession(authOptions);

    if (!session) {
        return <div>ログインが必要です</div>;
    }

    return (
        <div>
            <h1>プロフィール</h1>
            <p>名前: {session.user?.name}</p>
            <p>メール: {session.user?.email}</p>
        </div>
    );
}
```

### 実践例: 動的ルートでのDynamic Rendering

```tsx
// app/users/[id]/page.tsx
import { prisma } from '@/lib/prisma';

export const dynamic = 'force-dynamic';

export default async function UserPage({ params }: { params: { id: string } }) {
    // リクエストごとに最新のデータを取得
    const user = await prisma.user.findUnique({
        where: { id: params.id },
        include: { posts: true },
    });

    if (!user) {
        return <div>ユーザーが見つかりません</div>;
    }

    return (
        <div>
            <h1>{user.name}</h1>
            <p>投稿数: {user.posts.length}</p>
        </div>
    );
}
```

### 実践例: 条件付きDynamic Rendering

```tsx
// app/posts/[id]/page.tsx
import { cookies } from 'next/headers';
import { prisma } from '@/lib/prisma';

export default async function PostPage({ params }: { params: { id: string } }) {
    const cookieStore = cookies();
    const preview = cookieStore.get('preview');

    // プレビューモードの場合は動的レンダリング
    if (preview?.value === 'true') {
        // 最新のデータを取得
        const post = await prisma.post.findUnique({
            where: { id: params.id },
        });

        return (
            <div>
                <h1>{post?.title} (プレビュー)</h1>
                <p>{post?.content}</p>
            </div>
        );
    }

    // 通常モードの場合は静的レンダリング
    const post = await prisma.post.findUnique({
        where: { id: params.id },
    });

    return (
        <div>
            <h1>{post?.title}</h1>
            <p>{post?.content}</p>
        </div>
    );
}
```

### 実践例: 部分的にDynamic Rendering

```tsx
// app/posts/page.tsx
import { unstable_noStore as noStore } from 'next/cache';
import { prisma } from '@/lib/prisma';

export default async function PostsPage() {
    // noStore()を使用して、この部分だけ動的レンダリング
    noStore();
    const recentPosts = await prisma.post.findMany({
        orderBy: { createdAt: 'desc' },
        take: 5,
    });

    // この部分は静的レンダリング
    const allPosts = await prisma.post.findMany();

    return (
        <div>
            <section>
                <h2>最新の投稿</h2>
                <ul>
                    {recentPosts.map(post => (
                        <li key={post.id}>{post.title}</li>
                    ))}
                </ul>
            </section>
            <section>
                <h2>すべての投稿</h2>
                <ul>
                    {allPosts.map(post => (
                        <li key={post.id}>{post.title}</li>
                    ))}
                </ul>
            </section>
        </div>
    );
}
```

---

## Streaming（ストリーミング）

### Streamingとは
Streamingは、**ページを段階的に生成して送信する**レンダリング戦略です。データ取得に時間がかかる場合でも、準備できた部分から順に表示できます。

### 日常生活での例
- **レストラン**: 準備できた料理（ストリーミング）から順に提供する
- **工場のライン**: 完成した製品（ストリーミング）から順に出荷する
- **配信**: 準備できた部分（ストリーミング）から順に配信する

### Streamingの特徴
1. **段階的表示**: 準備できた部分から順に表示される
2. **ユーザー体験**: 待ち時間を感じにくい
3. **パフォーマンス**: 全体が準備できるまで待つ必要がない

### 実践例: 基本的なStreaming

```tsx
// app/posts/page.tsx
import { Suspense } from 'react';
import { prisma } from '@/lib/prisma';

async function PostsList() {
    // データ取得に時間がかかる場合でも、準備できた部分から表示される
    const posts = await prisma.post.findMany();
    
    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}

export default function PostsPage() {
    return (
        <div>
            <h1>投稿一覧</h1>
            <Suspense fallback={<div>読み込み中...</div>}>
                <PostsList />
            </Suspense>
        </div>
    );
}
```

### 実践例: 複数のSuspense境界

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { prisma } from '@/lib/prisma';

async function UserStats() {
    const userCount = await prisma.user.count();
    return <div>ユーザー数: {userCount}</div>;
}

async function PostStats() {
    const postCount = await prisma.post.count();
    return <div>投稿数: {postCount}</div>;
}

async function RecentPosts() {
    const posts = await prisma.post.findMany({
        orderBy: { createdAt: 'desc' },
        take: 5,
    });
    
    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}

export default function DashboardPage() {
    return (
        <div>
            <h1>ダッシュボード</h1>
            
            <Suspense fallback={<div>ユーザー統計を読み込み中...</div>}>
                <UserStats />
            </Suspense>
            
            <Suspense fallback={<div>投稿統計を読み込み中...</div>}>
                <PostStats />
            </Suspense>
            
            <Suspense fallback={<div>最新の投稿を読み込み中...</div>}>
                <RecentPosts />
            </Suspense>
        </div>
    );
}
```

### 実践例: ストリーミングとエラーハンドリング

```tsx
// app/posts/page.tsx
import { Suspense } from 'react';
import { prisma } from '@/lib/prisma';
import { ErrorBoundary } from 'react-error-boundary';

async function PostsList() {
    const posts = await prisma.post.findMany();
    
    if (posts.length === 0) {
        throw new Error('投稿が見つかりません');
    }
    
    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}

function ErrorFallback({ error }: { error: Error }) {
    return (
        <div>
            <h2>エラーが発生しました</h2>
            <p>{error.message}</p>
        </div>
    );
}

export default function PostsPage() {
    return (
        <div>
            <h1>投稿一覧</h1>
            <ErrorBoundary FallbackComponent={ErrorFallback}>
                <Suspense fallback={<div>読み込み中...</div>}>
                    <PostsList />
                </Suspense>
            </ErrorBoundary>
        </div>
    );
}
```

### 実践例: ストリーミングとローディング状態

```tsx
// app/components/LoadingSkeleton.tsx
export function PostSkeleton() {
    return (
        <div style={{ padding: '16px', border: '1px solid #ccc', margin: '8px' }}>
            <div style={{ height: '20px', backgroundColor: '#eee', marginBottom: '8px' }}></div>
            <div style={{ height: '16px', backgroundColor: '#eee', width: '60%' }}></div>
        </div>
    );
}

// app/posts/page.tsx
import { Suspense } from 'react';
import { PostSkeleton } from '@/components/LoadingSkeleton';
import { prisma } from '@/lib/prisma';

async function PostsList() {
    const posts = await prisma.post.findMany();
    
    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}

export default function PostsPage() {
    return (
        <div>
            <h1>投稿一覧</h1>
            <Suspense fallback={<PostSkeleton />}>
                <PostsList />
            </Suspense>
        </div>
    );
}
```

### 実践例: ストリーミングと並列データ取得

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { prisma } from '@/lib/prisma';

async function UserCount() {
    // 並列でデータ取得
    const userCount = await prisma.user.count();
    return <div>ユーザー数: {userCount}</div>;
}

async function PostCount() {
    // 並列でデータ取得
    const postCount = await prisma.post.count();
    return <div>投稿数: {postCount}</div>;
}

async function CommentCount() {
    // 並列でデータ取得
    const commentCount = await prisma.comment.count();
    return <div>コメント数: {commentCount}</div>;
}

export default function DashboardPage() {
    return (
        <div>
            <h1>ダッシュボード</h1>
            
            {/* 並列でデータ取得し、準備できた部分から順に表示 */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '16px' }}>
                <Suspense fallback={<div>読み込み中...</div>}>
                    <UserCount />
                </Suspense>
                
                <Suspense fallback={<div>読み込み中...</div>}>
                    <PostCount />
                </Suspense>
                
                <Suspense fallback={<div>読み込み中...</div>}>
                    <CommentCount />
                </Suspense>
            </div>
        </div>
    );
}
```

---

## まとめ

この章では、レンダリング戦略の最適化について以下のことを学びました。

### レンダリング戦略の種類
- **Static Rendering**: ビルド時にページを事前に生成（最高のパフォーマンス）
- **Dynamic Rendering**: リクエスト時にページを生成（リアルタイムデータ）
- **Streaming**: ページを段階的に生成して送信（待ち時間を感じにくい）

### Static Rendering（静的レンダリング）
- **適用条件**: 動的関数を使用しない場合、自動的に適用される
- **generateStaticParams**: 動的ルートで事前に生成するページを指定
- **dynamicParams**: 事前に生成されていないページの処理を制御
- **使用例**: ブログ、商品一覧など、変更が少ないページ

### Dynamic Rendering（動的レンダリング）
- **適用条件**: cookies()、headers()などの動的関数を使用する場合
- **force-dynamic**: 動的レンダリングを強制
- **noStore()**: 部分的に動的レンダリング
- **使用例**: ユーザー固有のページ、リアルタイムデータを表示するページ

### Streaming（ストリーミング）
- **Suspense**: データ取得中の表示を制御
- **段階的表示**: 準備できた部分から順に表示
- **並列データ取得**: 複数のデータを並列で取得し、準備できた部分から表示
- **使用例**: データ取得に時間がかかるページ、複数のデータソースがあるページ

### レンダリング戦略の選択
- **パフォーマンス重視**: Static Rendering
- **リアルタイムデータ**: Dynamic Rendering
- **ユーザー体験重視**: Streaming

### 次のステップ
レンダリング戦略の最適化を理解したら、次のトピックに進みましょう：
- アセットの最適化（9-4）
- デプロイと運用（10章）

---

## 演習問題

以下の問題を解いて、レンダリング戦略の最適化の理解を深めましょう。

### 問題1: Static Rendering
ビルド時に事前に生成される投稿一覧ページを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/posts/page.tsx
import { prisma } from '@/lib/prisma';

export default async function PostsPage() {
    const posts = await prisma.post.findMany();

    return (
        <div>
            <h1>投稿一覧</h1>
            <ul>
                {posts.map(post => (
                    <li key={post.id}>{post.title}</li>
                ))}
            </ul>
        </div>
    );
}
```
</details>

### 問題2: Dynamic Rendering
リクエスト時に生成されるプロフィールページを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/profile/page.tsx
import { getServerSession } from 'next-auth';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

export const dynamic = 'force-dynamic';

export default async function ProfilePage() {
    const session = await getServerSession(authOptions);

    if (!session) {
        return <div>ログインが必要です</div>;
    }

    return (
        <div>
            <h1>プロフィール</h1>
            <p>名前: {session.user?.name}</p>
        </div>
    );
}
```
</details>

### 問題3: Streaming
Suspenseを使用して、ストリーミングでデータを表示するページを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/posts/page.tsx
import { Suspense } from 'react';
import { prisma } from '@/lib/prisma';

async function PostsList() {
    const posts = await prisma.post.findMany();
    
    return (
        <ul>
            {posts.map(post => (
                <li key={post.id}>{post.title}</li>
            ))}
        </ul>
    );
}

export default function PostsPage() {
    return (
        <div>
            <h1>投稿一覧</h1>
            <Suspense fallback={<div>読み込み中...</div>}>
                <PostsList />
            </Suspense>
        </div>
    );
}
```
</details>

### 問題4: generateStaticParams
動的ルートで、ビルド時に生成するページを指定してください。

<details>
<summary>解答例</summary>

```tsx
// app/posts/[id]/page.tsx
import { prisma } from '@/lib/prisma';

export async function generateStaticParams() {
    const posts = await prisma.post.findMany();
    
    return posts.map(post => ({
        id: post.id.toString(),
    }));
}

export default async function PostPage({ params }: { params: { id: string } }) {
    const post = await prisma.post.findUnique({
        where: { id: params.id },
    });

    return (
        <div>
            <h1>{post?.title}</h1>
            <p>{post?.content}</p>
        </div>
    );
}
```
</details>

### 問題5: 複数のSuspense境界
複数のSuspense境界を使用して、並列でデータを取得するページを作成してください。

<details>
<summary>解答例</summary>

```tsx
// app/dashboard/page.tsx
import { Suspense } from 'react';
import { prisma } from '@/lib/prisma';

async function UserCount() {
    const count = await prisma.user.count();
    return <div>ユーザー数: {count}</div>;
}

async function PostCount() {
    const count = await prisma.post.count();
    return <div>投稿数: {count}</div>;
}

export default function DashboardPage() {
    return (
        <div>
            <h1>ダッシュボード</h1>
            <Suspense fallback={<div>読み込み中...</div>}>
                <UserCount />
            </Suspense>
            <Suspense fallback={<div>読み込み中...</div>}>
                <PostCount />
            </Suspense>
        </div>
    );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。

