# 11. ジェネリクス（Generics）

この章では、型をパラメータとして扱える「ジェネリクス」について学びます。ジェネリクスを使うことで、同じコードを複数の型で再利用でき、型安全性を保ちながら柔軟なコードを書けるようになります。

---

## 目次

- [ジェネリクスの概念と必要性](#ジェネリクスの概念と必要性)
- [ジェネリック関数の基本文法](#ジェネリック関数の基本文法)
- [型引数を省略する記法](#型引数を省略する記法)
- [複数の型パラメータの使用](#複数の型パラメータの使用)
- [ジェネリクスの型制約と応用](#ジェネリクスの型制約と応用)
- [ジェネリッククラスの実装](#ジェネリッククラスの実装)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## ジェネリクスの概念と必要性

### ジェネリクスとは
ジェネリクス（Generics）は、**型をパラメータとして扱う**機能です。関数やクラスを定義する際に、具体的な型を指定せず、後から型を指定できるようにします。

### 日常生活での例
- **箱**: どんな物でも入る箱（ジェネリクス）を用意し、後から「りんご用」「本用」などと指定する
- **フォーム**: 同じフォーム（ジェネリクス）を使って、名前、住所、電話番号など異なる種類の情報を入力する
- **レシピ**: 同じ手順（ジェネリクス）で、異なる食材を使って料理を作る

### ジェネリクスが必要な理由

#### 問題点: 型ごとに同じ関数を書く必要がある

```typescript
// 型ごとに同じような関数を書く必要がある（非効率）
function getFirstNumber(numbers: number[]): number | undefined {
    return numbers.length > 0 ? numbers[0] : undefined;
}

function getFirstString(strings: string[]): string | undefined {
    return strings.length > 0 ? strings[0] : undefined;
}

function getFirstBoolean(booleans: boolean[]): boolean | undefined {
    return booleans.length > 0 ? booleans[0] : undefined;
}
```

#### 解決策: ジェネリクスを使う

```typescript
// 1つの関数で複数の型に対応できる
function getFirst<T>(items: T[]): T | undefined {
    return items.length > 0 ? items[0] : undefined;
}

// 様々な型で使用可能
const firstNumber = getFirst<number>([1, 2, 3]);
const firstString = getFirst<string>(["a", "b", "c"]);
const firstBoolean = getFirst<boolean>([true, false]);
```

### ジェネリクスのメリット
1. **コードの再利用**: 同じコードを複数の型で使える
2. **型安全性**: 型チェックが効くため、エラーを防げる
3. **柔軟性**: 後から型を指定できる
4. **保守性**: 1箇所を修正するだけで、すべての型に反映される

### 実践例: ジェネリクスの必要性

```typescript
// src/generics-necessity.ts
// 問題例: 型ごとに同じような関数を書く必要がある
function swapNumbers(a: number, b: number): [number, number] {
    return [b, a];
}

function swapStrings(a: string, b: string): [string, string] {
    return [b, a];
}

function swapBooleans(a: boolean, b: boolean): [boolean, boolean] {
    return [b, a];
}

// 解決策: ジェネリクスを使う
function swap<T>(a: T, b: T): [T, T] {
    return [b, a];
}

// 様々な型で使用可能
const swappedNumbers = swap<number>(10, 20);
console.log(swappedNumbers); // [20, 10]

const swappedStrings = swap<string>("Hello", "World");
console.log(swappedStrings); // ["World", "Hello"]

const swappedBooleans = swap<boolean>(true, false);
console.log(swappedBooleans); // [false, true]

// 実践例: 配列の最後の要素を取得する関数
function getLast<T>(items: T[]): T | undefined {
    return items.length > 0 ? items[items.length - 1] : undefined;
}

const lastNumber = getLast<number>([1, 2, 3, 4, 5]);
console.log(lastNumber); // 5

const lastString = getLast<string>(["a", "b", "c"]);
console.log(lastString); // "c"

// 実践例: 配列を逆順にする関数
function reverseArray<T>(items: T[]): T[] {
    return [...items].reverse();
}

const reversedNumbers = reverseArray<number>([1, 2, 3, 4, 5]);
console.log(reversedNumbers); // [5, 4, 3, 2, 1]

const reversedStrings = reverseArray<string>(["a", "b", "c"]);
console.log(reversedStrings); // ["c", "b", "a"]

// 実践例: 配列から重複を削除する関数
function removeDuplicates<T>(items: T[]): T[] {
    return [...new Set(items)];
}

const uniqueNumbers = removeDuplicates<number>([1, 2, 2, 3, 3, 4]);
console.log(uniqueNumbers); // [1, 2, 3, 4]

const uniqueStrings = removeDuplicates<string>(["a", "b", "a", "c"]);
console.log(uniqueStrings); // ["a", "b", "c"]
```

---

## ジェネリック関数の基本文法

### ジェネリック関数の基本構文

```typescript
function 関数名<型パラメータ>(引数: 型パラメータ): 戻り値の型 {
    // 処理
}
```

### 型パラメータの命名規則
- **T**: Type（型）の略で、最も一般的
- **U, V**: 複数の型パラメータがある場合
- **K**: Key（キー）の略
- **V**: Value（値）の略
- **E**: Element（要素）の略

### 実践例: ジェネリック関数の基本

```typescript
// src/generic-function-basics.ts
// 基本的なジェネリック関数
function identity<T>(value: T): T {
    return value;
}

const numberValue = identity<number>(42);
console.log(numberValue); // 42

const stringValue = identity<string>("Hello");
console.log(stringValue); // "Hello"

const booleanValue = identity<boolean>(true);
console.log(booleanValue); // true

// 実践例1: 配列の最初の要素を取得
function getFirst<T>(items: T[]): T | undefined {
    return items.length > 0 ? items[0] : undefined;
}

const firstNumber = getFirst<number>([1, 2, 3]);
console.log(firstNumber); // 1

const firstString = getFirst<string>(["a", "b", "c"]);
console.log(firstString); // "a"

// 実践例2: 配列の長さを取得（ジェネリクスで型安全性を確保）
function getLength<T>(items: T[]): number {
    return items.length;
}

const numbersLength = getLength<number>([1, 2, 3, 4, 5]);
console.log(numbersLength); // 5

const stringsLength = getLength<string>(["a", "b"]);
console.log(stringsLength); // 2

// 実践例3: 配列に要素を追加する関数
function addToArray<T>(array: T[], item: T): T[] {
    return [...array, item];
}

const numbers = addToArray<number>([1, 2, 3], 4);
console.log(numbers); // [1, 2, 3, 4]

const strings = addToArray<string>(["a", "b"], "c");
console.log(strings); // ["a", "b", "c"]

// 実践例4: 配列から要素を検索する関数
function findItem<T>(items: T[], predicate: (item: T) => boolean): T | undefined {
    return items.find(predicate);
}

const numbers2 = [1, 2, 3, 4, 5];
const found = findItem<number>(numbers2, (n: number): boolean => n > 3);
console.log(found); // 4

const strings2 = ["apple", "banana", "cherry"];
const foundString = findItem<string>(strings2, (s: string): boolean => s.startsWith("b"));
console.log(foundString); // "banana"

// 実践例5: 配列を変換する関数
function mapArray<T, U>(items: T[], transform: (item: T) => U): U[] {
    return items.map(transform);
}

const numbers3 = [1, 2, 3, 4, 5];
const doubled = mapArray<number, number>(numbers3, (n: number): number => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

const strings3 = ["hello", "world"];
const lengths = mapArray<string, number>(strings3, (s: string): number => s.length);
console.log(lengths); // [5, 5]

// 実践例6: オブジェクトのプロパティを取得する関数
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const person = {
    name: "太郎",
    age: 25,
    email: "taro@example.com"
};

const name = getProperty(person, "name");
console.log(name); // "太郎"

const age = getProperty(person, "age");
console.log(age); // 25

// 実践例7: 条件に合う要素を抽出する関数
function filterArray<T>(items: T[], predicate: (item: T) => boolean): T[] {
    return items.filter(predicate);
}

const numbers4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = filterArray<number>(numbers4, (n: number): boolean => n % 2 === 0);
console.log(evens); // [2, 4, 6, 8, 10]

const strings4 = ["apple", "banana", "cherry", "date"];
const longStrings = filterArray<string>(strings4, (s: string): boolean => s.length > 5);
console.log(longStrings); // ["banana", "cherry"]
```

---

## 型引数を省略する記法

### 型推論による省略
TypeScriptは、**引数から型を推論できる場合、型引数を省略できます**。

### 型引数を省略する場合

```typescript
// 型引数を明示的に指定
const value1 = identity<number>(42);

// 型引数を省略（型推論される）
const value2 = identity(42);  // number型と推論される
```

### 実践例: 型引数の省略

```typescript
// src/type-argument-omission.ts
// 型引数を明示的に指定
function getFirst<T>(items: T[]): T | undefined {
    return items.length > 0 ? items[0] : undefined;
}

// 型引数を明示的に指定
const first1 = getFirst<number>([1, 2, 3]);
console.log(first1); // 1

// 型引数を省略（型推論される）
const first2 = getFirst([1, 2, 3]);  // number型と推論される
console.log(first2); // 1

// 文字列配列の場合
const first3 = getFirst<string>(["a", "b", "c"]);
const first4 = getFirst(["a", "b", "c"]);  // string型と推論される
console.log(first3); // "a"
console.log(first4); // "a"

// 実践例1: 配列を結合する関数
function combine<T>(arr1: T[], arr2: T[]): T[] {
    return [...arr1, ...arr2];
}

// 型引数を明示
const combined1 = combine<number>([1, 2], [3, 4]);
console.log(combined1); // [1, 2, 3, 4]

// 型引数を省略
const combined2 = combine([1, 2], [3, 4]);  // number型と推論される
console.log(combined2); // [1, 2, 3, 4]

const combined3 = combine(["a", "b"], ["c", "d"]);  // string型と推論される
console.log(combined3); // ["a", "b", "c", "d"]

// 実践例2: 配列をソートする関数
function sortArray<T>(items: T[], compareFn?: (a: T, b: T) => number): T[] {
    return [...items].sort(compareFn);
}

// 型引数を省略
const sorted1 = sortArray([3, 1, 4, 1, 5, 9, 2, 6]);
console.log(sorted1); // [1, 1, 2, 3, 4, 5, 6, 9]

const sorted2 = sortArray(["banana", "apple", "cherry"]);
console.log(sorted2); // ["apple", "banana", "cherry"]

// 実践例3: 配列から要素を削除する関数
function removeItem<T>(items: T[], item: T): T[] {
    return items.filter((i: T): boolean => i !== item);
}

// 型引数を省略
const numbers1 = removeItem([1, 2, 3, 4, 5], 3);
console.log(numbers1); // [1, 2, 4, 5]

const strings1 = removeItem(["a", "b", "c", "d"], "b");
console.log(strings1); // ["a", "c", "d"]

// 実践例4: オブジェクトの配列を処理する関数
interface User {
    id: number;
    name: string;
}

function getUserNames<T extends { name: string }>(users: T[]): string[] {
    return users.map((user: T): string => user.name);
}

const users: User[] = [
    { id: 1, name: "太郎" },
    { id: 2, name: "花子" },
    { id: 3, name: "次郎" }
];

// 型引数を省略
const names = getUserNames(users);
console.log(names); // ["太郎", "花子", "次郎"]

// 実践例5: 複数の型パラメータがある場合
function pair<T, U>(first: T, second: U): [T, U] {
    return [first, second];
}

// 型引数を省略
const pair1 = pair(1, "hello");
console.log(pair1); // [1, "hello"]

const pair2 = pair("world", true);
console.log(pair2); // ["world", true]

// 注意: 型推論ができない場合は明示的に指定する必要がある
function createArray<T>(length: number, value: T): T[] {
    return new Array(length).fill(value);
}

// 型推論ができない場合は明示的に指定
const array1 = createArray<number>(5, 0);
console.log(array1); // [0, 0, 0, 0, 0]

const array2 = createArray<string>(3, "default");
console.log(array2); // ["default", "default", "default"]
```

---

## 複数の型パラメータの使用

### 複数の型パラメータの基本構文

```typescript
function 関数名<T, U, V>(引数1: T, 引数2: U): V {
    // 処理
}
```

### 複数の型パラメータを使う理由
- **異なる型を扱う**: 入力と出力で異なる型を使いたい場合
- **関連する型を扱う**: キーと値、開始と終了など、関連する型を扱う場合

### 実践例: 複数の型パラメータ

```typescript
// src/multiple-type-parameters.ts
// 基本的な複数の型パラメータ
function pair<T, U>(first: T, second: U): [T, U] {
    return [first, second];
}

const pair1 = pair<number, string>(1, "hello");
console.log(pair1); // [1, "hello"]

const pair2 = pair<string, boolean>("world", true);
console.log(pair2); // ["world", true]

// 型引数を省略
const pair3 = pair(42, "answer");
console.log(pair3); // [42, "answer"]

// 実践例1: 2つの配列を結合して新しい型の配列を作る
function zip<T, U>(arr1: T[], arr2: U[]): [T, U][] {
    const length = Math.min(arr1.length, arr2.length);
    const result: [T, U][] = [];
    for (let i = 0; i < length; i++) {
        result.push([arr1[i], arr2[i]]);
    }
    return result;
}

const numbers = [1, 2, 3];
const strings = ["a", "b", "c"];
const zipped = zip<number, string>(numbers, strings);
console.log(zipped); // [[1, "a"], [2, "b"], [3, "c"]]

// 型引数を省略
const zipped2 = zip([1, 2, 3], ["a", "b", "c"]);
console.log(zipped2); // [[1, "a"], [2, "b"], [3, "c"]]

// 実践例2: 配列を変換して別の型の配列にする
function mapArray<T, U>(items: T[], transform: (item: T) => U): U[] {
    return items.map(transform);
}

const numbers2 = [1, 2, 3, 4, 5];
const strings2 = mapArray<number, string>(numbers2, (n: number): string => n.toString());
console.log(strings2); // ["1", "2", "3", "4", "5"]

const strings3 = ["hello", "world"];
const lengths = mapArray<string, number>(strings3, (s: string): number => s.length);
console.log(lengths); // [5, 5]

// 型引数を省略
const doubled = mapArray([1, 2, 3], (n: number): number => n * 2);
console.log(doubled); // [2, 4, 6]

// 実践例3: オブジェクトのキーと値を取得
function getKeysAndValues<T, K extends keyof T>(obj: T): [K[], T[K][]] {
    const keys = Object.keys(obj) as K[];
    const values = Object.values(obj) as T[K][];
    return [keys, values];
}

const person = {
    name: "太郎",
    age: 25,
    email: "taro@example.com"
};

const [keys, values] = getKeysAndValues(person);
console.log(keys);   // ["name", "age", "email"]
console.log(values); // ["太郎", 25, "taro@example.com"]

// 実践例4: 2つの値を比較する関数
function compare<T, U>(value1: T, value2: U, compareFn: (a: T, b: U) => number): number {
    return compareFn(value1, value2);
}

const result1 = compare<number, number>(10, 20, (a: number, b: number): number => a - b);
console.log(result1); // -10

const result2 = compare<string, string>("apple", "banana", (a: string, b: string): number => 
    a.localeCompare(b)
);
console.log(result2); // 負の値（apple < banana）

// 実践例5: オブジェクトをマージする関数
function merge<T, U>(obj1: T, obj2: U): T & U {
    return { ...obj1, ...obj2 };
}

const obj1 = { name: "太郎", age: 25 };
const obj2 = { email: "taro@example.com", city: "東京" };
const merged = merge(obj1, obj2);
console.log(merged); // { name: "太郎", age: 25, email: "taro@example.com", city: "東京" }

// 実践例6: 3つの型パラメータを使う例
function createTuple<T, U, V>(first: T, second: U, third: V): [T, U, V] {
    return [first, second, third];
}

const tuple = createTuple<number, string, boolean>(1, "hello", true);
console.log(tuple); // [1, "hello", true]

// 型引数を省略
const tuple2 = createTuple("world", 42, false);
console.log(tuple2); // ["world", 42, false]

// 実践例7: 非同期処理で複数の型パラメータを使う
async function fetchAndTransform<T, U>(
    url: string,
    transform: (data: T) => U
): Promise<U> {
    // 実際の実装ではfetchを使用
    const data = {} as T;  // シミュレーション
    return transform(data);
}

// 使用例（型推論により型が決定される）
interface ApiResponse {
    id: number;
    name: string;
}

interface TransformedData {
    identifier: number;
    fullName: string;
}

// 型引数を明示
const result = await fetchAndTransform<ApiResponse, TransformedData>(
    "https://api.example.com/user",
    (data: ApiResponse): TransformedData => ({
        identifier: data.id,
        fullName: data.name
    })
);
```

---

## ジェネリクスの型制約と応用

### 型制約とは
型制約は、**型パラメータに条件を付ける**機能です。`extends`キーワードを使って、型パラメータが特定の型やインターフェースを満たすことを要求できます。

### 型制約の基本構文

```typescript
function 関数名<T extends 制約型>(引数: T): 戻り値の型 {
    // 処理
}
```

### 型制約のメリット
- **型安全性の向上**: 必要なプロパティやメソッドが存在することを保証
- **コード補完**: IDEが適切な補完を提供
- **エラーの早期発見**: コンパイル時にエラーを検出

### 実践例: 型制約と応用

```typescript
// src/type-constraints.ts
// 基本的な型制約
interface HasLength {
    length: number;
}

function getLength<T extends HasLength>(item: T): number {
    return item.length;
}

const stringLength = getLength<string>("hello");
console.log(stringLength); // 5

const arrayLength = getLength<number[]>([1, 2, 3, 4, 5]);
console.log(arrayLength); // 5

// 実践例1: オブジェクトのプロパティにアクセス
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}

const person = {
    name: "太郎",
    age: 25,
    email: "taro@example.com"
};

const name = getProperty(person, "name");
console.log(name); // "太郎"

const age = getProperty(person, "age");
console.log(age); // 25

// 実践例2: 比較可能な型に制約
interface Comparable {
    compareTo(other: Comparable): number;
}

function findMax<T extends Comparable>(items: T[]): T | undefined {
    if (items.length === 0) {
        return undefined;
    }
    
    let max = items[0];
    for (let i = 1; i < items.length; i++) {
        if (items[i].compareTo(max) > 0) {
            max = items[i];
        }
    }
    return max;
}

class NumberWrapper implements Comparable {
    constructor(public value: number) {}
    
    compareTo(other: NumberWrapper): number {
        return this.value - other.value;
    }
}

const numbers = [
    new NumberWrapper(10),
    new NumberWrapper(5),
    new NumberWrapper(20)
];

const max = findMax(numbers);
console.log(max?.value); // 20

// 実践例3: 特定のプロパティを持つ型に制約
interface HasId {
    id: number;
}

function findById<T extends HasId>(items: T[], id: number): T | undefined {
    return items.find((item: T): boolean => item.id === id);
}

interface User extends HasId {
    name: string;
    email: string;
}

const users: User[] = [
    { id: 1, name: "太郎", email: "taro@example.com" },
    { id: 2, name: "花子", email: "hanako@example.com" },
    { id: 3, name: "次郎", email: "jiro@example.com" }
];

const user = findById(users, 2);
console.log(user); // { id: 2, name: "花子", email: "hanako@example.com" }

// 実践例4: 複数の型制約
interface HasName {
    name: string;
}

interface HasAge {
    age: number;
}

function getInfo<T extends HasName & HasAge>(person: T): string {
    return `${person.name} (${person.age}歳)`;
}

const person2 = {
    name: "太郎",
    age: 25,
    email: "taro@example.com"
};

const info = getInfo(person2);
console.log(info); // "太郎 (25歳)"

// 実践例5: 関数型に制約
interface Callable {
    (): void;
}

function execute<T extends Callable>(fn: T): void {
    fn();
}

const myFunction = (): void => {
    console.log("関数が実行されました");
};

execute(myFunction); // "関数が実行されました"

// 実践例6: 配列の要素型に制約
function getFirstOfType<T extends { id: number }>(items: T[]): T | undefined {
    return items.length > 0 ? items[0] : undefined;
}

interface Product {
    id: number;
    name: string;
    price: number;
}

const products: Product[] = [
    { id: 1, name: "商品A", price: 1000 },
    { id: 2, name: "商品B", price: 2000 }
];

const firstProduct = getFirstOfType(products);
console.log(firstProduct); // { id: 1, name: "商品A", price: 1000 }

// 実践例7: デフォルト型パラメータ
interface Cache<T = string> {
    get(key: string): T | undefined;
    set(key: string, value: T): void;
}

class SimpleCache<T = string> implements Cache<T> {
    private data: Map<string, T> = new Map();
    
    get(key: string): T | undefined {
        return this.data.get(key);
    }
    
    set(key: string, value: T): void {
        this.data.set(key, value);
    }
}

const stringCache = new SimpleCache<string>();
stringCache.set("name", "太郎");
console.log(stringCache.get("name")); // "太郎"

const numberCache = new SimpleCache<number>();
numberCache.set("age", 25);
console.log(numberCache.get("age")); // 25

// デフォルト型を使用
const defaultCache = new SimpleCache();
defaultCache.set("key", "value");
console.log(defaultCache.get("key")); // "value"
```

---

## ジェネリッククラスの実装

### ジェネリッククラスの基本構文

```typescript
class クラス名<型パラメータ> {
    プロパティ: 型パラメータ;
    
    constructor(引数: 型パラメータ) {
        this.プロパティ = 引数;
    }
    
    メソッド(): 型パラメータ {
        // 処理
    }
}
```

### ジェネリッククラスのメリット
- **型安全性**: クラス全体で同じ型を使用できる
- **再利用性**: 1つのクラス定義で複数の型に対応
- **柔軟性**: インスタンス化時に型を指定できる

### 実践例: ジェネリッククラスの実装

```typescript
// src/generic-class.ts
// 基本的なジェネリッククラス
class Box<T> {
    private content: T;
    
    constructor(content: T) {
        this.content = content;
    }
    
    public getContent(): T {
        return this.content;
    }
    
    public setContent(content: T): void {
        this.content = content;
    }
}

const numberBox = new Box<number>(42);
console.log(numberBox.getContent()); // 42

const stringBox = new Box<string>("Hello");
console.log(stringBox.getContent()); // "Hello"

// 型引数を省略
const booleanBox = new Box(true);
console.log(booleanBox.getContent()); // true

// 実践例1: スタック（LIFO: Last In First Out）
class Stack<T> {
    private items: T[] = [];
    
    public push(item: T): void {
        this.items.push(item);
    }
    
    public pop(): T | undefined {
        return this.items.pop();
    }
    
    public peek(): T | undefined {
        return this.items.length > 0 ? this.items[this.items.length - 1] : undefined;
    }
    
    public isEmpty(): boolean {
        return this.items.length === 0;
    }
    
    public size(): number {
        return this.items.length;
    }
}

const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
numberStack.push(3);
console.log(numberStack.pop()); // 3
console.log(numberStack.peek()); // 2

const stringStack = new Stack<string>();
stringStack.push("a");
stringStack.push("b");
console.log(stringStack.pop()); // "b"

// 実践例2: キュー（FIFO: First In First Out）
class Queue<T> {
    private items: T[] = [];
    
    public enqueue(item: T): void {
        this.items.push(item);
    }
    
    public dequeue(): T | undefined {
        return this.items.shift();
    }
    
    public front(): T | undefined {
        return this.items.length > 0 ? this.items[0] : undefined;
    }
    
    public isEmpty(): boolean {
        return this.items.length === 0;
    }
    
    public size(): number {
        return this.items.length;
    }
}

const numberQueue = new Queue<number>();
numberQueue.enqueue(1);
numberQueue.enqueue(2);
numberQueue.enqueue(3);
console.log(numberQueue.dequeue()); // 1
console.log(numberQueue.front());   // 2

// 実践例3: ペア（2つの値を保持）
class Pair<T, U> {
    private first: T;
    private second: U;
    
    constructor(first: T, second: U) {
        this.first = first;
        this.second = second;
    }
    
    public getFirst(): T {
        return this.first;
    }
    
    public getSecond(): U {
        return this.second;
    }
    
    public setFirst(first: T): void {
        this.first = first;
    }
    
    public setSecond(second: U): void {
        this.second = second;
    }
}

const pair = new Pair<number, string>(1, "hello");
console.log(pair.getFirst());  // 1
console.log(pair.getSecond()); // "hello"

// 実践例4: キャッシュクラス
class Cache<K, V> {
    private data: Map<K, V> = new Map();
    
    public set(key: K, value: V): void {
        this.data.set(key, value);
    }
    
    public get(key: K): V | undefined {
        return this.data.get(key);
    }
    
    public has(key: K): boolean {
        return this.data.has(key);
    }
    
    public delete(key: K): boolean {
        return this.data.delete(key);
    }
    
    public clear(): void {
        this.data.clear();
    }
    
    public size(): number {
        return this.data.size;
    }
}

const cache = new Cache<string, number>();
cache.set("age", 25);
cache.set("score", 100);
console.log(cache.get("age"));   // 25
console.log(cache.has("score"));  // true

// 実践例5: リポジトリパターン
interface Repository<T> {
    findById(id: number): T | undefined;
    findAll(): T[];
    save(entity: T): void;
    delete(id: number): boolean;
}

class UserRepository implements Repository<User> {
    private users: User[] = [];
    
    findById(id: number): User | undefined {
        return this.users.find((user: User): boolean => user.id === id);
    }
    
    findAll(): User[] {
        return [...this.users];
    }
    
    save(user: User): void {
        const index = this.users.findIndex((u: User): boolean => u.id === user.id);
        if (index >= 0) {
            this.users[index] = user;
        } else {
            this.users.push(user);
        }
    }
    
    delete(id: number): boolean {
        const index = this.users.findIndex((user: User): boolean => user.id === id);
        if (index >= 0) {
            this.users.splice(index, 1);
            return true;
        }
        return false;
    }
}

interface User {
    id: number;
    name: string;
    email: string;
}

const userRepository = new UserRepository();
userRepository.save({ id: 1, name: "太郎", email: "taro@example.com" });
userRepository.save({ id: 2, name: "花子", email: "hanako@example.com" });

const user = userRepository.findById(1);
console.log(user); // { id: 1, name: "太郎", email: "taro@example.com" }

const allUsers = userRepository.findAll();
console.log(allUsers); // [{ id: 1, ... }, { id: 2, ... }]

// 実践例6: 型制約付きジェネリッククラス
interface Identifiable {
    id: number;
}

class Repository<T extends Identifiable> {
    private items: T[] = [];
    
    public findById(id: number): T | undefined {
        return this.items.find((item: T): boolean => item.id === id);
    }
    
    public findAll(): T[] {
        return [...this.items];
    }
    
    public save(item: T): void {
        const index = this.items.findIndex((i: T): boolean => i.id === item.id);
        if (index >= 0) {
            this.items[index] = item;
        } else {
            this.items.push(item);
        }
    }
    
    public delete(id: number): boolean {
        const index = this.items.findIndex((item: T): boolean => item.id === id);
        if (index >= 0) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }
}

interface Product extends Identifiable {
    name: string;
    price: number;
}

const productRepository = new Repository<Product>();
productRepository.save({ id: 1, name: "商品A", price: 1000 });
productRepository.save({ id: 2, name: "商品B", price: 2000 });

const product = productRepository.findById(1);
console.log(product); // { id: 1, name: "商品A", price: 1000 }
```

---

## まとめ

この章では、TypeScriptのジェネリクスについて学びました。

### 学んだこと
- **ジェネリクスの概念**: 型をパラメータとして扱う機能
- **ジェネリック関数**: 型パラメータを使った関数の定義
- **型引数の省略**: 型推論により型引数を省略できる
- **複数の型パラメータ**: 複数の型を同時に扱う
- **型制約**: 型パラメータに条件を付ける
- **ジェネリッククラス**: 型パラメータを使ったクラスの定義

### 重要なポイント
1. **コードの再利用**: 同じコードを複数の型で使える
2. **型安全性**: 型チェックが効くため、エラーを防げる
3. **柔軟性**: 後から型を指定できる
4. **型推論**: 型引数を省略できる場合がある
5. **型制約**: 必要なプロパティやメソッドを保証できる

### 使い分けの目安
- **ジェネリック関数**: 複数の型で使いたい関数
- **ジェネリッククラス**: 複数の型で使いたいクラス
- **型制約**: 特定の条件を満たす型のみを受け入れたい場合
- **複数の型パラメータ**: 異なる型を同時に扱う場合

### 次のステップ
ジェネリクスを理解することで、より柔軟で再利用可能なコードを書けるようになります。実際のプロジェクトで積極的にジェネリクスを活用してみましょう。

---

## 演習問題

### 問題1: ジェネリック関数
配列の最後の要素を取得するジェネリック関数`getLast`を作成してください。

<details>
<summary>解答例</summary>

```typescript
function getLast<T>(items: T[]): T | undefined {
    return items.length > 0 ? items[items.length - 1] : undefined;
}

const lastNumber = getLast<number>([1, 2, 3, 4, 5]);
console.log(lastNumber); // 5

const lastString = getLast<string>(["a", "b", "c"]);
console.log(lastString); // "c"

// 型引数を省略
const last = getLast([1, 2, 3]);
console.log(last); // 3
```
</details>

### 問題2: 複数の型パラメータ
2つの値をペアにする関数`createPair`を作成してください。2つの型パラメータを使用してください。

<details>
<summary>解答例</summary>

```typescript
function createPair<T, U>(first: T, second: U): [T, U] {
    return [first, second];
}

const pair1 = createPair<number, string>(1, "hello");
console.log(pair1); // [1, "hello"]

const pair2 = createPair<string, boolean>("world", true);
console.log(pair2); // ["world", true]

// 型引数を省略
const pair3 = createPair(42, "answer");
console.log(pair3); // [42, "answer"]
```
</details>

### 問題3: 型制約
`length`プロパティを持つ型のみを受け入れる関数`getLength`を作成してください。

<details>
<summary>解答例</summary>

```typescript
interface HasLength {
    length: number;
}

function getLength<T extends HasLength>(item: T): number {
    return item.length;
}

const stringLength = getLength<string>("hello");
console.log(stringLength); // 5

const arrayLength = getLength<number[]>([1, 2, 3, 4, 5]);
console.log(arrayLength); // 5
```
</details>

### 問題4: ジェネリッククラス
ジェネリッククラス`Container`を作成し、値を保持して取得できるようにしてください。

<details>
<summary>解答例</summary>

```typescript
class Container<T> {
    private value: T;
    
    constructor(value: T) {
        this.value = value;
    }
    
    public getValue(): T {
        return this.value;
    }
    
    public setValue(value: T): void {
        this.value = value;
    }
}

const numberContainer = new Container<number>(42);
console.log(numberContainer.getValue()); // 42

const stringContainer = new Container<string>("Hello");
console.log(stringContainer.getValue()); // "Hello"

// 型引数を省略
const booleanContainer = new Container(true);
console.log(booleanContainer.getValue()); // true
```
</details>

### 問題5: ジェネリックスタック
ジェネリッククラス`Stack`を作成し、`push`、`pop`、`peek`メソッドを実装してください。

<details>
<summary>解答例</summary>

```typescript
class Stack<T> {
    private items: T[] = [];
    
    public push(item: T): void {
        this.items.push(item);
    }
    
    public pop(): T | undefined {
        return this.items.pop();
    }
    
    public peek(): T | undefined {
        return this.items.length > 0 ? this.items[this.items.length - 1] : undefined;
    }
    
    public isEmpty(): boolean {
        return this.items.length === 0;
    }
}

const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
numberStack.push(3);
console.log(numberStack.pop()); // 3
console.log(numberStack.peek()); // 2
console.log(numberStack.isEmpty()); // false

const stringStack = new Stack<string>();
stringStack.push("a");
stringStack.push("b");
console.log(stringStack.pop()); // "b"
```
</details>

---

お疲れ様でした！次の章に進みましょう。

