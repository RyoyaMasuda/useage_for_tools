# 9-3. 比較と応用

この章では、Interfaceと型エイリアスの使い分け、そしてIntersection型（交差型）による型の合成について学びます。これらを理解することで、より柔軟で強力な型システムを活用できるようになります。

---

## 目次

- [Interfaceと型エイリアスの使い分け](#interfaceと型エイリアスの使い分け)
- [Intersection型（交差型）による型の合成](#intersection型交差型による型の合成)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Interfaceと型エイリアスの使い分け

### Interfaceと型エイリアスの違い

TypeScriptでは、オブジェクトの型を定義する方法として、**Interface**と**型エイリアス**の2つがあります。それぞれに特徴があり、適切に使い分けることが重要です。

### 主な違い

| 特徴 | Interface | 型エイリアス |
|------|-----------|-------------|
| 宣言のマージ | 可能（同じ名前で複数回宣言できる） | 不可 |
| 拡張 | `extends`で拡張 | `&`（交差型）で合成 |
| 実装 | クラスで`implements`できる | できない |
| プリミティブ型 | 定義できない | 定義できる |
| ユニオン型 | 定義できない | 定義できる |
| 計算されたプロパティ | 定義できない | 定義できる |

### Interfaceを使うべき場面

1. **オブジェクトの構造を定義する場合**
2. **クラスで実装する必要がある場合**
3. **宣言のマージを活用したい場合**
4. **拡張性を重視する場合**

### 型エイリアスを使うべき場面

1. **ユニオン型や交差型を定義する場合**
2. **プリミティブ型に別名を付ける場合**
3. **計算されたプロパティを使う場合**
4. **より柔軟な型定義が必要な場合**

### 実践例: Interfaceと型エイリアスの使い分け

```typescript
// src/interface-vs-type-alias.ts
// 実践例1: Interface - オブジェクトの構造定義
interface Person {
    name: string;
    age: number;
    email: string;
}

// Interfaceは拡張できる
interface Employee extends Person {
    employeeId: string;
    department: string;
}

const employee: Employee = {
    name: "太郎",
    age: 25,
    email: "taro@example.com",
    employeeId: "E001",
    department: "開発部"
};

console.log(`従業員: ${employee.name} (${employee.department})`);

// 実践例2: 型エイリアス - ユニオン型
type Status = "pending" | "approved" | "rejected";
type ID = string | number;

// 型エイリアスはユニオン型を定義できる
type StringOrNumber = string | number;
type Maybe<T> = T | null | undefined;

const status: Status = "pending";
const id: ID = 123;

console.log(`ステータス: ${status}, ID: ${id}`);

// 実践例3: Interface - 宣言のマージ
interface Config {
    host: string;
    port: number;
}

// 同じ名前で再度宣言すると、マージされる
interface Config {
    timeout: number;
}

// マージされた結果、Configは host, port, timeout を持つ
const config: Config = {
    host: "localhost",
    port: 3000,
    timeout: 5000
};

console.log(`設定: ${config.host}:${config.port} (タイムアウト: ${config.timeout}ms)`);

// 型エイリアスでは宣言のマージはできない
// type Config2 = { host: string; };
// type Config2 = { port: number; }; // エラー: 重複した識別子

// 実践例4: Interface - クラスで実装
interface Drawable {
    draw(): void;
}

class Circle implements Drawable {
    radius: number;
    
    constructor(radius: number) {
        this.radius = radius;
    }
    
    draw(): void {
        console.log(`半径${this.radius}の円を描画`);
    }
}

class Rectangle implements Drawable {
    width: number;
    height: number;
    
    constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
    }
    
    draw(): void {
        console.log(`${this.width}x${this.height}の矩形を描画`);
    }
}

const circle = new Circle(5);
const rectangle = new Rectangle(10, 20);

circle.draw();
rectangle.draw();

// 実践例5: 型エイリアス - プリミティブ型
type UserID = number;
type UserName = string;
type IsActive = boolean;

const userId: UserID = 123;
const userName: UserName = "太郎";
const isActive: IsActive = true;

console.log(`ユーザー: ${userName} (ID: ${userId}, アクティブ: ${isActive})`);

// 実践例6: 型エイリアス - 計算されたプロパティ
type EventType = "click" | "submit" | "change";

type EventMap = {
    [K in EventType]: {
        type: K;
        timestamp: number;
    };
};

const clickEvent: EventMap["click"] = {
    type: "click",
    timestamp: Date.now()
};

console.log(`イベント: ${clickEvent.type} (${clickEvent.timestamp})`);

// 実践例7: 使い分けの例 - APIレスポンス
// Interface: オブジェクトの構造を定義
interface APIResponse<T> {
    success: boolean;
    data: T;
    message?: string;
}

// 型エイリアス: ユニオン型を定義
type APIError = {
    code: number;
    message: string;
};

type APIResult<T> = APIResponse<T> | APIError;

function handleResponse<T>(result: APIResult<T>): void {
    if ("success" in result) {
        console.log(`成功: ${result.data}`);
    } else {
        console.log(`エラー: ${result.message} (コード: ${result.code})`);
    }
}

// 実践例8: 使い分けの例 - 設定オブジェクト
// Interface: 拡張可能な構造
interface BaseConfig {
    env: "development" | "production";
    debug: boolean;
}

interface DatabaseConfig extends BaseConfig {
    host: string;
    port: number;
}

// 型エイリアス: 複雑な型の組み合わせ
type ConfigValue = string | number | boolean;
type ConfigObject = Record<string, ConfigValue>;

const dbConfig: DatabaseConfig = {
    env: "development",
    debug: true,
    host: "localhost",
    port: 5432
};

console.log(`データベース設定: ${dbConfig.host}:${dbConfig.port}`);

// 実践例9: 推奨される使い分け
// Interface: 公開APIやライブラリの型定義
interface PublicAPI {
    version: string;
    endpoints: string[];
}

// 型エイリアス: 内部的な型定義やユーティリティ型
type InternalState = "idle" | "loading" | "success" | "error";
type Optional<T> = T | undefined;

// 実践例10: 両方を使う例
interface User {
    id: number;
    name: string;
    email: string;
}

// 型エイリアスでユニオン型を定義
type UserRole = "admin" | "user" | "guest";

// Interfaceで拡張
interface UserWithRole extends User {
    role: UserRole;
}

const admin: UserWithRole = {
    id: 1,
    name: "管理者",
    email: "admin@example.com",
    role: "admin"
};

console.log(`ユーザー: ${admin.name} (役割: ${admin.role})`);
```

---

## Intersection型（交差型）による型の合成

### Intersection型とは
Intersection型（交差型）は、**複数の型を組み合わせて新しい型を作成する**機能です。`&`演算子を使用します。

### Intersection型の基本構文

```typescript
type 新しい型 = 型1 & 型2 & 型3;
```

### Intersection型の特徴
- **型の合成**: 複数の型のすべてのプロパティを持つ
- **型の組み合わせ**: Interfaceや型エイリアスを組み合わせられる
- **柔軟性**: 必要な型を自由に組み合わせられる

### 基本的なIntersection型

```typescript
type A = { a: string };
type B = { b: number };
type C = A & B; // { a: string; b: number }
```

### 実践例: Intersection型

```typescript
// src/intersection-type.ts
// 基本的なIntersection型
type Name = {
    name: string;
};

type Age = {
    age: number;
};

type Person = Name & Age;

const person: Person = {
    name: "太郎",
    age: 25
};

console.log(`名前: ${person.name}, 年齢: ${person.age}`);

// 実践例1: Interfaceと型エイリアスの組み合わせ
interface Identifiable {
    id: number;
}

interface Timestamped {
    createdAt: Date;
    updatedAt: Date;
}

type Entity = Identifiable & Timestamped;

const entity: Entity = {
    id: 1,
    createdAt: new Date(),
    updatedAt: new Date()
};

console.log(`エンティティ: ID ${entity.id}, 作成日: ${entity.createdAt}`);

// 実践例2: 複数の型を組み合わせる
type HasName = { name: string };
type HasEmail = { email: string };
type HasPhone = { phone: string };

type Contact = HasName & HasEmail & HasPhone;

const contact: Contact = {
    name: "太郎",
    email: "taro@example.com",
    phone: "090-1234-5678"
};

console.log(`連絡先: ${contact.name}, ${contact.email}, ${contact.phone}`);

// 実践例3: 既存の型を拡張
interface BaseUser {
    id: number;
    name: string;
}

type Admin = BaseUser & {
    role: "admin";
    permissions: string[];
};

type RegularUser = BaseUser & {
    role: "user";
};

type User = Admin | RegularUser;

function getUserInfo(user: User): void {
    console.log(`ユーザー: ${user.name} (ID: ${user.id})`);
    if (user.role === "admin") {
        console.log(`権限: ${user.permissions.join(", ")}`);
    }
}

const admin: Admin = {
    id: 1,
    name: "管理者",
    role: "admin",
    permissions: ["read", "write", "delete"]
};

getUserInfo(admin);

// 実践例4: 関数型のIntersection
type Logger = {
    log: (message: string) => void;
};

type ErrorHandler = {
    handleError: (error: Error) => void;
};

type LoggerWithErrorHandler = Logger & ErrorHandler;

const logger: LoggerWithErrorHandler = {
    log: (message: string): void => {
        console.log(`[LOG] ${message}`);
    },
    handleError: (error: Error): void => {
        console.error(`[ERROR] ${error.message}`);
    }
};

logger.log("処理が完了しました");
logger.handleError(new Error("エラーが発生しました"));

// 実践例5: オプショナルプロパティの組み合わせ
type RequiredFields = {
    name: string;
    email: string;
};

type OptionalFields = {
    age?: number;
    phone?: string;
};

type UserProfile = RequiredFields & OptionalFields;

const profile1: UserProfile = {
    name: "太郎",
    email: "taro@example.com"
};

const profile2: UserProfile = {
    name: "花子",
    email: "hanako@example.com",
    age: 30,
    phone: "090-1234-5678"
};

console.log(`プロフィール1: ${profile1.name}`);
console.log(`プロフィール2: ${profile1.name}, ${profile2.age}歳`);

// 実践例6: 型の合成とオーバーライド
type Base = {
    id: number;
    name: string;
};

type Extended = Base & {
    name: string; // 同じプロパティ名（型が互換性があればOK）
    description: string;
};

const extended: Extended = {
    id: 1,
    name: "拡張",
    description: "説明"
};

console.log(`拡張: ${extended.name} - ${extended.description}`);

// 実践例7: 複雑な型の合成
interface Drawable {
    draw(): void;
}

interface Movable {
    move(x: number, y: number): void;
}

interface Resizable {
    resize(width: number, height: number): void;
}

type Shape = Drawable & Movable & Resizable;

class Rectangle implements Shape {
    x: number = 0;
    y: number = 0;
    width: number = 100;
    height: number = 50;
    
    draw(): void {
        console.log(`矩形を描画: (${this.x}, ${this.y}), サイズ: ${this.width}x${this.height}`);
    }
    
    move(x: number, y: number): void {
        this.x = x;
        this.y = y;
        console.log(`位置を移動: (${x}, ${y})`);
    }
    
    resize(width: number, height: number): void {
        this.width = width;
        this.height = height;
        console.log(`サイズを変更: ${width}x${height}`);
    }
}

const rect = new Rectangle();
rect.draw();
rect.move(10, 20);
rect.resize(200, 100);

// 実践例8: ユニオン型とIntersection型の組み合わせ
type Status = "active" | "inactive";
type Role = "admin" | "user";

type UserStatus = {
    status: Status;
};

type UserRole = {
    role: Role;
};

type UserWithStatusAndRole = UserStatus & UserRole;

const user: UserWithStatusAndRole = {
    status: "active",
    role: "admin"
};

console.log(`ユーザー: ステータス=${user.status}, 役割=${user.role}`);

// 実践例9: 条件付き型との組み合わせ
type NonNullable<T> = T extends null | undefined ? never : T;

type RequiredFields<T> = {
    [K in keyof T]-?: NonNullable<T[K]>;
};

type OptionalFields<T> = {
    [K in keyof T]?: T[K];
};

type PartialUser = {
    name?: string;
    email?: string;
    age?: number;
};

type RequiredUser = RequiredFields<PartialUser> & {
    id: number;
};

const requiredUser: RequiredUser = {
    id: 1,
    name: "太郎",
    email: "taro@example.com",
    age: 25
};

console.log(`必須ユーザー: ${requiredUser.name}, ${requiredUser.email}`);

// 実践例10: 実用的な型合成パターン
interface Timestamp {
    createdAt: Date;
    updatedAt: Date;
}

interface SoftDelete {
    deletedAt?: Date;
    isDeleted: boolean;
}

type Auditable<T> = T & Timestamp & SoftDelete;

type Product = {
    id: number;
    name: string;
    price: number;
};

type AuditableProduct = Auditable<Product>;

const product: AuditableProduct = {
    id: 1,
    name: "商品",
    price: 1000,
    createdAt: new Date(),
    updatedAt: new Date(),
    isDeleted: false
};

console.log(`商品: ${product.name} (${product.price}円), 作成日: ${product.createdAt}`);
```

---

## まとめ

この章では、Interfaceと型エイリアスの使い分け、そしてIntersection型による型の合成について学びました。

### 学んだこと
- Interfaceと型エイリアスの違い: それぞれの特徴と使い分け
- Intersection型: 複数の型を組み合わせて新しい型を作成

### 重要なポイント
1. **Interface**: オブジェクトの構造定義、クラスの実装、宣言のマージに適している
2. **型エイリアス**: ユニオン型、プリミティブ型、計算されたプロパティに適している
3. **Intersection型**: `&`演算子で複数の型を組み合わせる
4. **使い分け**: 用途に応じて適切な方法を選択する

### 次のステップ
次の章では、高度な型システムについて詳しく学びます。

---

## 演習問題

### 問題1: Interfaceと型エイリアスの使い分け
名前と年齢を持つ`Person`型を、Interfaceと型エイリアスの両方で定義してください。

<details>
<summary>解答例</summary>

```typescript
// Interface
interface PersonInterface {
    name: string;
    age: number;
}

// 型エイリアス
type PersonType = {
    name: string;
    age: number;
};

const person1: PersonInterface = { name: "太郎", age: 25 };
const person2: PersonType = { name: "花子", age: 30 };

console.log(`person1: ${person1.name}, person2: ${person2.name}`);
```
</details>

### 問題2: Intersection型の基本
`HasName`と`HasEmail`を組み合わせて`Contact`型を作成してください。

<details>
<summary>解答例</summary>

```typescript
type HasName = { name: string };
type HasEmail = { email: string };

type Contact = HasName & HasEmail;

const contact: Contact = {
    name: "太郎",
    email: "taro@example.com"
};

console.log(`連絡先: ${contact.name}, ${contact.email}`);
```
</details>

### 問題3: Interfaceの拡張
`BaseUser`を拡張して`AdminUser`型を作成してください。

<details>
<summary>解答例</summary>

```typescript
interface BaseUser {
    id: number;
    name: string;
}

interface AdminUser extends BaseUser {
    role: "admin";
    permissions: string[];
}

const admin: AdminUser = {
    id: 1,
    name: "管理者",
    role: "admin",
    permissions: ["read", "write"]
};

console.log(`管理者: ${admin.name}, 権限: ${admin.permissions.join(", ")}`);
```
</details>

### 問題4: Intersection型で型を合成
`Identifiable`と`Timestamped`を組み合わせて`Entity`型を作成してください。

<details>
<summary>解答例</summary>

```typescript
interface Identifiable {
    id: number;
}

interface Timestamped {
    createdAt: Date;
}

type Entity = Identifiable & Timestamped;

const entity: Entity = {
    id: 1,
    createdAt: new Date()
};

console.log(`エンティティ: ID ${entity.id}, 作成日: ${entity.createdAt}`);
```
</details>

### 問題5: 複雑な型の合成
`Drawable`と`Movable`を組み合わせて`Shape`型を作成し、クラスで実装してください。

<details>
<summary>解答例</summary>

```typescript
interface Drawable {
    draw(): void;
}

interface Movable {
    move(x: number, y: number): void;
}

type Shape = Drawable & Movable;

class Circle implements Shape {
    x: number = 0;
    y: number = 0;
    
    draw(): void {
        console.log(`円を描画: (${this.x}, ${this.y})`);
    }
    
    move(x: number, y: number): void {
        this.x = x;
        this.y = y;
    }
}

const circle = new Circle();
circle.draw();
circle.move(10, 20);
circle.draw();
```
</details>

---

お疲れ様でした！次の章に進みましょう。

