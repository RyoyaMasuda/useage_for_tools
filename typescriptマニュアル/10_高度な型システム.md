# 10. 高度な型システム

この章では、TypeScriptの高度な型システムについて学びます。Union型、Literal型、型アサーション、型ガードを理解することで、より柔軟で安全な型システムを活用できるようになります。

---

## 目次

- [Union型（共用型）](#union型共用型)
- [Literal型](#literal型)
- [asキーワードによる型アサーション](#asキーワードによる型アサーション)
- [型ガード（Type Guard）による安全な型チェック](#型ガードtype-guardによる安全な型チェック)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Union型（共用型）

### Union型とは
Union型（共用型）は、**複数の型のいずれかを受け入れる**型です。`|`演算子を使用します。

### Union型の基本構文

```typescript
type 型名 = 型1 | 型2 | 型3;
```

### Union型の特徴
- **複数の型を受け入れる**: いずれかの型の値を受け入れる
- **型の柔軟性**: 様々な型を組み合わせられる
- **型の安全性**: TypeScriptが適切に型チェックを行う

### 基本的なUnion型

```typescript
type StringOrNumber = string | number;
type Status = "pending" | "approved" | "rejected";
```

### 実践例: Union型

```typescript
// src/union-type.ts
// 基本的なUnion型
type StringOrNumber = string | number;

function processValue(value: StringOrNumber): void {
    if (typeof value === "string") {
        console.log(`文字列: ${value.toUpperCase()}`);
    } else {
        console.log(`数値: ${value * 2}`);
    }
}

processValue("hello");  // 文字列: HELLO
processValue(10);       // 数値: 20

// 実践例1: 複数のプリミティブ型
type ID = string | number;
type Maybe<T> = T | null | undefined;

function getID(id: ID): string {
    if (typeof id === "string") {
        return id;
    } else {
        return id.toString();
    }
}

const id1: ID = "123";
const id2: ID = 456;

console.log(`ID1: ${getID(id1)}`); // ID1: 123
console.log(`ID2: ${getID(id2)}`); // ID2: 456

// 実践例2: オブジェクト型のUnion
type Circle = {
    kind: "circle";
    radius: number;
};

type Rectangle = {
    kind: "rectangle";
    width: number;
    height: number;
};

type Shape = Circle | Rectangle;

function getArea(shape: Shape): number {
    if (shape.kind === "circle") {
        return Math.PI * shape.radius * shape.radius;
    } else {
        return shape.width * shape.height;
    }
}

const circle: Shape = { kind: "circle", radius: 5 };
const rectangle: Shape = { kind: "rectangle", width: 10, height: 20 };

console.log(`円の面積: ${getArea(circle).toFixed(2)}`);        // 78.54
console.log(`矩形の面積: ${getArea(rectangle)}`);             // 200

// 実践例3: 関数型のUnion
type StringProcessor = ((str: string) => string) | ((str: string) => number);

function processString(str: string, processor: StringProcessor): string | number {
    return processor(str);
}

const upperCase: StringProcessor = (str: string): string => str.toUpperCase();
const length: StringProcessor = (str: string): number => str.length;

console.log(processString("hello", upperCase)); // HELLO
console.log(processString("hello", length));   // 5

// 実践例4: 配列型のUnion
type NumberOrStringArray = number[] | string[];

function sumArray(arr: NumberOrStringArray): number {
    if (arr.length === 0) return 0;
    
    if (typeof arr[0] === "number") {
        return (arr as number[]).reduce((acc, n) => acc + n, 0);
    } else {
        return (arr as string[]).reduce((acc, s) => acc + s.length, 0);
    }
}

const numbers: NumberOrStringArray = [1, 2, 3, 4, 5];
const strings: NumberOrStringArray = ["a", "bb", "ccc"];

console.log(`数値の合計: ${sumArray(numbers)}`);   // 15
console.log(`文字列の長さの合計: ${sumArray(strings)}`); // 6

// 実践例5: 複雑なUnion型
type Success<T> = {
    success: true;
    data: T;
};

type Error = {
    success: false;
    error: string;
};

type Result<T> = Success<T> | Error;

function handleResult<T>(result: Result<T>): void {
    if (result.success) {
        console.log(`成功: ${result.data}`);
    } else {
        console.log(`エラー: ${result.error}`);
    }
}

const successResult: Result<string> = {
    success: true,
    data: "処理が完了しました"
};

const errorResult: Result<string> = {
    success: false,
    error: "エラーが発生しました"
};

handleResult(successResult); // 成功: 処理が完了しました
handleResult(errorResult);   // エラー: エラーが発生しました

// 実践例6: Union型と配列
type MixedArray = (string | number | boolean)[];

const mixed: MixedArray = ["hello", 42, true, "world", 100];

mixed.forEach((item): void => {
    if (typeof item === "string") {
        console.log(`文字列: ${item}`);
    } else if (typeof item === "number") {
        console.log(`数値: ${item}`);
    } else {
        console.log(`真偽値: ${item}`);
    }
});

// 実践例7: Union型の型推論
function getValue(): string | number {
    return Math.random() > 0.5 ? "文字列" : 42;
}

const value = getValue(); // string | number型

if (typeof value === "string") {
    console.log(`文字列の長さ: ${value.length}`);
} else {
    console.log(`数値の2倍: ${value * 2}`);
}
```

---

## Literal型

### Literal型とは
Literal型は、**特定の値のみを受け入れる**型です。文字列リテラル型、数値リテラル型、真偽値リテラル型があります。

### Literal型の基本構文

```typescript
type 型名 = "値1" | "値2" | "値3";
type 型名 = 1 | 2 | 3;
type 型名 = true | false;
```

### Literal型の特徴
- **特定の値のみ**: 指定した値のみを受け入れる
- **型の厳密性**: より厳密な型チェックが可能
- **定数の定義**: 定数のような動作をする

### 基本的なLiteral型

```typescript
type Status = "pending" | "approved" | "rejected";
type Direction = "up" | "down" | "left" | "right";
type Dice = 1 | 2 | 3 | 4 | 5 | 6;
```

### 実践例: Literal型

```typescript
// src/literal-type.ts
// 文字列リテラル型
type Status = "pending" | "approved" | "rejected";
type Color = "red" | "green" | "blue";

function setStatus(status: Status): void {
    console.log(`ステータスを設定: ${status}`);
}

setStatus("pending");   // OK
setStatus("approved");  // OK
// setStatus("invalid"); // エラー: "invalid"はStatus型に含まれない

// 実践例1: 数値リテラル型
type Dice = 1 | 2 | 3 | 4 | 5 | 6;
type HTTPStatus = 200 | 404 | 500;

function rollDice(): Dice {
    return Math.floor(Math.random() * 6) + 1 as Dice;
}

function handleHTTPStatus(status: HTTPStatus): void {
    switch (status) {
        case 200:
            console.log("成功");
            break;
        case 404:
            console.log("見つかりません");
            break;
        case 500:
            console.log("サーバーエラー");
            break;
    }
}

const dice: Dice = rollDice();
console.log(`サイコロ: ${dice}`);

handleHTTPStatus(200); // 成功
handleHTTPStatus(404); // 見つかりません

// 実践例2: 真偽値リテラル型
type TrueOnly = true;
type FalseOnly = false;

function processFlag(flag: true): void {
    console.log("フラグはtrueです");
}

processFlag(true);  // OK
// processFlag(false); // エラー: falseは受け入れられない

// 実践例3: 複数のLiteral型の組み合わせ
type Theme = "light" | "dark";
type Language = "ja" | "en" | "zh";

type UserPreference = {
    theme: Theme;
    language: Language;
};

const preference: UserPreference = {
    theme: "dark",
    language: "ja"
};

console.log(`テーマ: ${preference.theme}, 言語: ${preference.language}`);

// 実践例4: Literal型とUnion型の組み合わせ
type EventType = "click" | "submit" | "change";
type EventTarget = "button" | "form" | "input";

type Event = {
    type: EventType;
    target: EventTarget;
    timestamp: number;
};

function handleEvent(event: Event): void {
    console.log(`${event.type}イベントが${event.target}で発生しました`);
}

const clickEvent: Event = {
    type: "click",
    target: "button",
    timestamp: Date.now()
};

handleEvent(clickEvent);

// 実践例5: constアサーションとLiteral型
const status = "pending" as const; // "pending"型（文字列型ではない）
const numbers = [1, 2, 3] as const; // readonly [1, 2, 3]型

// 実践例6: 関数の戻り値としてLiteral型
function getStatus(): "success" | "error" {
    return Math.random() > 0.5 ? "success" : "error";
}

const result = getStatus(); // "success" | "error"型
console.log(`結果: ${result}`);

// 実践例7: オブジェクトのプロパティとしてLiteral型
type Action = {
    type: "ADD" | "DELETE" | "UPDATE";
    payload: unknown;
};

function dispatch(action: Action): void {
    switch (action.type) {
        case "ADD":
            console.log("追加アクション");
            break;
        case "DELETE":
            console.log("削除アクション");
            break;
        case "UPDATE":
            console.log("更新アクション");
            break;
    }
}

dispatch({ type: "ADD", payload: {} });
dispatch({ type: "DELETE", payload: {} });

// 実践例8: 型エイリアスとLiteral型
type Direction = "north" | "south" | "east" | "west";

function move(direction: Direction): void {
    console.log(`${direction}に移動しました`);
}

move("north"); // OK
move("south"); // OK
// move("northeast"); // エラー

// 実践例9: Literal型の配列
type StatusList = ("pending" | "approved" | "rejected")[];

const statuses: StatusList = ["pending", "approved", "rejected"];
console.log("ステータスリスト:", statuses);

// 実践例10: 複雑なLiteral型の組み合わせ
type Method = "GET" | "POST" | "PUT" | "DELETE";
type Protocol = "http" | "https";

type APIRequest = {
    method: Method;
    protocol: Protocol;
    url: string;
};

function makeRequest(request: APIRequest): void {
    console.log(`${request.method} ${request.protocol}://${request.url}`);
}

makeRequest({
    method: "GET",
    protocol: "https",
    url: "api.example.com/users"
});
```

---

## asキーワードによる型アサーション

### 型アサーションとは
型アサーションは、**TypeScriptに型を明示的に伝える**機能です。`as`キーワードを使用します。

### 型アサーションの基本構文

```typescript
const 変数 = 値 as 型;
// または
const 変数 = <型>値;
```

### 型アサーションの特徴
- **型の明示**: TypeScriptに型を伝える
- **注意が必要**: 間違った型アサーションは実行時エラーの原因になる
- **型の変換**: 型を変換する際に使用

### 基本的な型アサーション

```typescript
const value = "123" as string;
const number = "123" as unknown as number; // 二重アサーション
```

### 実践例: 型アサーション

```typescript
// src/type-assertion.ts
// 基本的な型アサーション
const value: unknown = "hello";
const str = value as string;

console.log(`文字列: ${str.toUpperCase()}`); // HELLO

// 実践例1: DOM要素の型アサーション
const element = document.getElementById("myElement") as HTMLInputElement;
if (element) {
    element.value = "新しい値";
    console.log(`値: ${element.value}`);
}

// 実践例2: オブジェクトの型アサーション
const data = {
    name: "太郎",
    age: 25
} as {
    name: string;
    age: number;
    email?: string;
};

console.log(`名前: ${data.name}, 年齢: ${data.age}`);

// 実践例3: 配列の型アサーション
const mixed = [1, "hello", true] as unknown;
const numbers = mixed as number[];

// 注意: 実行時エラーが発生する可能性がある
// console.log(numbers[0] * 2); // 実行時エラーの可能性

// 実践例4: 関数の型アサーション
type Calculator = (a: number, b: number) => number;

const add = ((a: number, b: number): number => a + b) as Calculator;
console.log(`5 + 3 = ${add(5, 3)}`); // 8

// 実践例5: 二重アサーション
const value1: string = "123";
const number1 = value1 as unknown as number; // 二重アサーション

// 注意: これは危険な操作です
// console.log(number1 * 2); // 実行時エラーの可能性

// 実践例6: constアサーション
const status = "pending" as const; // "pending"型
const numbers2 = [1, 2, 3] as const; // readonly [1, 2, 3]型

// status = "approved"; // エラー: 変更できない
// numbers2.push(4);    // エラー: 変更できない

// 実践例7: 型アサーションと型ガードの組み合わせ
function isString(value: unknown): value is string {
    return typeof value === "string";
}

const unknownValue: unknown = "hello";

if (isString(unknownValue)) {
    // このブロック内ではunknownValueはstring型
    console.log(`文字列の長さ: ${unknownValue.length}`);
}

// 実践例8: JSONパース時の型アサーション
type User = {
    id: number;
    name: string;
    email: string;
};

const jsonString = '{"id": 1, "name": "太郎", "email": "taro@example.com"}';
const user = JSON.parse(jsonString) as User;

console.log(`ユーザー: ${user.name} (${user.email})`);

// 実践例9: 型アサーションの注意点
// 間違った型アサーションは実行時エラーの原因になる
const wrong = "hello" as number;
// console.log(wrong * 2); // 実行時エラー: 文字列に数値演算はできない

// 実践例10: 型アサーションの適切な使用
interface ApiResponse {
    data: unknown;
    status: number;
}

function handleResponse(response: ApiResponse): void {
    // 型ガードと組み合わせて安全に使用
    if (typeof response.data === "object" && response.data !== null) {
        const data = response.data as { message: string };
        if ("message" in data) {
            console.log(`メッセージ: ${data.message}`);
        }
    }
}

const response: ApiResponse = {
    data: { message: "成功しました" },
    status: 200
};

handleResponse(response);
```

---

## 型ガード（Type Guard）による安全な型チェック

### 型ガードとは
型ガードは、**実行時に型をチェックし、TypeScriptに型を伝える**機能です。

### 型ガードの基本構文

```typescript
function isType(value: unknown): value is Type {
    // 型チェックのロジック
    return ...;
}
```

### 型ガードの特徴
- **型の絞り込み**: 条件分岐で型を絞り込む
- **型安全性**: 実行時の型チェックで安全性を確保
- **型推論**: TypeScriptが自動的に型を推論する

### 基本的な型ガード

```typescript
function isString(value: unknown): value is string {
    return typeof value === "string";
}
```

### 実践例: 型ガード

```typescript
// src/type-guard.ts
// 基本的な型ガード
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function isNumber(value: unknown): value is number {
    return typeof value === "number";
}

function isBoolean(value: unknown): value is boolean {
    return typeof value === "boolean";
}

function processValue(value: unknown): void {
    if (isString(value)) {
        // このブロック内ではvalueはstring型
        console.log(`文字列: ${value.toUpperCase()}`);
    } else if (isNumber(value)) {
        // このブロック内ではvalueはnumber型
        console.log(`数値: ${value * 2}`);
    } else if (isBoolean(value)) {
        // このブロック内ではvalueはboolean型
        console.log(`真偽値: ${value}`);
    } else {
        console.log("不明な型");
    }
}

processValue("hello");  // 文字列: HELLO
processValue(10);       // 数値: 20
processValue(true);     // 真偽値: true

// 実践例1: オブジェクトの型ガード
interface Person {
    name: string;
    age: number;
}

function isPerson(value: unknown): value is Person {
    return (
        typeof value === "object" &&
        value !== null &&
        "name" in value &&
        "age" in value &&
        typeof (value as Person).name === "string" &&
        typeof (value as Person).age === "number"
    );
}

function greet(value: unknown): void {
    if (isPerson(value)) {
        // このブロック内ではvalueはPerson型
        console.log(`こんにちは、${value.name}さん（${value.age}歳）`);
    } else {
        console.log("Person型ではありません");
    }
}

greet({ name: "太郎", age: 25 }); // こんにちは、太郎さん（25歳）
greet("文字列");                   // Person型ではありません

// 実践例2: 配列の型ガード
function isStringArray(value: unknown): value is string[] {
    return (
        Array.isArray(value) &&
        value.every((item) => typeof item === "string")
    );
}

function processArray(value: unknown): void {
    if (isStringArray(value)) {
        // このブロック内ではvalueはstring[]型
        console.log(`文字列配列: ${value.join(", ")}`);
    } else {
        console.log("文字列配列ではありません");
    }
}

processArray(["a", "b", "c"]);     // 文字列配列: a, b, c
processArray([1, 2, 3]);           // 文字列配列ではありません

// 実践例3: Union型の型ガード
type Circle = {
    kind: "circle";
    radius: number;
};

type Rectangle = {
    kind: "rectangle";
    width: number;
    height: number;
};

type Shape = Circle | Rectangle;

function isCircle(shape: Shape): shape is Circle {
    return shape.kind === "circle";
}

function getArea(shape: Shape): number {
    if (isCircle(shape)) {
        // このブロック内ではshapeはCircle型
        return Math.PI * shape.radius * shape.radius;
    } else {
        // このブロック内ではshapeはRectangle型
        return shape.width * shape.height;
    }
}

const circle: Shape = { kind: "circle", radius: 5 };
const rectangle: Shape = { kind: "rectangle", width: 10, height: 20 };

console.log(`円の面積: ${getArea(circle).toFixed(2)}`);        // 78.54
console.log(`矩形の面積: ${getArea(rectangle)}`);             // 200

// 実践例4: インスタンスの型ガード
class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
}

class Dog extends Animal {
    breed: string;
    
    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }
}

function isDog(animal: Animal): animal is Dog {
    return animal instanceof Dog;
}

function describe(animal: Animal): void {
    if (isDog(animal)) {
        // このブロック内ではanimalはDog型
        console.log(`${animal.name}は${animal.breed}です`);
    } else {
        console.log(`${animal.name}は動物です`);
    }
}

const dog = new Dog("ポチ", "柴犬");
const animal = new Animal("動物");

describe(dog);     // ポチは柴犬です
describe(animal);  // 動物は動物です

// 実践例5: 複雑な型ガード
type Success<T> = {
    success: true;
    data: T;
};

type Error = {
    success: false;
    error: string;
};

type Result<T> = Success<T> | Error;

function isSuccess<T>(result: Result<T>): result is Success<T> {
    return result.success === true;
}

function handleResult<T>(result: Result<T>): void {
    if (isSuccess(result)) {
        // このブロック内ではresultはSuccess<T>型
        console.log(`成功: ${result.data}`);
    } else {
        // このブロック内ではresultはError型
        console.log(`エラー: ${result.error}`);
    }
}

const success: Result<string> = {
    success: true,
    data: "処理が完了しました"
};

const error: Result<string> = {
    success: false,
    error: "エラーが発生しました"
};

handleResult(success); // 成功: 処理が完了しました
handleResult(error);   // エラー: エラーが発生しました

// 実践例6: 型ガードの組み合わせ
function isNullOrString(value: unknown): value is null | string {
    return value === null || typeof value === "string";
}

function processNullableString(value: unknown): void {
    if (isNullOrString(value)) {
        if (value === null) {
            console.log("値はnullです");
        } else {
            // このブロック内ではvalueはstring型
            console.log(`文字列: ${value.toUpperCase()}`);
        }
    } else {
        console.log("文字列またはnullではありません");
    }
}

processNullableString("hello"); // 文字列: HELLO
processNullableString(null);    // 値はnullです
processNullableString(123);     // 文字列またはnullではありません

// 実践例7: カスタム型ガード
interface Admin {
    role: "admin";
    permissions: string[];
}

interface User {
    role: "user";
}

type Account = Admin | User;

function isAdmin(account: Account): account is Admin {
    return account.role === "admin";
}

function checkPermission(account: Account, permission: string): boolean {
    if (isAdmin(account)) {
        // このブロック内ではaccountはAdmin型
        return account.permissions.includes(permission);
    }
    return false;
}

const admin: Account = {
    role: "admin",
    permissions: ["read", "write", "delete"]
};

const user: Account = {
    role: "user"
};

console.log(`管理者のread権限: ${checkPermission(admin, "read")}`); // true
console.log(`ユーザーのread権限: ${checkPermission(user, "read")}`); // false
```

---

## まとめ

この章では、TypeScriptの高度な型システムについて学びました。

### 学んだこと
- Union型: 複数の型のいずれかを受け入れる
- Literal型: 特定の値のみを受け入れる
- 型アサーション: TypeScriptに型を明示的に伝える
- 型ガード: 実行時に型をチェックし、型を絞り込む

### 重要なポイント
1. **Union型**: `|`演算子で複数の型を組み合わせる
2. **Literal型**: 特定の値のみを受け入れる型
3. **型アサーション**: `as`キーワードで型を明示する（注意が必要）
4. **型ガード**: 実行時の型チェックで安全性を確保

### 次のステップ
次の章では、ジェネリクスについて詳しく学びます。

---

## 演習問題

### 問題1: Union型
文字列または数値を受け取り、文字列の場合は大文字に、数値の場合は2倍にして表示する関数を作成してください。

<details>
<summary>解答例</summary>

```typescript
type StringOrNumber = string | number;

function process(value: StringOrNumber): void {
    if (typeof value === "string") {
        console.log(value.toUpperCase());
    } else {
        console.log(value * 2);
    }
}

process("hello"); // HELLO
process(10);      // 20
```
</details>

### 問題2: Literal型
"pending"、"approved"、"rejected"のいずれかの値を受け取る`Status`型を定義してください。

<details>
<summary>解答例</summary>

```typescript
type Status = "pending" | "approved" | "rejected";

function setStatus(status: Status): void {
    console.log(`ステータス: ${status}`);
}

setStatus("pending");  // OK
setStatus("approved"); // OK
```
</details>

### 問題3: 型アサーション
`unknown`型の値を`string`型として扱い、大文字に変換してください。

<details>
<summary>解答例</summary>

```typescript
const value: unknown = "hello";
const str = value as string;

console.log(str.toUpperCase()); // HELLO
```
</details>

### 問題4: 型ガード
`unknown`型の値が`string`型かどうかをチェックする型ガード関数を作成してください。

<details>
<summary>解答例</summary>

```typescript
function isString(value: unknown): value is string {
    return typeof value === "string";
}

function process(value: unknown): void {
    if (isString(value)) {
        console.log(`文字列: ${value.toUpperCase()}`);
    } else {
        console.log("文字列ではありません");
    }
}

process("hello"); // 文字列: HELLO
process(123);     // 文字列ではありません
```
</details>

### 問題5: Union型と型ガード
`Circle`と`Rectangle`のUnion型を作成し、型ガードを使って面積を計算してください。

<details>
<summary>解答例</summary>

```typescript
type Circle = {
    kind: "circle";
    radius: number;
};

type Rectangle = {
    kind: "rectangle";
    width: number;
    height: number;
};

type Shape = Circle | Rectangle;

function isCircle(shape: Shape): shape is Circle {
    return shape.kind === "circle";
}

function getArea(shape: Shape): number {
    if (isCircle(shape)) {
        return Math.PI * shape.radius * shape.radius;
    } else {
        return shape.width * shape.height;
    }
}

const circle: Shape = { kind: "circle", radius: 5 };
console.log(`円の面積: ${getArea(circle).toFixed(2)}`); // 78.54
```
</details>

---

お疲れ様でした！次の章に進みましょう。

