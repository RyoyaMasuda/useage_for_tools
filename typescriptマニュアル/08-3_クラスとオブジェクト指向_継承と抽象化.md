# 8-3. クラスとオブジェクト指向（継承と抽象化）

この章では、クラスの継承と抽象化について学びます。継承を理解することで、コードの再利用性を高め、より効率的にプログラムを作成できるようになります。また、抽象クラスやインターフェースの実装により、柔軟で拡張しやすいコードを書けるようになります。

---

## 目次

- [クラスの継承（extends）](#クラスの継承extends)
- [メソッドのオーバーライド](#メソッドのオーバーライド)
- [コンストラクタのオーバーライド](#コンストラクタのオーバーライド)
- [抽象クラス（abstract class）の概念と活用](#抽象クラスabstract-classの概念と活用)
- [implements キーワードと使用場面](#implements-キーワードと使用場面)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## クラスの継承（extends）

### 継承とは
継承は、**既存のクラスの機能を引き継いで、新しいクラスを作成する**仕組みです。親クラス（スーパークラス）の機能を子クラス（サブクラス）が受け継ぎ、追加や変更を加えることができます。

### 日常生活での例
- **車の種類**: 自動車という基本クラスから、乗用車、トラック、バスなどが継承される
- **動物の分類**: 動物という基本クラスから、哺乳類、鳥類、魚類などが継承される
- **家電製品**: 家電という基本クラスから、テレビ、冷蔵庫、洗濯機などが継承される

### プログラミングでの例

```typescript
// 親クラス（基底クラス）
class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    speak(): void {
        console.log(`${this.name}が鳴いています`);
    }
}

// 子クラス（派生クラス）
class Dog extends Animal {
    // Animalクラスの機能を継承
}

const dog = new Dog("ポチ");
dog.speak(); // "ポチが鳴いています"
```

### 継承の基本構文

```typescript
// 親クラス
class 親クラス名 {
    // プロパティとメソッド
}

// 子クラス
class 子クラス名 extends 親クラス名 {
    // 追加のプロパティとメソッド
    // 親クラスの機能をすべて使用可能
}
```

### 継承のメリット
1. **コードの再利用**: 親クラスの機能をそのまま使える
2. **コードの整理**: 共通の機能を親クラスにまとめられる
3. **保守性の向上**: 親クラスを修正すれば、すべての子クラスに反映される
4. **拡張性**: 子クラスで新しい機能を追加できる

### 実践例: クラスの継承

```typescript
// src/class-inheritance.ts
// 親クラス: 動物
class Animal {
    name: string;
    age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    
    speak(): void {
        console.log(`${this.name}が鳴いています`);
    }
    
    move(): void {
        console.log(`${this.name}が動いています`);
    }
    
    getInfo(): string {
        return `名前: ${this.name}, 年齢: ${this.age}`;
    }
}

// 子クラス: 犬（Animalを継承）
class Dog extends Animal {
    breed: string;  // 犬特有のプロパティ
    
    constructor(name: string, age: number, breed: string) {
        super(name, age);  // 親クラスのコンストラクタを呼び出す
        this.breed = breed;
    }
    
    // 親クラスのメソッドを使用可能
    // speak(), move(), getInfo() が使える
}

// 子クラス: 猫（Animalを継承）
class Cat extends Animal {
    color: string;  // 猫特有のプロパティ
    
    constructor(name: string, age: number, color: string) {
        super(name, age);
        this.color = color;
    }
}

// 使用例
const dog = new Dog("ポチ", 3, "柴犬");
dog.speak();        // "ポチが鳴いています"（親クラスのメソッド）
dog.move();         // "ポチが動いています"（親クラスのメソッド）
console.log(dog.getInfo());  // "名前: ポチ, 年齢: 3"（親クラスのメソッド）
console.log(dog.breed);      // "柴犬"（子クラスのプロパティ）

const cat = new Cat("タマ", 2, "白");
cat.speak();        // "タマが鳴いています"
console.log(cat.color);      // "白"
```

### superキーワード

```typescript
// src/super-keyword.ts
// superキーワードで親クラスにアクセス
class Vehicle {
    brand: string;
    year: number;
    
    constructor(brand: string, year: number) {
        this.brand = brand;
        this.year = year;
    }
    
    start(): void {
        console.log(`${this.brand}がエンジンを始動しました`);
    }
    
    getInfo(): string {
        return `${this.brand} (${this.year}年式)`;
    }
}

class Car extends Vehicle {
    model: string;
    
    constructor(brand: string, year: number, model: string) {
        super(brand, year);  // 親クラスのコンストラクタを呼び出す
        this.model = model;
    }
    
    // 親クラスのメソッドを呼び出す
    displayInfo(): void {
        console.log(super.getInfo());  // 親クラスのメソッドを呼び出し
        console.log(`モデル: ${this.model}`);
    }
}

const car = new Car("トヨタ", 2023, "プリウス");
car.start();        // "トヨタがエンジンを始動しました"
car.displayInfo();  // 親クラスのgetInfo()と子クラスの情報を表示
```

### 継承チェーン

```typescript
// src/inheritance-chain.ts
// 複数レベルの継承
class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    eat(): void {
        console.log(`${this.name}が食べています`);
    }
}

class Mammal extends Animal {
    // Animalを継承
    giveBirth(): void {
        console.log(`${this.name}が子を産みました`);
    }
}

class Dog extends Mammal {
    // Mammalを継承（間接的にAnimalも継承）
    breed: string;
    
    constructor(name: string, breed: string) {
        super(name);
        this.breed = breed;
    }
    
    bark(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
}

const dog = new Dog("ポチ", "柴犬");
dog.eat();        // Animalクラスのメソッド
dog.giveBirth();  // Mammalクラスのメソッド
dog.bark();       // Dogクラスのメソッド
```

---

## メソッドのオーバーライド

### オーバーライドとは
オーバーライドは、**親クラスのメソッドを子クラスで再定義する**ことです。親クラスのメソッドと同じ名前のメソッドを子クラスで定義することで、親クラスの動作を変更できます。

### オーバーライドの基本構文

```typescript
// 親クラス
class 親クラス名 {
    methodName(): void {
        // 親クラスの実装
    }
}

// 子クラス
class 子クラス名 extends 親クラス名 {
    methodName(): void {
        // 子クラスでの実装（親クラスのメソッドを上書き）
    }
}
```

### 実践例: メソッドのオーバーライド

```typescript
// src/method-override.ts
// 親クラス
class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    speak(): void {
        console.log(`${this.name}が鳴いています`);
    }
    
    move(): void {
        console.log(`${this.name}が動いています`);
    }
}

// 子クラス: 犬（speakメソッドをオーバーライド）
class Dog extends Animal {
    speak(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
}

// 子クラス: 猫（speakメソッドをオーバーライド）
class Cat extends Animal {
    speak(): void {
        console.log(`${this.name}がニャーニャーと鳴いています`);
    }
}

// 子クラス: 鳥（speakとmoveメソッドをオーバーライド）
class Bird extends Animal {
    speak(): void {
        console.log(`${this.name}がチュンチュンと鳴いています`);
    }
    
    move(): void {
        console.log(`${this.name}が飛んでいます`);
    }
}

// 使用例
const dog = new Dog("ポチ");
dog.speak();  // "ポチがワンワンと鳴いています"（オーバーライドされたメソッド）
dog.move();   // "ポチが動いています"（親クラスのメソッド）

const cat = new Cat("タマ");
cat.speak();  // "タマがニャーニャーと鳴いています"

const bird = new Bird("ピヨ");
bird.speak(); // "ピヨがチュンチュンと鳴いています"
bird.move();  // "ピヨが飛んでいます"（オーバーライドされたメソッド）
```

### superを使ったオーバーライド

```typescript
// src/super-override.ts
// 親クラスのメソッドを呼び出しながら拡張
class Vehicle {
    brand: string;
    
    constructor(brand: string) {
        this.brand = brand;
    }
    
    start(): void {
        console.log(`${this.brand}がエンジンを始動しました`);
    }
    
    stop(): void {
        console.log(`${this.brand}が停止しました`);
    }
}

class Car extends Vehicle {
    model: string;
    
    constructor(brand: string, model: string) {
        super(brand);
        this.model = model;
    }
    
    // 親クラスのメソッドを呼び出しながら拡張
    start(): void {
        super.start();  // 親クラスのstart()を呼び出す
        console.log(`${this.model}のエアコンをオンにしました`);
    }
    
    // 完全に上書き
    stop(): void {
        console.log(`${this.brand} ${this.model}が安全に停止しました`);
    }
}

const car = new Car("トヨタ", "プリウス");
car.start();
// "トヨタがエンジンを始動しました"（親クラスのメソッド）
// "プリウスのエアコンをオンにしました"（子クラスの追加処理）

car.stop();
// "トヨタ プリウスが安全に停止しました"（完全に上書き）
```

### 実践例: 図形クラス

```typescript
// src/shape-override.ts
// 図形の親クラス
class Shape {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    getArea(): number {
        return 0;  // デフォルト実装
    }
    
    displayInfo(): void {
        console.log(`${this.name}の面積: ${this.getArea()}`);
    }
}

// 長方形クラス
class Rectangle extends Shape {
    width: number;
    height: number;
    
    constructor(width: number, height: number) {
        super("長方形");
        this.width = width;
        this.height = height;
    }
    
    // getAreaメソッドをオーバーライド
    getArea(): number {
        return this.width * this.height;
    }
}

// 円クラス
class Circle extends Shape {
    radius: number;
    
    constructor(radius: number) {
        super("円");
        this.radius = radius;
    }
    
    // getAreaメソッドをオーバーライド
    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

// 使用例
const rect = new Rectangle(10, 5);
rect.displayInfo();  // "長方形の面積: 50"

const circle = new Circle(5);
circle.displayInfo();  // "円の面積: 78.53981633974483"
```

---

## コンストラクタのオーバーライド

### コンストラクタのオーバーライドとは
子クラスでコンストラクタを定義する場合、**必ず`super()`を呼び出して親クラスのコンストラクタを実行する**必要があります。

### コンストラクタのオーバーライドの基本構文

```typescript
// 親クラス
class 親クラス名 {
    constructor(引数1: 型1, 引数2: 型2) {
        // 親クラスの初期化処理
    }
}

// 子クラス
class 子クラス名 extends 親クラス名 {
    constructor(引数1: 型1, 引数2: 型2, 引数3: 型3) {
        super(引数1, 引数2);  // 親クラスのコンストラクタを呼び出す（必須）
        // 子クラスの初期化処理
    }
}
```

### 実践例: コンストラクタのオーバーライド

```typescript
// src/constructor-override.ts
// 親クラス
class Person {
    name: string;
    age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
        console.log(`Personコンストラクタ: ${name}が作成されました`);
    }
    
    introduce(): void {
        console.log(`私は${this.name}、${this.age}歳です`);
    }
}

// 子クラス: 学生
class Student extends Person {
    studentId: string;
    school: string;
    
    constructor(name: string, age: number, studentId: string, school: string) {
        super(name, age);  // 親クラスのコンストラクタを呼び出す（必須）
        this.studentId = studentId;
        this.school = school;
        console.log(`Studentコンストラクタ: 学生ID ${studentId}が設定されました`);
    }
    
    introduce(): void {
        super.introduce();  // 親クラスのメソッドを呼び出す
        console.log(`学生ID: ${this.studentId}, 学校: ${this.school}`);
    }
}

// 子クラス: 従業員
class Employee extends Person {
    employeeId: string;
    department: string;
    
    constructor(
        name: string,
        age: number,
        employeeId: string,
        department: string
    ) {
        super(name, age);  // 親クラスのコンストラクタを呼び出す
        this.employeeId = employeeId;
        this.department = department;
    }
    
    introduce(): void {
        super.introduce();
        console.log(`従業員ID: ${this.employeeId}, 部署: ${this.department}`);
    }
}

// 使用例
const student = new Student("太郎", 20, "S001", "東京大学");
// "Personコンストラクタ: 太郎が作成されました"
// "Studentコンストラクタ: 学生ID S001が設定されました"

student.introduce();
// "私は太郎、20歳です"
// "学生ID: S001, 学校: 東京大学"

const employee = new Employee("花子", 30, "E001", "営業部");
employee.introduce();
// "私は花子、30歳です"
// "従業員ID: E001, 部署: 営業部"
```

### super()の呼び出しタイミング

```typescript
// src/super-timing.ts
// super()は必ず最初に呼び出す必要がある
class Base {
    value: number;
    
    constructor(value: number) {
        this.value = value;
    }
}

class Derived extends Base {
    multiplier: number;
    
    constructor(value: number, multiplier: number) {
        // エラー: super()を呼び出す前にthisにアクセスできない
        // this.multiplier = multiplier;  // エラー
        
        super(value);  // 最初にsuper()を呼び出す
        this.multiplier = multiplier;  // OK: super()の後にアクセス可能
    }
    
    calculate(): number {
        return this.value * this.multiplier;
    }
}

const derived = new Derived(10, 5);
console.log(derived.calculate());  // 50
```

### 実践例: 車の継承

```typescript
// src/car-inheritance.ts
// 車の基本クラス
class Vehicle {
    brand: string;
    year: number;
    speed: number;
    
    constructor(brand: string, year: number) {
        this.brand = brand;
        this.year = year;
        this.speed = 0;
    }
    
    accelerate(amount: number): void {
        this.speed += amount;
        console.log(`${this.brand}の速度が${this.speed}km/hになりました`);
    }
    
    brake(amount: number): void {
        this.speed = Math.max(0, this.speed - amount);
        console.log(`${this.brand}の速度が${this.speed}km/hになりました`);
    }
}

// 乗用車クラス
class Car extends Vehicle {
    model: string;
    fuelType: string;
    
    constructor(brand: string, year: number, model: string, fuelType: string) {
        super(brand, year);  // 親クラスのコンストラクタを呼び出す
        this.model = model;
        this.fuelType = fuelType;
    }
    
    getInfo(): string {
        return `${this.brand} ${this.model} (${this.year}年式, ${this.fuelType})`;
    }
}

// トラッククラス
class Truck extends Vehicle {
    loadCapacity: number;  // 積載量（トン）
    
    constructor(brand: string, year: number, loadCapacity: number) {
        super(brand, year);
        this.loadCapacity = loadCapacity;
    }
    
    load(weight: number): void {
        if (weight <= this.loadCapacity) {
            console.log(`${weight}トンの荷物を積み込みました`);
        } else {
            console.log(`積載量を超えています（最大${this.loadCapacity}トン）`);
        }
    }
}

// 使用例
const car = new Car("トヨタ", 2023, "プリウス", "ハイブリッド");
console.log(car.getInfo());  // "トヨタ プリウス (2023年式, ハイブリッド)"
car.accelerate(50);          // "トヨタの速度が50km/hになりました"

const truck = new Truck("いすゞ", 2022, 5);
truck.load(3);               // "3トンの荷物を積み込みました"
truck.load(6);               // "積載量を超えています（最大5トン）"
```

---

## 抽象クラス（abstract class）の概念と活用

### 抽象クラスとは
抽象クラスは、**インスタンス化できないクラス**で、継承されることを前提に設計されます。抽象メソッド（実装がないメソッド）を含むことができ、子クラスで実装を強制できます。

### 抽象クラスの基本構文

```typescript
// 抽象クラス
abstract class 抽象クラス名 {
    // 通常のプロパティとメソッド
    プロパティ名: 型;
    
    // 抽象メソッド（実装がない）
    abstract メソッド名(): 戻り値の型;
    
    // 通常のメソッド（実装がある）
    メソッド名(): void {
        // 実装
    }
}

// 具象クラス（抽象クラスを継承）
class 具象クラス名 extends 抽象クラス名 {
    // 抽象メソッドを実装する必要がある
    メソッド名(): 戻り値の型 {
        // 実装
    }
}
```

### 抽象クラスの特徴
1. **インスタンス化不可**: `new`で直接インスタンスを作成できない
2. **抽象メソッド**: 実装がないメソッドを定義できる
3. **継承前提**: 子クラスで実装されることを前提に設計される
4. **共通機能の提供**: 抽象クラスで共通の機能を実装できる

### 実践例: 抽象クラス

```typescript
// src/abstract-class.ts
// 抽象クラス: 動物
abstract class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    // 抽象メソッド（子クラスで実装必須）
    abstract speak(): void;
    
    // 抽象メソッド（子クラスで実装必須）
    abstract move(): void;
    
    // 通常のメソッド（共通の実装）
    eat(): void {
        console.log(`${this.name}が食べています`);
    }
    
    sleep(): void {
        console.log(`${this.name}が眠っています`);
    }
}

// 具象クラス: 犬（抽象メソッドを実装）
class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    
    // 抽象メソッドの実装（必須）
    speak(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
    
    // 抽象メソッドの実装（必須）
    move(): void {
        console.log(`${this.name}が走っています`);
    }
}

// 具象クラス: 猫（抽象メソッドを実装）
class Cat extends Animal {
    constructor(name: string) {
        super(name);
    }
    
    speak(): void {
        console.log(`${this.name}がニャーニャーと鳴いています`);
    }
    
    move(): void {
        console.log(`${this.name}が歩いています`);
    }
}

// 使用例
const dog = new Dog("ポチ");
dog.speak();  // "ポチがワンワンと鳴いています"
dog.move();   // "ポチが走っています"
dog.eat();    // "ポチが食べています"（親クラスのメソッド）

const cat = new Cat("タマ");
cat.speak();  // "タマがニャーニャーと鳴いています"
cat.move();   // "タマが歩いています"

// エラー: 抽象クラスはインスタンス化できない
// const animal = new Animal("動物");  // エラー
```

### 実践例: 図形の抽象クラス

```typescript
// src/abstract-shape.ts
// 抽象クラス: 図形
abstract class Shape {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    // 抽象メソッド: 面積を計算（子クラスで実装必須）
    abstract getArea(): number;
    
    // 抽象メソッド: 周囲の長さを計算（子クラスで実装必須）
    abstract getPerimeter(): number;
    
    // 通常のメソッド（共通の実装）
    displayInfo(): void {
        console.log(`${this.name}`);
        console.log(`面積: ${this.getArea()}`);
        console.log(`周囲の長さ: ${this.getPerimeter()}`);
    }
}

// 具象クラス: 長方形
class Rectangle extends Shape {
    width: number;
    height: number;
    
    constructor(width: number, height: number) {
        super("長方形");
        this.width = width;
        this.height = height;
    }
    
    // 抽象メソッドの実装
    getArea(): number {
        return this.width * this.height;
    }
    
    getPerimeter(): number {
        return 2 * (this.width + this.height);
    }
}

// 具象クラス: 円
class Circle extends Shape {
    radius: number;
    
    constructor(radius: number) {
        super("円");
        this.radius = radius;
    }
    
    // 抽象メソッドの実装
    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
    
    getPerimeter(): number {
        return 2 * Math.PI * this.radius;
    }
}

// 使用例
const rect = new Rectangle(10, 5);
rect.displayInfo();
// "長方形"
// "面積: 50"
// "周囲の長さ: 30"

const circle = new Circle(5);
circle.displayInfo();
// "円"
// "面積: 78.53981633974483"
// "周囲の長さ: 31.41592653589793"
```

### 抽象プロパティ

```typescript
// src/abstract-property.ts
// 抽象プロパティを含む抽象クラス
abstract class Database {
    // 抽象プロパティ（子クラスで実装必須）
    abstract connectionString: string;
    
    // 通常のメソッド
    connect(): void {
        console.log(`${this.connectionString}に接続しました`);
    }
    
    // 抽象メソッド
    abstract query(sql: string): void;
}

// 具象クラス: MySQLデータベース
class MySQLDatabase extends Database {
    connectionString: string;  // 抽象プロパティの実装
    
    constructor(host: string, port: number, database: string) {
        super();
        this.connectionString = `mysql://${host}:${port}/${database}`;
    }
    
    query(sql: string): void {
        console.log(`MySQL: ${sql}を実行しました`);
    }
}

// 具象クラス: PostgreSQLデータベース
class PostgreSQLDatabase extends Database {
    connectionString: string;  // 抽象プロパティの実装
    
    constructor(host: string, port: number, database: string) {
        super();
        this.connectionString = `postgresql://${host}:${port}/${database}`;
    }
    
    query(sql: string): void {
        console.log(`PostgreSQL: ${sql}を実行しました`);
    }
}

// 使用例
const mysql = new MySQLDatabase("localhost", 3306, "mydb");
mysql.connect();        // "mysql://localhost:3306/mydbに接続しました"
mysql.query("SELECT * FROM users");

const postgres = new PostgreSQLDatabase("localhost", 5432, "mydb");
postgres.connect();     // "postgresql://localhost:5432/mydbに接続しました"
postgres.query("SELECT * FROM users");
```

---

## implements キーワードと使用場面

### implementsとは
`implements`は、**クラスがインターフェースを実装する**ことを示すキーワードです。インターフェースで定義されたメソッドやプロパティを、クラスで実装することを保証します。

### implementsの基本構文

```typescript
// インターフェース
interface インターフェース名 {
    メソッド名(): 戻り値の型;
    プロパティ名: 型;
}

// クラスがインターフェースを実装
class クラス名 implements インターフェース名 {
    プロパティ名: 型;
    
    メソッド名(): 戻り値の型 {
        // 実装
    }
}
```

### implementsの特徴
1. **契約の保証**: インターフェースで定義されたメソッドを実装することを保証
2. **複数実装可能**: 複数のインターフェースを実装できる
3. **型安全性**: インターフェースに定義されていないメソッドは実装不要
4. **柔軟性**: クラスの継承とは独立して使用できる

### 実践例: implementsの基本

```typescript
// src/implements-basic.ts
// インターフェース: 飛べるもの
interface Flyable {
    fly(): void;
}

// インターフェース: 泳げるもの
interface Swimmable {
    swim(): void;
}

// クラス: 鳥（Flyableを実装）
class Bird implements Flyable {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    // インターフェースで定義されたメソッドを実装（必須）
    fly(): void {
        console.log(`${this.name}が飛んでいます`);
    }
}

// クラス: 魚（Swimmableを実装）
class Fish implements Swimmable {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    // インターフェースで定義されたメソッドを実装（必須）
    swim(): void {
        console.log(`${this.name}が泳いでいます`);
    }
}

// クラス: ペンギン（Swimmableを実装、Flyableは実装しない）
class Penguin implements Swimmable {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    swim(): void {
        console.log(`${this.name}が泳いでいます`);
    }
}

// 使用例
const bird = new Bird("スズメ");
bird.fly();  // "スズメが飛んでいます"

const fish = new Fish("マグロ");
fish.swim();  // "マグロが泳いでいます"

const penguin = new Penguin("ペンギン");
penguin.swim();  // "ペンギンが泳いでいます"
```

### 複数のインターフェースを実装

```typescript
// src/multiple-implements.ts
// インターフェース1: 動く
interface Movable {
    move(): void;
}

// インターフェース2: 鳴く
interface Speakable {
    speak(): void;
}

// インターフェース3: 食べる
interface Eatable {
    eat(): void;
}

// 複数のインターフェースを実装
class Dog implements Movable, Speakable, Eatable {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    // Movableインターフェースの実装
    move(): void {
        console.log(`${this.name}が走っています`);
    }
    
    // Speakableインターフェースの実装
    speak(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
    
    // Eatableインターフェースの実装
    eat(): void {
        console.log(`${this.name}が食べています`);
    }
}

// 使用例
const dog = new Dog("ポチ");
dog.move();   // "ポチが走っています"
dog.speak();  // "ポチがワンワンと鳴いています"
dog.eat();    // "ポチが食べています"
```

### 継承とimplementsの組み合わせ

```typescript
// src/extends-and-implements.ts
// 親クラス
class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    breathe(): void {
        console.log(`${this.name}が呼吸しています`);
    }
}

// インターフェース
interface Flyable {
    fly(): void;
}

interface Swimmable {
    swim(): void;
}

// 継承とimplementsを同時に使用
class Duck extends Animal implements Flyable, Swimmable {
    constructor(name: string) {
        super(name);
    }
    
    // インターフェースの実装
    fly(): void {
        console.log(`${this.name}が飛んでいます`);
    }
    
    swim(): void {
        console.log(`${this.name}が泳いでいます`);
    }
}

// 使用例
const duck = new Duck("アヒル");
duck.breathe();  // "アヒルが呼吸しています"（親クラスのメソッド）
duck.fly();      // "アヒルが飛んでいます"（インターフェースの実装）
duck.swim();     // "アヒルが泳いでいます"（インターフェースの実装）
```

### 実践例: ペイメントシステム

```typescript
// src/payment-system.ts
// インターフェース: 支払い方法
interface PaymentMethod {
    processPayment(amount: number): boolean;
    getPaymentInfo(): string;
}

// インターフェース: 返金可能
interface Refundable {
    refund(amount: number): boolean;
}

// クレジットカードクラス
class CreditCard implements PaymentMethod, Refundable {
    cardNumber: string;
    cardHolder: string;
    
    constructor(cardNumber: string, cardHolder: string) {
        this.cardNumber = cardNumber;
        this.cardHolder = cardHolder;
    }
    
    processPayment(amount: number): boolean {
        console.log(`クレジットカードで${amount}円を支払いました`);
        return true;
    }
    
    getPaymentInfo(): string {
        return `クレジットカード: ${this.cardHolder}`;
    }
    
    refund(amount: number): boolean {
        console.log(`クレジットカードで${amount}円を返金しました`);
        return true;
    }
}

// 現金クラス
class Cash implements PaymentMethod {
    processPayment(amount: number): boolean {
        console.log(`現金で${amount}円を支払いました`);
        return true;
    }
    
    getPaymentInfo(): string {
        return "現金";
    }
}

// 使用例
const creditCard = new CreditCard("1234-5678-9012-3456", "山田太郎");
creditCard.processPayment(1000);  // "クレジットカードで1000円を支払いました"
console.log(creditCard.getPaymentInfo());  // "クレジットカード: 山田太郎"
creditCard.refund(500);  // "クレジットカードで500円を返金しました"

const cash = new Cash();
cash.processPayment(500);  // "現金で500円を支払いました"
console.log(cash.getPaymentInfo());  // "現金"
```

### インターフェースと抽象クラスの違い

```typescript
// src/interface-vs-abstract.ts
// インターフェース: 契約のみ（実装なし）
interface Drawable {
    draw(): void;
}

// 抽象クラス: 実装と抽象メソッドの両方を含める
abstract class Shape {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    // 通常のメソッド（実装あり）
    getName(): string {
        return this.name;
    }
    
    // 抽象メソッド（実装なし）
    abstract getArea(): number;
}

// クラス: インターフェースと抽象クラスの両方を実装
class Circle extends Shape implements Drawable {
    radius: number;
    
    constructor(radius: number) {
        super("円");
        this.radius = radius;
    }
    
    // 抽象メソッドの実装
    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
    
    // インターフェースの実装
    draw(): void {
        console.log(`円を描画しました（半径: ${this.radius}）`);
    }
}

// 使用例
const circle = new Circle(5);
console.log(circle.getName());  // "円"（抽象クラスのメソッド）
console.log(circle.getArea());  // 78.53981633974483（抽象メソッドの実装）
circle.draw();                  // "円を描画しました（半径: 5）"（インターフェースの実装）
```

---

## まとめ

この章では、クラスの継承と抽象化について以下のことを学びました。

### クラスの継承（extends）
- 継承は、既存のクラスの機能を引き継いで新しいクラスを作成する仕組み
- `extends`キーワードで親クラスを継承できる
- `super`キーワードで親クラスにアクセスできる
- コードの再利用性と保守性が向上する

### メソッドのオーバーライド
- 親クラスのメソッドを子クラスで再定義できる
- 同じ名前のメソッドを定義することで、親クラスの動作を変更できる
- `super`を使って親クラスのメソッドを呼び出しながら拡張できる

### コンストラクタのオーバーライド
- 子クラスでコンストラクタを定義する場合、必ず`super()`を呼び出す必要がある
- `super()`は最初に呼び出す必要がある
- 親クラスの初期化処理を実行してから、子クラスの初期化処理を行う

### 抽象クラス（abstract class）
- 抽象クラスはインスタンス化できない
- 抽象メソッドを含むことができ、子クラスで実装を強制できる
- 共通の機能を実装しつつ、子クラスで実装すべきメソッドを定義できる
- `abstract`キーワードで抽象クラスと抽象メソッドを定義する

### implementsキーワード
- `implements`でクラスがインターフェースを実装することを示す
- 複数のインターフェースを実装できる
- 継承と組み合わせて使用できる
- インターフェースで定義されたメソッドの実装を保証する

### 継承と抽象化の活用場面
- 共通の機能を持つクラス群を整理する
- コードの再利用性を高める
- 型安全性を保ちながら柔軟な設計を実現する
- インターフェースで契約を定義し、実装を強制する

### 次のステップ
継承と抽象化を理解したら、次のトピックに進みましょう：
- インターフェースと型エイリアス（9章）
- 高度な型システム（10章）
- ジェネリクス（11章）

---

## 演習問題

以下の問題を解いて、継承と抽象化の理解を深めましょう。

### 問題1: クラスの継承
動物クラスを継承して、犬クラスと猫クラスを作成してください。それぞれ異なる鳴き声を出力するようにしてください。

<details>
<summary>解答例</summary>

```typescript
class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    speak(): void {
        console.log(`${this.name}が鳴いています`);
    }
}

class Dog extends Animal {
    speak(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
}

class Cat extends Animal {
    speak(): void {
        console.log(`${this.name}がニャーニャーと鳴いています`);
    }
}

const dog = new Dog("ポチ");
dog.speak();  // "ポチがワンワンと鳴いています"

const cat = new Cat("タマ");
cat.speak();  // "タマがニャーニャーと鳴いています"
```
</details>

### 問題2: メソッドのオーバーライド
図形クラスを継承して、長方形クラスと円クラスを作成し、面積を計算するメソッドをオーバーライドしてください。

<details>
<summary>解答例</summary>

```typescript
class Shape {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    getArea(): number {
        return 0;
    }
}

class Rectangle extends Shape {
    width: number;
    height: number;
    
    constructor(width: number, height: number) {
        super("長方形");
        this.width = width;
        this.height = height;
    }
    
    getArea(): number {
        return this.width * this.height;
    }
}

class Circle extends Shape {
    radius: number;
    
    constructor(radius: number) {
        super("円");
        this.radius = radius;
    }
    
    getArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

const rect = new Rectangle(10, 5);
console.log(rect.getArea());  // 50

const circle = new Circle(5);
console.log(circle.getArea());  // 78.53981633974483
```
</details>

### 問題3: コンストラクタのオーバーライド
人クラスを継承して、学生クラスを作成してください。学生クラスには学生IDを追加してください。

<details>
<summary>解答例</summary>

```typescript
class Person {
    name: string;
    age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    
    introduce(): void {
        console.log(`私は${this.name}、${this.age}歳です`);
    }
}

class Student extends Person {
    studentId: string;
    
    constructor(name: string, age: number, studentId: string) {
        super(name, age);
        this.studentId = studentId;
    }
    
    introduce(): void {
        super.introduce();
        console.log(`学生ID: ${this.studentId}`);
    }
}

const student = new Student("太郎", 20, "S001");
student.introduce();
// "私は太郎、20歳です"
// "学生ID: S001"
```
</details>

### 問題4: 抽象クラス
抽象クラス「動物」を作成し、抽象メソッド「動く」を定義してください。犬クラスと鳥クラスで実装してください。

<details>
<summary>解答例</summary>

```typescript
abstract class Animal {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    abstract move(): void;
}

class Dog extends Animal {
    move(): void {
        console.log(`${this.name}が走っています`);
    }
}

class Bird extends Animal {
    move(): void {
        console.log(`${this.name}が飛んでいます`);
    }
}

const dog = new Dog("ポチ");
dog.move();  // "ポチが走っています"

const bird = new Bird("スズメ");
bird.move();  // "スズメが飛んでいます"
```
</details>

### 問題5: implementsキーワード
「動く」インターフェースと「鳴く」インターフェースを作成し、犬クラスで両方を実装してください。

<details>
<summary>解答例</summary>

```typescript
interface Movable {
    move(): void;
}

interface Speakable {
    speak(): void;
}

class Dog implements Movable, Speakable {
    name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    move(): void {
        console.log(`${this.name}が走っています`);
    }
    
    speak(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
}

const dog = new Dog("ポチ");
dog.move();   // "ポチが走っています"
dog.speak();  // "ポチがワンワンと鳴いています"
```
</details>

---

お疲れ様でした！次の章に進みましょう。

