# 8-2. アクセス修飾子とカプセル化

この章では、クラスのメンバー（プロパティやメソッド）へのアクセスを制御する「アクセス修飾子」について学びます。アクセス修飾子を使うことで、データの安全性を高め、オブジェクト指向プログラミングの重要な概念である「カプセル化」を実現できます。

---

## 目次

- [アクセシビリティ修飾子（public / private / protected）](#アクセシビリティ修飾子public--private--protected)
- [プロパティを読み取り専用にしよう（readonly）](#プロパティを読み取り専用にしようreadonly)
- [オプショナルなプロパティ](#オプショナルなプロパティ)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## アクセシビリティ修飾子（public / private / protected）

### アクセス修飾子とは
アクセス修飾子は、**クラスのメンバー（プロパティやメソッド）に誰がアクセスできるかを制御する**機能です。

### 日常生活での例
- **銀行の金庫**: 一般の人は見られない（private）、銀行員は見られる（protected）、誰でも見られる（public）
- **家の鍵**: 家族だけが使える（private）、親戚も使える（protected）、誰でも使える（public）
- **会社の機密情報**: 社員だけがアクセスできる（private）、関連部署もアクセスできる（protected）、公開情報（public）

### アクセス修飾子の種類

TypeScriptには、以下の3つのアクセス修飾子があります：

1. **public**: どこからでもアクセス可能（デフォルト）
2. **private**: クラス内部からのみアクセス可能
3. **protected**: クラス内部と継承したクラスからのみアクセス可能

### アクセス修飾子の基本構文

```typescript
class クラス名 {
    public プロパティ名: 型;      // どこからでもアクセス可能
    private プロパティ名: 型;     // クラス内部からのみ
    protected プロパティ名: 型;   // クラス内部と継承クラスからのみ
    
    public メソッド名(): void {}   // どこからでも呼び出し可能
    private メソッド名(): void {}  // クラス内部からのみ
    protected メソッド名(): void {} // クラス内部と継承クラスからのみ
}
```

### public修飾子

public修飾子は、**どこからでもアクセス可能**です。TypeScriptでは、修飾子を省略すると自動的にpublicになります。

```typescript
class Person {
    public name: string;
    public age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    
    public greet(): string {
        return `こんにちは、${this.name}さん`;
    }
}

const person = new Person("太郎", 25);
console.log(person.name);        // OK: publicなのでアクセス可能
console.log(person.age);         // OK: publicなのでアクセス可能
console.log(person.greet());     // OK: publicなので呼び出し可能
```

### private修飾子

private修飾子は、**クラス内部からのみアクセス可能**です。外部からはアクセスできません。

```typescript
class BankAccount {
    private balance: number;  // 残高は外部から直接アクセスできない
    
    constructor(initialBalance: number) {
        this.balance = initialBalance;
    }
    
    // 残高を取得するメソッド（public）
    public getBalance(): number {
        return this.balance;
    }
    
    // 預金するメソッド（public）
    public deposit(amount: number): void {
        if (amount > 0) {
            this.balance += amount;
        }
    }
    
    // 引き出すメソッド（public）
    public withdraw(amount: number): boolean {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            return true;
        }
        return false;
    }
}

const account = new BankAccount(1000);
console.log(account.getBalance());  // OK: 1000
// console.log(account.balance);    // エラー: privateプロパティは外部からアクセスできない
account.deposit(500);
console.log(account.getBalance());  // OK: 1500
```

### protected修飾子

protected修飾子は、**クラス内部と継承したクラスからのみアクセス可能**です。外部からはアクセスできませんが、継承したクラスからはアクセスできます。

```typescript
class Animal {
    protected name: string;  // 継承クラスからアクセス可能
    
    constructor(name: string) {
        this.name = name;
    }
    
    protected makeSound(): void {  // 継承クラスから呼び出し可能
        console.log("動物の鳴き声");
    }
    
    public introduce(): void {
        console.log(`私は${this.name}です`);
    }
}

class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    
    public bark(): void {
        // OK: protectedメソッドは継承クラスから呼び出し可能
        this.makeSound();
        console.log(`${this.name}がワンワンと鳴いています`);
    }
    
    public getName(): string {
        // OK: protectedプロパティは継承クラスからアクセス可能
        return this.name;
    }
}

const dog = new Dog("ポチ");
dog.introduce();  // OK: publicメソッド
dog.bark();       // OK: publicメソッド
// dog.makeSound(); // エラー: protectedメソッドは外部から呼び出せない
// console.log(dog.name); // エラー: protectedプロパティは外部からアクセスできない
console.log(dog.getName()); // OK: publicメソッド経由でアクセス
```

### 実践例: アクセス修飾子の活用

```typescript
// src/access-modifiers.ts
// 実践例1: ユーザークラス（privateでデータを保護）
class User {
    private id: number;
    private email: string;
    public name: string;  // 名前は公開
    
    constructor(id: number, name: string, email: string) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // IDを取得するメソッド（読み取り専用）
    public getId(): number {
        return this.id;
    }
    
    // メールアドレスを取得するメソッド
    public getEmail(): string {
        return this.email;
    }
    
    // メールアドレスを変更するメソッド（検証付き）
    public setEmail(newEmail: string): void {
        if (newEmail.includes('@')) {
            this.email = newEmail;
        } else {
            throw new Error("無効なメールアドレスです");
        }
    }
}

const user = new User(1, "太郎", "taro@example.com");
console.log(user.name);        // OK: public
console.log(user.getId());     // OK: メソッド経由
// console.log(user.id);       // エラー: privateプロパティはアクセスできない
// console.log(user.email);   // エラー: privateプロパティはアクセスできない
user.setEmail("new@example.com");
console.log(user.getEmail());  // OK: new@example.com

// 実践例2: 商品クラス（protectedで継承を考慮）
class Product {
    protected price: number;
    protected discount: number;
    public name: string;
    
    constructor(name: string, price: number) {
        this.name = name;
        this.price = price;
        this.discount = 0;
    }
    
    protected calculateDiscount(): number {
        return this.price * (this.discount / 100);
    }
    
    public getPrice(): number {
        return this.price - this.calculateDiscount();
    }
}

class PremiumProduct extends Product {
    constructor(name: string, price: number) {
        super(name, price);
        this.discount = 10;  // OK: protectedプロパティは継承クラスからアクセス可能
    }
    
    public getOriginalPrice(): number {
        return this.price;  // OK: protectedプロパティは継承クラスからアクセス可能
    }
}

const product = new Product("商品A", 1000);
console.log(product.getPrice());  // 1000

const premium = new PremiumProduct("商品B", 1000);
console.log(premium.getPrice());        // 900（10%割引）
console.log(premium.getOriginalPrice()); // 1000

// 実践例3: カウンタークラス（privateで内部状態を保護）
class Counter {
    private count: number;
    
    constructor(initialValue: number = 0) {
        this.count = initialValue;
    }
    
    public increment(): void {
        this.count++;
    }
    
    public decrement(): void {
        if (this.count > 0) {
            this.count--;
        }
    }
    
    public getCount(): number {
        return this.count;
    }
    
    public reset(): void {
        this.count = 0;
    }
}

const counter = new Counter(10);
counter.increment();
console.log(counter.getCount());  // 11
counter.decrement();
console.log(counter.getCount());  // 10
// counter.count = 100;  // エラー: privateプロパティは直接変更できない
counter.reset();
console.log(counter.getCount());  // 0

// 実践例4: 図形クラス（protectedで継承を考慮）
class Shape {
    protected width: number;
    protected height: number;
    
    constructor(width: number, height: number) {
        this.width = width;
        this.height = height;
    }
    
    protected calculateArea(): number {
        return this.width * this.height;
    }
    
    public getArea(): number {
        return this.calculateArea();
    }
}

class Rectangle extends Shape {
    constructor(width: number, height: number) {
        super(width, height);
    }
    
    // 継承クラスで独自の実装を追加
    public getDimensions(): string {
        return `${this.width} × ${this.height}`;  // OK: protectedプロパティにアクセス可能
    }
}

class Triangle extends Shape {
    constructor(base: number, height: number) {
        super(base, height);
    }
    
    // 三角形の面積計算をオーバーライド
    public getArea(): number {
        return (this.width * this.height) / 2;  // OK: protectedプロパティにアクセス可能
    }
}

const rectangle = new Rectangle(10, 5);
console.log(rectangle.getArea());        // 50
console.log(rectangle.getDimensions());  // 10 × 5

const triangle = new Triangle(10, 5);
console.log(triangle.getArea());  // 25

// 実践例5: パスワード管理クラス（privateで機密情報を保護）
class PasswordManager {
    private password: string;
    private salt: string;
    
    constructor(password: string) {
        this.password = this.hashPassword(password);
        this.salt = this.generateSalt();
    }
    
    private hashPassword(password: string): string {
        // パスワードをハッシュ化（簡易版）
        return `hashed_${password}`;
    }
    
    private generateSalt(): string {
        // ソルトを生成（簡易版）
        return Math.random().toString(36).substring(7);
    }
    
    public verifyPassword(inputPassword: string): boolean {
        const hashed = this.hashPassword(inputPassword);
        return hashed === this.password;
    }
    
    public changePassword(oldPassword: string, newPassword: string): boolean {
        if (this.verifyPassword(oldPassword)) {
            this.password = this.hashPassword(newPassword);
            return true;
        }
        return false;
    }
}

const manager = new PasswordManager("myPassword123");
console.log(manager.verifyPassword("myPassword123"));  // true
console.log(manager.verifyPassword("wrongPassword"));   // false
// console.log(manager.password);  // エラー: privateプロパティはアクセスできない
```

---

## プロパティを読み取り専用にしよう（readonly）

### readonly修飾子とは
readonly修飾子は、**プロパティを読み取り専用にする**機能です。初期化後は変更できません。

### 日常生活での例
- **身分証明書の番号**: 一度発行されたら変更できない（readonly）
- **生年月日**: 一度設定されたら変更できない（readonly）
- **契約番号**: 一度発行されたら変更できない（readonly）

### readonlyの基本構文

```typescript
class クラス名 {
    readonly プロパティ名: 型;
    
    constructor(引数: 型) {
        this.プロパティ名 = 引数;  // コンストラクタでのみ代入可能
    }
}
```

### readonlyの特徴
- **初期化後は変更不可**: コンストラクタでのみ値を設定できる
- **読み取り専用**: 外部から読み取ることはできるが、変更はできない
- **型安全性**: 意図しない変更を防ぐ

### 実践例: readonly修飾子

```typescript
// src/readonly-property.ts
// 基本的なreadonlyプロパティ
class User {
    readonly id: number;
    public name: string;
    
    constructor(id: number, name: string) {
        this.id = id;  // OK: コンストラクタでは代入可能
        this.name = name;
    }
}

const user = new User(1, "太郎");
console.log(user.id);    // OK: 読み取り可能
console.log(user.name);  // OK: 読み取り可能
// user.id = 2;          // エラー: readonlyプロパティは変更できない
user.name = "花子";      // OK: publicプロパティは変更可能

// 実践例1: 商品クラス（IDは読み取り専用）
class Product {
    readonly id: number;
    readonly createdAt: Date;
    public name: string;
    public price: number;
    
    constructor(id: number, name: string, price: number) {
        this.id = id;
        this.createdAt = new Date();  // 作成日時も読み取り専用
        this.name = name;
        this.price = price;
    }
    
    public updatePrice(newPrice: number): void {
        this.price = newPrice;  // OK: priceは変更可能
    }
}

const product = new Product(1001, "商品A", 1000);
console.log(product.id);         // OK: 1001
console.log(product.createdAt);  // OK: 作成日時
// product.id = 1002;            // エラー: readonlyプロパティは変更できない
// product.createdAt = new Date(); // エラー: readonlyプロパティは変更できない
product.updatePrice(1200);       // OK: priceは変更可能

// 実践例2: 注文クラス（注文番号は読み取り専用）
class Order {
    readonly orderId: string;
    readonly orderDate: Date;
    public status: string;
    public items: string[];
    
    constructor(orderId: string) {
        this.orderId = orderId;
        this.orderDate = new Date();
        this.status = "pending";
        this.items = [];
    }
    
    public addItem(item: string): void {
        this.items.push(item);
    }
    
    public updateStatus(newStatus: string): void {
        this.status = newStatus;
    }
}

const order = new Order("ORD-2024-001");
order.addItem("商品A");
order.addItem("商品B");
order.updateStatus("shipped");
console.log(order.orderId);   // OK: ORD-2024-001
console.log(order.status);     // OK: shipped
// order.orderId = "ORD-2024-002"; // エラー: readonlyプロパティは変更できない

// 実践例3: 設定クラス（設定値は読み取り専用）
class Config {
    readonly apiUrl: string;
    readonly apiKey: string;
    readonly timeout: number;
    
    constructor(apiUrl: string, apiKey: string, timeout: number = 5000) {
        this.apiUrl = apiUrl;
        this.apiKey = apiKey;
        this.timeout = timeout;
    }
    
    public getApiUrl(): string {
        return this.apiUrl;
    }
}

const config = new Config("https://api.example.com", "secret-key", 10000);
console.log(config.apiUrl);   // OK: 読み取り可能
console.log(config.timeout);  // OK: 10000
// config.apiUrl = "https://other-api.com"; // エラー: readonlyプロパティは変更できない

// 実践例4: 学生クラス（学籍番号は読み取り専用）
class Student {
    readonly studentId: string;
    readonly enrollmentDate: Date;
    public name: string;
    public grade: number;
    
    constructor(studentId: string, name: string, grade: number) {
        this.studentId = studentId;
        this.enrollmentDate = new Date();
        this.name = name;
        this.grade = grade;
    }
    
    public promote(): void {
        this.grade++;  // OK: gradeは変更可能
    }
}

const student = new Student("STU-001", "太郎", 1);
console.log(student.studentId);      // OK: STU-001
console.log(student.enrollmentDate); // OK: 入学日時
student.promote();
console.log(student.grade);          // OK: 2
// student.studentId = "STU-002";    // エラー: readonlyプロパティは変更できない

// 実践例5: readonlyとprivateの組み合わせ
class BankAccount {
    private readonly accountNumber: string;  // privateとreadonlyの組み合わせ
    public balance: number;
    
    constructor(accountNumber: string, initialBalance: number) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }
    
    public getAccountNumber(): string {
        return this.accountNumber;  // OK: クラス内部からはアクセス可能
    }
}

const account = new BankAccount("ACC-12345", 1000);
console.log(account.getAccountNumber());  // OK: メソッド経由でアクセス
// console.log(account.accountNumber);    // エラー: privateプロパティは外部からアクセスできない
// account.accountNumber = "ACC-99999";  // エラー: readonlyプロパティは変更できない
```

---

## オプショナルなプロパティ

### オプショナルプロパティとは
オプショナルプロパティは、**プロパティを省略可能にする**機能です。`?`を使って指定します。

### 日常生活での例
- **メールアドレス**: 必須ではない場合がある（オプショナル）
- **電話番号**: 必須ではない場合がある（オプショナル）
- **備考欄**: 記入しなくてもよい（オプショナル）

### オプショナルプロパティの基本構文

```typescript
class クラス名 {
    プロパティ名?: 型;  // ?を付けるとオプショナルになる
}
```

### オプショナルプロパティの特徴
- **省略可能**: コンストラクタで値を設定しなくてもよい
- **undefinedの可能性**: 値が設定されていない場合はundefinedになる
- **型安全性**: TypeScriptがundefinedチェックを促す

### 実践例: オプショナルプロパティ

```typescript
// src/optional-property.ts
// 基本的なオプショナルプロパティ
class User {
    public name: string;
    public age?: number;        // オプショナル
    public email?: string;      // オプショナル
    
    constructor(name: string, age?: number, email?: string) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    public getInfo(): string {
        let info = `名前: ${this.name}`;
        if (this.age !== undefined) {
            info += `, 年齢: ${this.age}歳`;
        }
        if (this.email !== undefined) {
            info += `, メール: ${this.email}`;
        }
        return info;
    }
}

const user1 = new User("太郎");
console.log(user1.getInfo());  // 名前: 太郎

const user2 = new User("花子", 25);
console.log(user2.getInfo());  // 名前: 花子, 年齢: 25歳

const user3 = new User("次郎", 30, "jiro@example.com");
console.log(user3.getInfo());  // 名前: 次郎, 年齢: 30歳, メール: jiro@example.com

// 実践例1: 商品クラス（説明はオプショナル）
class Product {
    public id: number;
    public name: string;
    public price: number;
    public description?: string;  // 説明はオプショナル
    
    constructor(id: number, name: string, price: number, description?: string) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.description = description;
    }
    
    public getDisplayName(): string {
        if (this.description) {
            return `${this.name} - ${this.description}`;
        }
        return this.name;
    }
}

const product1 = new Product(1, "商品A", 1000);
console.log(product1.getDisplayName());  // 商品A

const product2 = new Product(2, "商品B", 2000, "高品質な商品です");
console.log(product2.getDisplayName());  // 商品B - 高品質な商品です

// 実践例2: 住所クラス（電話番号はオプショナル）
class Address {
    public street: string;
    public city: string;
    public postalCode: string;
    public phoneNumber?: string;  // 電話番号はオプショナル
    
    constructor(street: string, city: string, postalCode: string, phoneNumber?: string) {
        this.street = street;
        this.city = city;
        this.postalCode = postalCode;
        this.phoneNumber = phoneNumber;
    }
    
    public getFullAddress(): string {
        let address = `${this.postalCode} ${this.city} ${this.street}`;
        if (this.phoneNumber) {
            address += ` (電話: ${this.phoneNumber})`;
        }
        return address;
    }
}

const address1 = new Address("1-2-3", "東京", "100-0001");
console.log(address1.getFullAddress());  // 100-0001 東京 1-2-3

const address2 = new Address("4-5-6", "大阪", "530-0001", "090-1234-5678");
console.log(address2.getFullAddress());  // 530-0001 大阪 4-5-6 (電話: 090-1234-5678)

// 実践例3: 設定クラス（複数のオプショナルプロパティ）
class Settings {
    public theme: string;
    public language?: string;
    public timezone?: string;
    public notifications?: boolean;
    
    constructor(theme: string, language?: string, timezone?: string, notifications?: boolean) {
        this.theme = theme;
        this.language = language;
        this.timezone = timezone;
        this.notifications = notifications;
    }
    
    public getSettings(): string {
        let settings = `テーマ: ${this.theme}`;
        if (this.language) {
            settings += `, 言語: ${this.language}`;
        }
        if (this.timezone) {
            settings += `, タイムゾーン: ${this.timezone}`;
        }
        if (this.notifications !== undefined) {
            settings += `, 通知: ${this.notifications ? "ON" : "OFF"}`;
        }
        return settings;
    }
}

const settings1 = new Settings("dark");
console.log(settings1.getSettings());  // テーマ: dark

const settings2 = new Settings("light", "ja", "Asia/Tokyo", true);
console.log(settings2.getSettings());  // テーマ: light, 言語: ja, タイムゾーン: Asia/Tokyo, 通知: ON

// 実践例4: オプショナルプロパティとメソッド
class Employee {
    public id: number;
    public name: string;
    public department?: string;
    public manager?: Employee;  // オプショナルなオブジェクト
    
    constructor(id: number, name: string, department?: string, manager?: Employee) {
        this.id = id;
        this.name = name;
        this.department = department;
        this.manager = manager;
    }
    
    public getManagerName(): string {
        if (this.manager) {
            return this.manager.name;
        }
        return "マネージャーなし";
    }
}

const manager = new Employee(1, "田中", "営業部");
const employee = new Employee(2, "佐藤", "営業部", manager);
console.log(employee.getManagerName());  // 田中

const employee2 = new Employee(3, "鈴木", "開発部");
console.log(employee2.getManagerName());  // マネージャーなし

// 実践例5: オプショナルプロパティとアクセス修飾子の組み合わせ
class Book {
    public title: string;
    public author: string;
    private isbn?: string;      // privateとオプショナルの組み合わせ
    protected publisher?: string; // protectedとオプショナルの組み合わせ
    
    constructor(title: string, author: string, isbn?: string, publisher?: string) {
        this.title = title;
        this.author = author;
        this.isbn = isbn;
        this.publisher = publisher;
    }
    
    public getIsbn(): string {
        return this.isbn ?? "ISBN未設定";
    }
}

class EBook extends Book {
    public format?: string;
    
    constructor(title: string, author: string, format?: string, publisher?: string) {
        super(title, author, undefined, publisher);
        this.format = format;
    }
    
    public getPublisher(): string {
        return this.publisher ?? "出版社未設定";  // OK: protectedプロパティは継承クラスからアクセス可能
    }
}

const book = new Book("TypeScript入門", "山田太郎", "978-1234567890", "技術出版社");
console.log(book.getIsbn());  // 978-1234567890

const ebook = new EBook("TypeScript実践", "佐藤花子", "PDF", "技術出版社");
console.log(ebook.getPublisher());  // 技術出版社
```

---

## まとめ

この章では、TypeScriptのアクセス修飾子とカプセル化について学びました。

### 学んだこと
- **public修飾子**: どこからでもアクセス可能（デフォルト）
- **private修飾子**: クラス内部からのみアクセス可能
- **protected修飾子**: クラス内部と継承クラスからのみアクセス可能
- **readonly修飾子**: プロパティを読み取り専用にする
- **オプショナルプロパティ**: プロパティを省略可能にする（`?`を使用）

### 重要なポイント
1. **カプセル化**: データを保護し、適切な方法でのみアクセスできるようにする
2. **アクセス制御**: public、private、protectedで適切なアクセスレベルを設定
3. **readonly**: 一度設定した値を変更できないようにする
4. **オプショナル**: 必須でないプロパティは`?`を使って省略可能にする
5. **型安全性**: TypeScriptが適切に型チェックを行い、エラーを防ぐ

### 使い分けの目安
- **public**: 外部から自由にアクセスしてほしい場合
- **private**: クラス内部でのみ使用し、外部からは隠したい場合
- **protected**: 継承クラスからはアクセス可能にしたい場合
- **readonly**: 初期化後は変更したくない場合
- **オプショナル**: 必須でない情報の場合

### 次のステップ
次の章では、継承と抽象化について詳しく学びます。アクセス修飾子を理解することで、より安全で保守しやすいクラス設計ができるようになります。

---

## 演習問題

### 問題1: private修飾子
`BankAccount`クラスを作成し、`balance`プロパティをprivateにして、外部から直接アクセスできないようにしてください。残高を取得する`getBalance()`メソッドを追加してください。

<details>
<summary>解答例</summary>

```typescript
class BankAccount {
    private balance: number;
    
    constructor(initialBalance: number) {
        this.balance = initialBalance;
    }
    
    public getBalance(): number {
        return this.balance;
    }
    
    public deposit(amount: number): void {
        if (amount > 0) {
            this.balance += amount;
        }
    }
    
    public withdraw(amount: number): boolean {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            return true;
        }
        return false;
    }
}

const account = new BankAccount(1000);
console.log(account.getBalance());  // 1000
account.deposit(500);
console.log(account.getBalance());  // 1500
account.withdraw(200);
console.log(account.getBalance());  // 1300
```
</details>

### 問題2: protected修飾子
`Animal`クラスを作成し、`name`プロパティをprotectedにしてください。`Dog`クラスを継承し、`name`プロパティにアクセスできることを確認してください。

<details>
<summary>解答例</summary>

```typescript
class Animal {
    protected name: string;
    
    constructor(name: string) {
        this.name = name;
    }
    
    public introduce(): void {
        console.log(`私は${this.name}です`);
    }
}

class Dog extends Animal {
    constructor(name: string) {
        super(name);
    }
    
    public bark(): void {
        console.log(`${this.name}がワンワンと鳴いています`);
    }
}

const dog = new Dog("ポチ");
dog.introduce();  // 私はポチです
dog.bark();       // ポチがワンワンと鳴いています
```
</details>

### 問題3: readonly修飾子
`Product`クラスを作成し、`id`と`createdAt`プロパティをreadonlyにしてください。

<details>
<summary>解答例</summary>

```typescript
class Product {
    readonly id: number;
    readonly createdAt: Date;
    public name: string;
    public price: number;
    
    constructor(id: number, name: string, price: number) {
        this.id = id;
        this.createdAt = new Date();
        this.name = name;
        this.price = price;
    }
}

const product = new Product(1, "商品A", 1000);
console.log(product.id);         // 1
console.log(product.createdAt);  // 作成日時
// product.id = 2;               // エラー: readonlyプロパティは変更できない
product.price = 1200;            // OK: priceは変更可能
```
</details>

### 問題4: オプショナルプロパティ
`User`クラスを作成し、`email`と`phoneNumber`プロパティをオプショナルにしてください。

<details>
<summary>解答例</summary>

```typescript
class User {
    public name: string;
    public email?: string;
    public phoneNumber?: string;
    
    constructor(name: string, email?: string, phoneNumber?: string) {
        this.name = name;
        this.email = email;
        this.phoneNumber = phoneNumber;
    }
    
    public getContactInfo(): string {
        let info = `名前: ${this.name}`;
        if (this.email) {
            info += `, メール: ${this.email}`;
        }
        if (this.phoneNumber) {
            info += `, 電話: ${this.phoneNumber}`;
        }
        return info;
    }
}

const user1 = new User("太郎");
console.log(user1.getContactInfo());  // 名前: 太郎

const user2 = new User("花子", "hanako@example.com", "090-1234-5678");
console.log(user2.getContactInfo());  // 名前: 花子, メール: hanako@example.com, 電話: 090-1234-5678
```
</details>

### 問題5: 複合的な使用
`Employee`クラスを作成し、以下の要件を満たしてください：
- `id`はreadonly
- `salary`はprivate
- `department`はprotected
- `email`はオプショナル

<details>
<summary>解答例</summary>

```typescript
class Employee {
    readonly id: number;
    private salary: number;
    protected department: string;
    public name: string;
    public email?: string;
    
    constructor(id: number, name: string, salary: number, department: string, email?: string) {
        this.id = id;
        this.name = name;
        this.salary = salary;
        this.department = department;
        this.email = email;
    }
    
    public getSalary(): number {
        return this.salary;
    }
    
    public getDepartment(): string {
        return this.department;
    }
}

class Manager extends Employee {
    constructor(id: number, name: string, salary: number, department: string, email?: string) {
        super(id, name, salary, department, email);
    }
    
    public getInfo(): string {
        return `${this.name} (${this.department})`;  // OK: protectedプロパティにアクセス可能
    }
}

const employee = new Employee(1, "太郎", 500000, "営業部", "taro@example.com");
console.log(employee.id);           // OK: 1
console.log(employee.getSalary()); // OK: 500000
console.log(employee.getDepartment()); // OK: 営業部
// console.log(employee.salary);    // エラー: privateプロパティはアクセスできない
// employee.id = 2;                // エラー: readonlyプロパティは変更できない

const manager = new Manager(2, "花子", 800000, "開発部");
console.log(manager.getInfo());    // 花子 (開発部)
```
</details>

---

お疲れ様でした！次の章に進みましょう。

