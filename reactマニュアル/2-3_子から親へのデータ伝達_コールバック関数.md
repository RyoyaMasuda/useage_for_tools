# 2-3. 子から親へのデータ伝達 (コールバック関数)

この章では、子コンポーネントから親コンポーネントへデータを伝達する方法について学びます。Reactでは、Propsは親から子への一方通行ですが、コールバック関数を使用することで、子から親へデータを伝達できます。

---

## 目次

- [コールバック関数とは](#コールバック関数とは)
- [基本的なコールバック関数の使い方](#基本的なコールバック関数の使い方)
- [実践例: ボタンクリックで親の状態を更新](#実践例-ボタンクリックで親の状態を更新)
- [実践例: フォーム入力の親への伝達](#実践例-フォーム入力の親への伝達)
- [実践例: 複数の子コンポーネントからのデータ伝達](#実践例-複数の子コンポーネントからのデータ伝達)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## コールバック関数とは

### コールバック関数の概念
コールバック関数は、**他の関数に引数として渡される関数**です。Reactでは、親コンポーネントから子コンポーネントにコールバック関数をPropsとして渡し、子コンポーネントでその関数を呼び出すことで、親コンポーネントにデータを伝達します。

### データの流れ

```
親コンポーネント
  ↓ (Propsでコールバック関数を渡す)
子コンポーネント
  ↓ (コールバック関数を呼び出す)
親コンポーネント (状態を更新)
```

### コールバック関数の特徴
- **一方通行の補完**: Propsは親→子のみだが、コールバックで子→親も可能
- **状態の更新**: 親コンポーネントの状態を更新できる
- **イベント処理**: ユーザー操作に応じて親に通知できる

### 基本的なパターン

```jsx
// 親コンポーネント
function Parent() {
  const [value, setValue] = useState('')
  
  // コールバック関数
  const handleChildData = (data) => {
    setValue(data)
  }
  
  return <Child onDataChange={handleChildData} />
}

// 子コンポーネント
function Child({ onDataChange }) {
  const handleClick = () => {
    onDataChange('新しい値')
  }
  
  return <button onClick={handleClick}>データを送信</button>
}
```

---

## 基本的なコールバック関数の使い方

### ステップ1: 親コンポーネントでコールバック関数を定義

```jsx
function Parent() {
  const [message, setMessage] = useState('初期メッセージ')
  
  // コールバック関数を定義
  const handleMessageChange = (newMessage) => {
    setMessage(newMessage)
  }
  
  return (
    <div>
      <p>親のメッセージ: {message}</p>
      <Child onMessageChange={handleMessageChange} />
    </div>
  )
}
```

### ステップ2: 子コンポーネントでコールバック関数を受け取る

```jsx
function Child({ onMessageChange }) {
  const handleClick = () => {
    // コールバック関数を呼び出す
    onMessageChange('子から親へ送信されたメッセージ')
  }
  
  return <button onClick={handleClick}>メッセージを送信</button>
}
```

### 実践例: 基本的なコールバック関数

```jsx
// src/App.jsx
import { useState } from 'react'
import Child from './Child'

function App() {
  const [count, setCount] = useState(0)
  
  // コールバック関数: 子コンポーネントから呼び出される
  const handleIncrement = () => {
    setCount(count + 1)
  }
  
  const handleDecrement = () => {
    setCount(count - 1)
  }
  
  return (
    <div>
      <h1>カウント: {count}</h1>
      <Child 
        onIncrement={handleIncrement}
        onDecrement={handleDecrement}
      />
    </div>
  )
}

export default App
```

```jsx
// src/Child.jsx
function Child({ onIncrement, onDecrement }) {
  return (
    <div>
      <button onClick={onIncrement}>増やす</button>
      <button onClick={onDecrement}>減らす</button>
    </div>
  )
}

export default Child
```

---

## 実践例: ボタンクリックで親の状態を更新

### 実践例1: カウンターアプリ

```jsx
// src/App.jsx
import { useState } from 'react'
import CounterButton from './components/CounterButton'

function App() {
  const [count, setCount] = useState(0)
  
  // カウントを増やすコールバック
  const handleIncrement = (amount) => {
    setCount(count + amount)
  }
  
  // カウントをリセットするコールバック
  const handleReset = () => {
    setCount(0)
  }
  
  return (
    <div className="App">
      <h1>カウンター: {count}</h1>
      <CounterButton 
        label="+1"
        amount={1}
        onClick={handleIncrement}
      />
      <CounterButton 
        label="+5"
        amount={5}
        onClick={handleIncrement}
      />
      <CounterButton 
        label="+10"
        amount={10}
        onClick={handleIncrement}
      />
      <button onClick={handleReset}>リセット</button>
    </div>
  )
}

export default App
```

```jsx
// src/components/CounterButton.jsx
function CounterButton({ label, amount, onClick }) {
  const handleClick = () => {
    onClick(amount)
  }
  
  return (
    <button onClick={handleClick}>
      {label}
    </button>
  )
}

export default CounterButton
```

### 実践例2: タスクリストアプリ

```jsx
// src/App.jsx
import { useState } from 'react'
import TaskList from './components/TaskList'
import AddTask from './components/AddTask'

function App() {
  const [tasks, setTasks] = useState([
    { id: 1, text: 'タスク1', completed: false },
    { id: 2, text: 'タスク2', completed: false }
  ])
  
  // タスクを追加するコールバック
  const handleAddTask = (taskText) => {
    const newTask = {
      id: Date.now(),
      text: taskText,
      completed: false
    }
    setTasks([...tasks, newTask])
  }
  
  // タスクを削除するコールバック
  const handleDeleteTask = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId))
  }
  
  // タスクの完了状態を切り替えるコールバック
  const handleToggleTask = (taskId) => {
    setTasks(tasks.map(task => 
      task.id === taskId 
        ? { ...task, completed: !task.completed }
        : task
    ))
  }
  
  return (
    <div className="App">
      <h1>タスクリスト</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList 
        tasks={tasks}
        onDeleteTask={handleDeleteTask}
        onToggleTask={handleToggleTask}
      />
    </div>
  )
}

export default App
```

```jsx
// src/components/AddTask.jsx
import { useState } from 'react'

function AddTask({ onAddTask }) {
  const [input, setInput] = useState('')
  
  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddTask(input)
      setInput('')
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input 
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="新しいタスクを入力"
      />
      <button type="submit">追加</button>
    </form>
  )
}

export default AddTask
```

```jsx
// src/components/TaskList.jsx
import TaskItem from './TaskItem'

function TaskList({ tasks, onDeleteTask, onToggleTask }) {
  return (
    <ul>
      {tasks.map(task => (
        <TaskItem
          key={task.id}
          task={task}
          onDelete={onDeleteTask}
          onToggle={onToggleTask}
        />
      ))}
    </ul>
  )
}

export default TaskList
```

```jsx
// src/components/TaskItem.jsx
function TaskItem({ task, onDelete, onToggle }) {
  return (
    <li>
      <input
        type="checkbox"
        checked={task.completed}
        onChange={() => onToggle(task.id)}
      />
      <span style={{ 
        textDecoration: task.completed ? 'line-through' : 'none' 
      }}>
        {task.text}
      </span>
      <button onClick={() => onDelete(task.id)}>削除</button>
    </li>
  )
}

export default TaskItem
```

---

## 実践例: フォーム入力の親への伝達

### 実践例1: シンプルなフォーム

```jsx
// src/App.jsx
import { useState } from 'react'
import FormInput from './components/FormInput'

function App() {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    message: ''
  })
  
  // フォームデータを更新するコールバック
  const handleInputChange = (field, value) => {
    setFormData({
      ...formData,
      [field]: value
    })
  }
  
  // フォーム送信の処理
  const handleSubmit = (e) => {
    e.preventDefault()
    console.log('送信されたデータ:', formData)
    alert('フォームが送信されました！')
  }
  
  return (
    <div className="App">
      <h1>お問い合わせフォーム</h1>
      <form onSubmit={handleSubmit}>
        <FormInput
          label="名前"
          value={formData.name}
          onChange={(value) => handleInputChange('name', value)}
        />
        <FormInput
          label="メールアドレス"
          type="email"
          value={formData.email}
          onChange={(value) => handleInputChange('email', value)}
        />
        <FormInput
          label="メッセージ"
          type="textarea"
          value={formData.message}
          onChange={(value) => handleInputChange('message', value)}
        />
        <button type="submit">送信</button>
      </form>
      
      <div>
        <h2>入力内容のプレビュー</h2>
        <p>名前: {formData.name}</p>
        <p>メール: {formData.email}</p>
        <p>メッセージ: {formData.message}</p>
      </div>
    </div>
  )
}

export default App
```

```jsx
// src/components/FormInput.jsx
function FormInput({ label, type = 'text', value, onChange }) {
  const handleChange = (e) => {
    onChange(e.target.value)
  }
  
  if (type === 'textarea') {
    return (
      <div>
        <label>{label}</label>
        <textarea
          value={value}
          onChange={handleChange}
        />
      </div>
    )
  }
  
  return (
    <div>
      <label>{label}</label>
      <input
        type={type}
        value={value}
        onChange={handleChange}
      />
    </div>
  )
}

export default FormInput
```

### 実践例2: 検索フォーム

```jsx
// src/App.jsx
import { useState } from 'react'
import SearchBox from './components/SearchBox'
import SearchResults from './components/SearchResults'

const items = [
  'りんご', 'バナナ', 'オレンジ', 'ぶどう', 'いちご',
  'メロン', 'スイカ', 'パイナップル', 'マンゴー', 'キウイ'
]

function App() {
  const [searchQuery, setSearchQuery] = useState('')
  const [filteredItems, setFilteredItems] = useState(items)
  
  // 検索クエリを更新するコールバック
  const handleSearchChange = (query) => {
    setSearchQuery(query)
    const filtered = items.filter(item => 
      item.includes(query)
    )
    setFilteredItems(filtered)
  }
  
  return (
    <div className="App">
      <h1>フルーツ検索</h1>
      <SearchBox 
        value={searchQuery}
        onChange={handleSearchChange}
      />
      <SearchResults items={filteredItems} />
    </div>
  )
}

export default App
```

```jsx
// src/components/SearchBox.jsx
function SearchBox({ value, onChange }) {
  const handleChange = (e) => {
    onChange(e.target.value)
  }
  
  return (
    <div>
      <input
        type="text"
        value={value}
        onChange={handleChange}
        placeholder="検索..."
      />
    </div>
  )
}

export default SearchBox
```

```jsx
// src/components/SearchResults.jsx
function SearchResults({ items }) {
  if (items.length === 0) {
    return <p>検索結果が見つかりませんでした</p>
  }
  
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  )
}

export default SearchResults
```

---

## 実践例: 複数の子コンポーネントからのデータ伝達

### 実践例1: 複数の設定パネル

```jsx
// src/App.jsx
import { useState } from 'react'
import SettingsPanel from './components/SettingsPanel'

function App() {
  const [settings, setSettings] = useState({
    theme: 'light',
    language: 'ja',
    notifications: true
  })
  
  // 設定を更新するコールバック
  const handleSettingChange = (key, value) => {
    setSettings({
      ...settings,
      [key]: value
    })
  }
  
  return (
    <div className="App">
      <h1>設定</h1>
      <SettingsPanel
        title="テーマ"
        value={settings.theme}
        options={['light', 'dark']}
        onChange={(value) => handleSettingChange('theme', value)}
      />
      <SettingsPanel
        title="言語"
        value={settings.language}
        options={['ja', 'en', 'zh']}
        onChange={(value) => handleSettingChange('language', value)}
      />
      <SettingsPanel
        title="通知"
        value={settings.notifications}
        type="checkbox"
        onChange={(value) => handleSettingChange('notifications', value)}
      />
      
      <div>
        <h2>現在の設定</h2>
        <pre>{JSON.stringify(settings, null, 2)}</pre>
      </div>
    </div>
  )
}

export default App
```

```jsx
// src/components/SettingsPanel.jsx
function SettingsPanel({ title, value, options, type, onChange }) {
  if (type === 'checkbox') {
    return (
      <div>
        <label>
          <input
            type="checkbox"
            checked={value}
            onChange={(e) => onChange(e.target.checked)}
          />
          {title}
        </label>
      </div>
    )
  }
  
  return (
    <div>
      <label>{title}</label>
      <select 
        value={value} 
        onChange={(e) => onChange(e.target.value)}
      >
        {options.map(option => (
          <option key={option} value={option}>
            {option}
          </option>
        ))}
      </select>
    </div>
  )
}

export default SettingsPanel
```

### 実践例2: モーダルダイアログ

```jsx
// src/App.jsx
import { useState } from 'react'
import Modal from './components/Modal'
import Button from './components/Button'

function App() {
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [modalContent, setModalContent] = useState('')
  
  // モーダルを開くコールバック
  const handleOpenModal = (content) => {
    setModalContent(content)
    setIsModalOpen(true)
  }
  
  // モーダルを閉じるコールバック
  const handleCloseModal = () => {
    setIsModalOpen(false)
    setModalContent('')
  }
  
  return (
    <div className="App">
      <h1>モーダルダイアログの例</h1>
      <Button 
        label="情報を表示"
        onClick={() => handleOpenModal('これは情報メッセージです')}
      />
      <Button 
        label="警告を表示"
        onClick={() => handleOpenModal('これは警告メッセージです')}
      />
      <Button 
        label="確認を表示"
        onClick={() => handleOpenModal('これは確認メッセージです')}
      />
      
      {isModalOpen && (
        <Modal 
          content={modalContent}
          onClose={handleCloseModal}
        />
      )}
    </div>
  )
}

export default App
```

```jsx
// src/components/Modal.jsx
function Modal({ content, onClose }) {
  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }}>
      <div style={{
        backgroundColor: 'white',
        padding: '20px',
        borderRadius: '8px',
        maxWidth: '400px'
      }}>
        <p>{content}</p>
        <button onClick={onClose}>閉じる</button>
      </div>
    </div>
  )
}

export default Modal
```

```jsx
// src/components/Button.jsx
function Button({ label, onClick }) {
  return (
    <button onClick={onClick}>
      {label}
    </button>
  )
}

export default Button
```

---

## まとめ

この章では、子コンポーネントから親コンポーネントへデータを伝達する方法について学びました。

### 学んだこと
- コールバック関数: 親から子に渡し、子から呼び出す関数
- 基本的な使い方: 親で定義し、子にPropsで渡す
- 実践例: ボタンクリック、フォーム入力、複数の子コンポーネント

### 重要なポイント
1. **コールバック関数**: Propsで親から子に渡す関数
2. **データの流れ**: 子→親へのデータ伝達が可能
3. **状態の更新**: 親コンポーネントの状態を更新できる
4. **イベント処理**: ユーザー操作に応じて親に通知

### 次のステップ
次の章では、副作用とフック（Hooks）の基本について詳しく学びます。

---

## 演習問題

### 問題1: 基本的なコールバック関数
親コンポーネントで`count`という状態を持ち、子コンポーネントのボタンをクリックすると親の`count`が増えるようにしてください。

<details>
<summary>解答例</summary>

```jsx
// src/App.jsx
import { useState } from 'react'
import CounterButton from './CounterButton'

function App() {
  const [count, setCount] = useState(0)
  
  const handleIncrement = () => {
    setCount(count + 1)
  }
  
  return (
    <div>
      <h1>カウント: {count}</h1>
      <CounterButton onIncrement={handleIncrement} />
    </div>
  )
}

export default App
```

```jsx
// src/CounterButton.jsx
function CounterButton({ onIncrement }) {
  return (
    <button onClick={onIncrement}>
      カウントを増やす
    </button>
  )
}

export default CounterButton
```
</details>

### 問題2: フォーム入力の親への伝達
子コンポーネントで入力フィールドを作成し、入力内容を親コンポーネントに伝達してください。

<details>
<summary>解答例</summary>

```jsx
// src/App.jsx
import { useState } from 'react'
import InputField from './InputField'

function App() {
  const [value, setValue] = useState('')
  
  const handleChange = (newValue) => {
    setValue(newValue)
  }
  
  return (
    <div>
      <h1>入力値: {value}</h1>
      <InputField onChange={handleChange} />
    </div>
  )
}

export default App
```

```jsx
// src/InputField.jsx
import { useState } from 'react'

function InputField({ onChange }) {
  const [input, setInput] = useState('')
  
  const handleChange = (e) => {
    const newValue = e.target.value
    setInput(newValue)
    onChange(newValue)
  }
  
  return (
    <input
      type="text"
      value={input}
      onChange={handleChange}
      placeholder="入力してください"
    />
  )
}

export default InputField
```
</details>

### 問題3: タスクの追加と削除
タスクリストアプリを作成し、子コンポーネントからタスクを追加・削除できるようにしてください。

<details>
<summary>解答例</summary>

```jsx
// src/App.jsx
import { useState } from 'react'
import TaskForm from './TaskForm'
import TaskList from './TaskList'

function App() {
  const [tasks, setTasks] = useState([])
  
  const handleAddTask = (taskText) => {
    setTasks([...tasks, { id: Date.now(), text: taskText }])
  }
  
  const handleDeleteTask = (taskId) => {
    setTasks(tasks.filter(task => task.id !== taskId))
  }
  
  return (
    <div>
      <h1>タスクリスト</h1>
      <TaskForm onAddTask={handleAddTask} />
      <TaskList tasks={tasks} onDeleteTask={handleDeleteTask} />
    </div>
  )
}

export default App
```

```jsx
// src/TaskForm.jsx
import { useState } from 'react'

function TaskForm({ onAddTask }) {
  const [input, setInput] = useState('')
  
  const handleSubmit = (e) => {
    e.preventDefault()
    if (input.trim()) {
      onAddTask(input)
      setInput('')
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
      />
      <button type="submit">追加</button>
    </form>
  )
}

export default TaskForm
```

```jsx
// src/TaskList.jsx
function TaskList({ tasks, onDeleteTask }) {
  return (
    <ul>
      {tasks.map(task => (
        <li key={task.id}>
          {task.text}
          <button onClick={() => onDeleteTask(task.id)}>削除</button>
        </li>
      ))}
    </ul>
  )
}

export default TaskList
```
</details>

### 問題4: 検索機能
検索ボックスコンポーネントを作成し、検索クエリを親コンポーネントに伝達してください。

<details>
<summary>解答例</summary>

```jsx
// src/App.jsx
import { useState } from 'react'
import SearchBox from './SearchBox'

const items = ['りんご', 'バナナ', 'オレンジ', 'ぶどう']

function App() {
  const [query, setQuery] = useState('')
  
  const handleSearch = (searchQuery) => {
    setQuery(searchQuery)
  }
  
  const filteredItems = items.filter(item => item.includes(query))
  
  return (
    <div>
      <h1>検索</h1>
      <SearchBox onSearch={handleSearch} />
      <ul>
        {filteredItems.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  )
}

export default App
```

```jsx
// src/SearchBox.jsx
function SearchBox({ onSearch }) {
  const handleChange = (e) => {
    onSearch(e.target.value)
  }
  
  return (
    <input
      type="text"
      onChange={handleChange}
      placeholder="検索..."
    />
  )
}

export default SearchBox
```
</details>

### 問題5: モーダルダイアログ
モーダルダイアログコンポーネントを作成し、子コンポーネントからモーダルを開閉できるようにしてください。

<details>
<summary>解答例</summary>

```jsx
// src/App.jsx
import { useState } from 'react'
import Modal from './Modal'
import Button from './Button'

function App() {
  const [isOpen, setIsOpen] = useState(false)
  
  const handleOpen = () => {
    setIsOpen(true)
  }
  
  const handleClose = () => {
    setIsOpen(false)
  }
  
  return (
    <div>
      <h1>モーダルの例</h1>
      <Button label="モーダルを開く" onClick={handleOpen} />
      {isOpen && (
        <Modal onClose={handleClose}>
          <p>これはモーダルの内容です</p>
        </Modal>
      )}
    </div>
  )
}

export default App
```

```jsx
// src/Modal.jsx
function Modal({ children, onClose }) {
  return (
    <div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }}>
      <div style={{
        backgroundColor: 'white',
        padding: '20px',
        borderRadius: '8px'
      }}>
        {children}
        <button onClick={onClose}>閉じる</button>
      </div>
    </div>
  )
}

export default Modal
```

```jsx
// src/Button.jsx
function Button({ label, onClick }) {
  return <button onClick={onClick}>{label}</button>
}

export default Button
```
</details>

---

お疲れ様でした！次の章に進みましょう。

