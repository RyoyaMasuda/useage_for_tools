# 10-2. カスタムフックの型

この章では、TypeScriptでカスタムフックの型を定義する方法について学びます。カスタムフックに型を付けることで、型安全なコードを書けるようになります。

---

## 目次

- [カスタムフックの型とは](#カスタムフックの型とは)
- [基本的なカスタムフックの型定義](#基本的なカスタムフックの型定義)
- [引数と戻り値の型定義](#引数と戻り値の型定義)
- [実践例: 様々なカスタムフックの型](#実践例-様々なカスタムフックの型)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## カスタムフックの型とは

### カスタムフックとは
カスタムフックは、**ロジックを再利用するための関数**です。`use`で始まる名前を持ち、他のフックを使用できます。

### カスタムフックの型定義の重要性
- **型安全性**: 引数と戻り値の型を明示できる
- **エラー検出**: コンパイル時にエラーを発見できる
- **IDE支援**: コード補完や型チェックが向上
- **可読性**: 関数の仕様が明確になる

### 基本的な型定義

```typescript
function useCustomHook<T>(arg: T): ReturnType {
  // フックの実装
  return value
}
```

---

## 基本的なカスタムフックの型定義

### 基本的な型定義のパターン

```typescript
// 引数なし、戻り値あり
function useCounter(): { count: number; increment: () => void } {
  const [count, setCount] = useState<number>(0)
  
  const increment = () => {
    setCount(count + 1)
  }
  
  return { count, increment }
}

// 引数あり、戻り値あり
function useToggle(initialValue: boolean): [boolean, () => void] {
  const [value, setValue] = useState<boolean>(initialValue)
  
  const toggle = () => {
    setValue(!value)
  }
  
  return [value, toggle]
}
```

### 実践例: 基本的なカスタムフック

```typescript
// src/hooks/useCounter.ts
import { useState } from 'react'

interface UseCounterReturn {
  count: number
  increment: () => void
  decrement: () => void
  reset: () => void
}

function useCounter(initialValue: number = 0): UseCounterReturn {
  const [count, setCount] = useState<number>(initialValue)
  
  const increment = () => {
    setCount(count + 1)
  }
  
  const decrement = () => {
    setCount(count - 1)
  }
  
  const reset = () => {
    setCount(initialValue)
  }
  
  return { count, increment, decrement, reset }
}

export default useCounter
```

```typescript
// src/components/Counter.tsx
import useCounter from '../hooks/useCounter'

function Counter() {
  const { count, increment, decrement, reset } = useCounter(0)
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>増やす</button>
      <button onClick={decrement}>減らす</button>
      <button onClick={reset}>リセット</button>
    </div>
  )
}

export default Counter
```

---

## 引数と戻り値の型定義

### 引数の型定義

```typescript
// 単一の引数
function useInput(initialValue: string) {
  // ...
}

// 複数の引数
function useFetch<T>(url: string, options?: RequestInit) {
  // ...
}

// オブジェクト型の引数
interface UseFormOptions {
  initialValues: Record<string, any>
  onSubmit: (values: Record<string, any>) => void
}

function useForm(options: UseFormOptions) {
  // ...
}
```

### 戻り値の型定義

```typescript
// オブジェクト型の戻り値
interface UseToggleReturn {
  value: boolean
  toggle: () => void
  setTrue: () => void
  setFalse: () => void
}

function useToggle(initialValue: boolean): UseToggleReturn {
  // ...
}

// タプル型の戻り値
function useToggle(initialValue: boolean): [boolean, () => void] {
  // ...
}

// ジェネリクスを使用した戻り値
function useState<T>(initialValue: T): [T, (value: T) => void] {
  // ...
}
```

### 実践例: 引数と戻り値の型定義

```typescript
// src/hooks/useInput.ts
import { useState, ChangeEvent } from 'react'

interface UseInputReturn {
  value: string
  onChange: (e: ChangeEvent<HTMLInputElement>) => void
  reset: () => void
}

function useInput(initialValue: string = ''): UseInputReturn {
  const [value, setValue] = useState<string>(initialValue)
  
  const onChange = (e: ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value)
  }
  
  const reset = () => {
    setValue(initialValue)
  }
  
  return { value, onChange, reset }
}

export default useInput
```

```typescript
// src/components/Input.tsx
import useInput from '../hooks/useInput'

function Input() {
  const { value, onChange, reset } = useInput('')
  
  return (
    <div>
      <input value={value} onChange={onChange} />
      <button onClick={reset}>リセット</button>
    </div>
  )
}

export default Input
```

---

## 実践例: 様々なカスタムフックの型

### 実践例1: useToggleフック

```typescript
// src/hooks/useToggle.ts
import { useState } from 'react'

interface UseToggleReturn {
  value: boolean
  toggle: () => void
  setTrue: () => void
  setFalse: () => void
}

function useToggle(initialValue: boolean = false): UseToggleReturn {
  const [value, setValue] = useState<boolean>(initialValue)
  
  const toggle = () => {
    setValue(prev => !prev)
  }
  
  const setTrue = () => {
    setValue(true)
  }
  
  const setFalse = () => {
    setValue(false)
  }
  
  return { value, toggle, setTrue, setFalse }
}

export default useToggle
```

```typescript
// src/components/Toggle.tsx
import useToggle from '../hooks/useToggle'

function Toggle() {
  const { value, toggle, setTrue, setFalse } = useToggle(false)
  
  return (
    <div>
      <p>状態: {value ? 'ON' : 'OFF'}</p>
      <button onClick={toggle}>切り替え</button>
      <button onClick={setTrue}>ON</button>
      <button onClick={setFalse}>OFF</button>
    </div>
  )
}

export default Toggle
```

### 実践例2: useFetchフック

```typescript
// src/hooks/useFetch.ts
import { useState, useEffect } from 'react'

interface UseFetchReturn<T> {
  data: T | null
  loading: boolean
  error: Error | null
  refetch: () => void
}

function useFetch<T>(url: string): UseFetchReturn<T> {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState<boolean>(true)
  const [error, setError] = useState<Error | null>(null)
  
  const fetchData = async () => {
    try {
      setLoading(true)
      setError(null)
      const response = await fetch(url)
      if (!response.ok) {
        throw new Error('データの取得に失敗しました')
      }
      const json = await response.json()
      setData(json)
    } catch (err) {
      setError(err as Error)
    } finally {
      setLoading(false)
    }
  }
  
  useEffect(() => {
    fetchData()
  }, [url])
  
  return { data, loading, error, refetch: fetchData }
}

export default useFetch
```

```typescript
// src/components/UserList.tsx
import useFetch from '../hooks/useFetch'

interface User {
  id: number
  name: string
  email: string
}

function UserList() {
  const { data, loading, error, refetch } = useFetch<User[]>('/api/users')
  
  if (loading) return <p>読み込み中...</p>
  if (error) return <p>エラー: {error.message}</p>
  
  return (
    <div>
      <button onClick={refetch}>再取得</button>
      <ul>
        {data?.map(user => (
          <li key={user.id}>
            {user.name} - {user.email}
          </li>
        ))}
      </ul>
    </div>
  )
}

export default UserList
```

### 実践例3: useLocalStorageフック

```typescript
// src/hooks/useLocalStorage.ts
import { useState, useEffect } from 'react'

interface UseLocalStorageReturn<T> {
  value: T
  setValue: (value: T) => void
  removeValue: () => void
}

function useLocalStorage<T>(
  key: string,
  initialValue: T
): UseLocalStorageReturn<T> {
  const [value, setValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch {
      return initialValue
    }
  })
  
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value))
    } catch (error) {
      console.error('localStorageへの保存に失敗しました', error)
    }
  }, [key, value])
  
  const removeValue = () => {
    try {
      window.localStorage.removeItem(key)
      setValue(initialValue)
    } catch (error) {
      console.error('localStorageからの削除に失敗しました', error)
    }
  }
  
  return { value, setValue, removeValue }
}

export default useLocalStorage
```

```typescript
// src/components/Settings.tsx
import useLocalStorage from '../hooks/useLocalStorage'

interface Settings {
  theme: 'light' | 'dark'
  language: 'ja' | 'en'
}

function Settings() {
  const { value, setValue, removeValue } = useLocalStorage<Settings>(
    'settings',
    { theme: 'light', language: 'ja' }
  )
  
  return (
    <div>
      <div>
        <label>テーマ:</label>
        <select
          value={value.theme}
          onChange={(e) =>
            setValue({ ...value, theme: e.target.value as 'light' | 'dark' })
          }
        >
          <option value="light">ライト</option>
          <option value="dark">ダーク</option>
        </select>
      </div>
      <div>
        <label>言語:</label>
        <select
          value={value.language}
          onChange={(e) =>
            setValue({ ...value, language: e.target.value as 'ja' | 'en' })
          }
        >
          <option value="ja">日本語</option>
          <option value="en">English</option>
        </select>
      </div>
      <button onClick={removeValue}>リセット</button>
    </div>
  )
}

export default Settings
```

### 実践例4: useDebounceフック

```typescript
// src/hooks/useDebounce.ts
import { useState, useEffect } from 'react'

function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value)
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)
    
    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])
  
  return debouncedValue
}

export default useDebounce
```

```typescript
// src/components/Search.tsx
import { useState } from 'react'
import useDebounce from '../hooks/useDebounce'

function Search() {
  const [query, setQuery] = useState<string>('')
  const debouncedQuery = useDebounce<string>(query, 500)
  
  // debouncedQueryが変更されたときに検索を実行
  useEffect(() => {
    if (debouncedQuery) {
      console.log('検索:', debouncedQuery)
      // 検索APIを呼び出す
    }
  }, [debouncedQuery])
  
  return (
    <input
      type="text"
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="検索..."
    />
  )
}

export default Search
```

### 実践例5: useClickOutsideフック

```typescript
// src/hooks/useClickOutside.ts
import { useEffect, RefObject } from 'react'

function useClickOutside<T extends HTMLElement>(
  ref: RefObject<T>,
  handler: () => void
): void {
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (ref.current && !ref.current.contains(event.target as Node)) {
        handler()
      }
    }
    
    document.addEventListener('mousedown', handleClickOutside)
    
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [ref, handler])
}

export default useClickOutside
```

```typescript
// src/components/Dropdown.tsx
import { useRef, useState } from 'react'
import useClickOutside from '../hooks/useClickOutside'

function Dropdown() {
  const [isOpen, setIsOpen] = useState<boolean>(false)
  const dropdownRef = useRef<HTMLDivElement>(null)
  
  useClickOutside(dropdownRef, () => {
    setIsOpen(false)
  })
  
  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>
        メニュー
      </button>
      {isOpen && (
        <div>
          <ul>
            <li>項目1</li>
            <li>項目2</li>
            <li>項目3</li>
          </ul>
        </div>
      )}
    </div>
  )
}

export default Dropdown
```

### 実践例6: useFormフック

```typescript
// src/hooks/useForm.ts
import { useState, ChangeEvent, FormEvent } from 'react'

interface UseFormReturn<T> {
  values: T
  errors: Partial<Record<keyof T, string>>
  handleChange: (e: ChangeEvent<HTMLInputElement>) => void
  handleSubmit: (e: FormEvent) => void
  reset: () => void
}

function useForm<T extends Record<string, any>>(
  initialValues: T,
  onSubmit: (values: T) => void
): UseFormReturn<T> {
  const [values, setValues] = useState<T>(initialValues)
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({})
  
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target
    setValues({
      ...values,
      [name]: value
    })
    // エラーをクリア
    if (errors[name as keyof T]) {
      setErrors({
        ...errors,
        [name]: undefined
      })
    }
  }
  
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    // バリデーション
    const newErrors: Partial<Record<keyof T, string>> = {}
    Object.keys(values).forEach(key => {
      if (!values[key]) {
        newErrors[key as keyof T] = `${key}は必須です`
      }
    })
    
    if (Object.keys(newErrors).length > 0) {
      setErrors(newErrors)
      return
    }
    
    onSubmit(values)
  }
  
  const reset = () => {
    setValues(initialValues)
    setErrors({})
  }
  
  return { values, errors, handleChange, handleSubmit, reset }
}

export default useForm
```

```typescript
// src/components/ContactForm.tsx
import useForm from '../hooks/useForm'

interface FormValues {
  name: string
  email: string
  message: string
}

function ContactForm() {
  const { values, errors, handleChange, handleSubmit, reset } = useForm<FormValues>(
    { name: '', email: '', message: '' },
    (values) => {
      console.log('送信:', values)
      // フォーム送信処理
    }
  )
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <input
          name="name"
          value={values.name}
          onChange={handleChange}
          placeholder="名前"
        />
        {errors.name && <span style={{ color: 'red' }}>{errors.name}</span>}
      </div>
      <div>
        <input
          name="email"
          type="email"
          value={values.email}
          onChange={handleChange}
          placeholder="メールアドレス"
        />
        {errors.email && <span style={{ color: 'red' }}>{errors.email}</span>}
      </div>
      <div>
        <textarea
          name="message"
          value={values.message}
          onChange={handleChange}
          placeholder="メッセージ"
        />
        {errors.message && <span style={{ color: 'red' }}>{errors.message}</span>}
      </div>
      <button type="submit">送信</button>
      <button type="button" onClick={reset}>リセット</button>
    </form>
  )
}

export default ContactForm
```

---

## まとめ

この章では、TypeScriptでカスタムフックの型を定義する方法について学びました。

### 学んだこと
- カスタムフックの型定義: 引数と戻り値の型を明示
- 基本的な型定義: インターフェースや型エイリアスを使用
- ジェネリクス: 汎用的な型定義
- 実践例: 様々なカスタムフックの型定義

### 重要なポイント
1. **型定義**: 引数と戻り値の型を明示する
2. **インターフェース**: 複雑な戻り値にはインターフェースを使用
3. **ジェネリクス**: 汎用的な型定義に使用
4. **型安全性**: コンパイル時にエラーを検出できる

### 次のステップ
次の章では、型安全な開発について詳しく学びます。

---

## 演習問題

### 問題1: useCounterフックの型定義
`useCounter`フックに型を定義してください。

<details>
<summary>解答例</summary>

```typescript
// src/hooks/useCounter.ts
import { useState } from 'react'

interface UseCounterReturn {
  count: number
  increment: () => void
  decrement: () => void
}

function useCounter(initialValue: number = 0): UseCounterReturn {
  const [count, setCount] = useState<number>(initialValue)
  
  const increment = () => setCount(count + 1)
  const decrement = () => setCount(count - 1)
  
  return { count, increment, decrement }
}

export default useCounter
```
</details>

### 問題2: useInputフックの型定義
`useInput`フックに型を定義してください。

<details>
<summary>解答例</summary>

```typescript
// src/hooks/useInput.ts
import { useState, ChangeEvent } from 'react'

interface UseInputReturn {
  value: string
  onChange: (e: ChangeEvent<HTMLInputElement>) => void
  reset: () => void
}

function useInput(initialValue: string = ''): UseInputReturn {
  const [value, setValue] = useState<string>(initialValue)
  
  const onChange = (e: ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value)
  }
  
  const reset = () => {
    setValue(initialValue)
  }
  
  return { value, onChange, reset }
}

export default useInput
```
</details>

### 問題3: useToggleフックの型定義
`useToggle`フックに型を定義してください。

<details>
<summary>解答例</summary>

```typescript
// src/hooks/useToggle.ts
import { useState } from 'react'

interface UseToggleReturn {
  value: boolean
  toggle: () => void
}

function useToggle(initialValue: boolean = false): UseToggleReturn {
  const [value, setValue] = useState<boolean>(initialValue)
  
  const toggle = () => {
    setValue(prev => !prev)
  }
  
  return { value, toggle }
}

export default useToggle
```
</details>

### 問題4: ジェネリクスを使用したフック
ジェネリクスを使用して、任意の型の値を扱える`useState`風のフックを作成してください。

<details>
<summary>解答例</summary>

```typescript
// src/hooks/useValue.ts
import { useState } from 'react'

interface UseValueReturn<T> {
  value: T
  setValue: (value: T) => void
  reset: () => void
}

function useValue<T>(initialValue: T): UseValueReturn<T> {
  const [value, setValue] = useState<T>(initialValue)
  
  const reset = () => {
    setValue(initialValue)
  }
  
  return { value, setValue, reset }
}

export default useValue
```
</details>

### 問題5: useFetchフックの型定義
`useFetch`フックにジェネリクスを使用して型を定義してください。

<details>
<summary>解答例</summary>

```typescript
// src/hooks/useFetch.ts
import { useState, useEffect } from 'react'

interface UseFetchReturn<T> {
  data: T | null
  loading: boolean
  error: Error | null
}

function useFetch<T>(url: string): UseFetchReturn<T> {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState<boolean>(true)
  const [error, setError] = useState<Error | null>(null)
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true)
        const response = await fetch(url)
        const json = await response.json()
        setData(json)
      } catch (err) {
        setError(err as Error)
      } finally {
        setLoading(false)
      }
    }
    
    fetchData()
  }, [url])
  
  return { data, loading, error }
}

export default useFetch
```
</details>

---

お疲れ様でした！次の章に進みましょう。

