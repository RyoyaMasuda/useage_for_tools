# 11-2. コンポーネントのレンダリングテスト

この章では、React Testing Libraryを使用したコンポーネントのレンダリングテストについて学びます。コンポーネントのテストを理解することで、Reactアプリケーションの品質を向上させることができます。

---

## 目次

- [React Testing Libraryとは](#react-testing-libraryとは)
- [コンポーネントのレンダリング](#コンポーネントのレンダリング)
- [要素の取得方法](#要素の取得方法)
- [アサーション（検証）](#アサーション検証)
- [ユーザー操作のシミュレーション](#ユーザー操作のシミュレーション)
- [非同期処理のテスト](#非同期処理のテスト)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## React Testing Libraryとは

### React Testing Libraryの特徴

React Testing Libraryは、**ユーザーの視点に立ったテスト**を書くためのライブラリです。コンポーネントの実装の詳細ではなく、ユーザーが実際に操作する要素に焦点を当てます。

### React Testing Libraryの主な特徴

- **ユーザー中心**: ユーザーが実際に操作する要素をテスト
- **アクセシビリティ重視**: アクセシビリティに配慮した要素の取得
- **シンプルなAPI**: 直感的で使いやすいAPI
- **実装の詳細を隠蔽**: コンポーネントの内部実装に依存しない

### テストの考え方

```javascript
// ❌ 悪い例: 実装の詳細をテスト
it('useStateが呼ばれる', () => {
  // 内部実装に依存している
})

// ✅ 良い例: ユーザーの視点でテスト
it('ボタンをクリックするとカウントが増える', () => {
  // ユーザーが実際に行う操作をテスト
})
```

---

## コンポーネントのレンダリング

### render関数の基本

`render`関数を使用してコンポーネントをレンダリングします。

```javascript
import { render } from '@testing-library/react'
import Button from './Button'

it('ボタンがレンダリングされる', () => {
  render(<Button label="クリック" />)
})
```

### TypeScriptでの使用

```typescript
import { render } from '@testing-library/react'
import Button from './Button'

it('ボタンがレンダリングされる', () => {
  render(<Button label="クリック" />)
})
```

### 実践例: 基本的なレンダリング

```javascript
// src/components/Button.test.jsx
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import Button from './Button'

describe('Button', () => {
  it('ボタンがレンダリングされる', () => {
    render(<Button label="クリック" />)
    // コンポーネントがエラーなくレンダリングされることを確認
  })
})
```

---

## 要素の取得方法

### screenオブジェクト

`screen`オブジェクトを使用して、レンダリングされた要素を取得します。

```javascript
import { render, screen } from '@testing-library/react'
```

### 主な取得メソッド

#### getByText: テキストで取得

```javascript
// 完全一致
screen.getByText('クリック')

// 部分一致（正規表現）
screen.getByText(/クリック/)

// 部分一致（関数）
screen.getByText((content, element) => {
  return element.tagName.toLowerCase() === 'button'
})
```

#### getByRole: ロールで取得

```javascript
// ボタン要素を取得
screen.getByRole('button')

// 特定の名前のボタン
screen.getByRole('button', { name: 'クリック' })

// リンク要素を取得
screen.getByRole('link', { name: 'ホーム' })
```

#### getByLabelText: ラベルで取得

```javascript
// ラベルテキストで取得
screen.getByLabelText('ユーザー名')

// 部分一致
screen.getByLabelText(/ユーザー/)
```

#### getByPlaceholderText: プレースホルダーで取得

```javascript
screen.getByPlaceholderText('メールアドレスを入力')
```

#### getByTestId: テストIDで取得

```javascript
// データ属性で取得（最後の手段として使用）
screen.getByTestId('submit-button')
```

### 複数要素の取得

複数の要素を取得する場合は、`getAllBy`を使用します。

```javascript
// 複数のボタンを取得
const buttons = screen.getAllByRole('button')

// 配列の要素にアクセス
expect(buttons[0]).toBeInTheDocument()
```

### 要素が存在しないことの確認

要素が存在しないことを確認する場合は、`queryBy`を使用します。

```javascript
// 要素が存在しない場合、nullを返す
const element = screen.queryByText('存在しないテキスト')
expect(element).not.toBeInTheDocument()
```

### 実践例: 要素の取得

```javascript
// src/components/LoginForm.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import LoginForm from './LoginForm'

describe('LoginForm', () => {
  it('フォーム要素がレンダリングされる', () => {
    render(<LoginForm />)
    
    // テキストで取得
    expect(screen.getByText('ログイン')).toBeInTheDocument()
    
    // ロールで取得
    expect(screen.getByRole('button', { name: '送信' })).toBeInTheDocument()
    
    // ラベルで取得
    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument()
    expect(screen.getByLabelText('パスワード')).toBeInTheDocument()
  })
})
```

---

## アサーション（検証）

### jest-domのマッチャー

`@testing-library/jest-dom`を使用すると、便利なマッチャーが利用できます。

### 主なマッチャー

#### toBeInTheDocument: ドキュメントに存在する

```javascript
expect(screen.getByText('クリック')).toBeInTheDocument()
```

#### toBeVisible: 要素が表示されている

```javascript
expect(screen.getByText('クリック')).toBeVisible()
```

#### toHaveTextContent: テキストコンテンツを確認

```javascript
expect(screen.getByRole('button')).toHaveTextContent('クリック')
```

#### toHaveClass: クラス名を確認

```javascript
expect(screen.getByRole('button')).toHaveClass('primary')
```

#### toHaveAttribute: 属性を確認

```javascript
expect(screen.getByRole('button')).toHaveAttribute('type', 'submit')
```

#### toBeDisabled: 無効化されている

```javascript
expect(screen.getByRole('button')).toBeDisabled()
```

#### toBeEnabled: 有効化されている

```javascript
expect(screen.getByRole('button')).toBeEnabled()
```

### 実践例: アサーション

```javascript
// src/components/Button.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Button from './Button'

describe('Button', () => {
  it('ボタンの属性が正しい', () => {
    render(<Button label="クリック" type="submit" disabled={false} />)
    
    const button = screen.getByRole('button', { name: 'クリック' })
    
    expect(button).toBeInTheDocument()
    expect(button).toBeVisible()
    expect(button).toHaveTextContent('クリック')
    expect(button).toHaveAttribute('type', 'submit')
    expect(button).toBeEnabled()
  })
  
  it('無効化されたボタンが正しく表示される', () => {
    render(<Button label="クリック" disabled={true} />)
    
    const button = screen.getByRole('button', { name: 'クリック' })
    expect(button).toBeDisabled()
  })
})
```

---

## ユーザー操作のシミュレーション

### user-eventの使用

`@testing-library/user-event`を使用して、ユーザー操作をシミュレーションします。

### user-eventのセットアップ

```javascript
import userEvent from '@testing-library/user-event'

// ユーザーインスタンスを作成
const user = userEvent.setup()
```

### 主な操作メソッド

#### click: クリック

```javascript
const user = userEvent.setup()
const button = screen.getByRole('button')
await user.click(button)
```

#### type: テキスト入力

```javascript
const user = userEvent.setup()
const input = screen.getByLabelText('ユーザー名')
await user.type(input, 'テストユーザー')
```

#### clear: 入力のクリア

```javascript
const user = userEvent.setup()
const input = screen.getByLabelText('ユーザー名')
await user.clear(input)
```

#### selectOptions: セレクトボックスの選択

```javascript
const user = userEvent.setup()
const select = screen.getByLabelText('都道府県')
await user.selectOptions(select, '東京')
```

#### check / uncheck: チェックボックスの操作

```javascript
const user = userEvent.setup()
const checkbox = screen.getByLabelText('同意する')
await user.click(checkbox) // チェック
await user.click(checkbox) // チェック解除
```

### 実践例: ユーザー操作のシミュレーション

```javascript
// src/components/Counter.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Counter from './Counter'

describe('Counter', () => {
  it('増やすボタンをクリックするとカウントが増える', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    // 初期値の確認
    expect(screen.getByText('カウント: 0')).toBeInTheDocument()
    
    // ボタンをクリック
    const incrementButton = screen.getByRole('button', { name: '増やす' })
    await user.click(incrementButton)
    
    // カウントが増えたことを確認
    expect(screen.getByText('カウント: 1')).toBeInTheDocument()
  })
  
  it('減らすボタンをクリックするとカウントが減る', async () => {
    const user = userEvent.setup()
    render(<Counter initialCount={5} />)
    
    expect(screen.getByText('カウント: 5')).toBeInTheDocument()
    
    const decrementButton = screen.getByRole('button', { name: '減らす' })
    await user.click(decrementButton)
    
    expect(screen.getByText('カウント: 4')).toBeInTheDocument()
  })
})
```

### 実践例: フォーム入力のテスト

```javascript
// src/components/LoginForm.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import LoginForm from './LoginForm'

describe('LoginForm', () => {
  it('フォームに入力して送信できる', async () => {
    const user = userEvent.setup()
    const handleSubmit = vi.fn()
    
    render(<LoginForm onSubmit={handleSubmit} />)
    
    // 入力フィールドに値を入力
    const emailInput = screen.getByLabelText('メールアドレス')
    const passwordInput = screen.getByLabelText('パスワード')
    
    await user.type(emailInput, 'test@example.com')
    await user.type(passwordInput, 'password123')
    
    // 入力値が反映されていることを確認
    expect(emailInput).toHaveValue('test@example.com')
    expect(passwordInput).toHaveValue('password123')
    
    // 送信ボタンをクリック
    const submitButton = screen.getByRole('button', { name: '送信' })
    await user.click(submitButton)
    
    // 送信関数が呼ばれたことを確認
    expect(handleSubmit).toHaveBeenCalledWith({
      email: 'test@example.com',
      password: 'password123',
    })
  })
})
```

---

## 非同期処理のテスト

### waitFor: 非同期更新の待機

`waitFor`を使用して、非同期で更新される要素を待機します。

```javascript
import { waitFor } from '@testing-library/react'

await waitFor(() => {
  expect(screen.getByText('読み込み完了')).toBeInTheDocument()
})
```

### findBy: 非同期要素の取得

`findBy`を使用して、非同期で表示される要素を取得します。

```javascript
// 要素が表示されるまで待機
const message = await screen.findByText('読み込み完了')
expect(message).toBeInTheDocument()
```

### 実践例: 非同期処理のテスト

```javascript
// src/components/DataLoader.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import DataLoader from './DataLoader'

describe('DataLoader', () => {
  it('データが読み込まれる', async () => {
    // APIのモック
    global.fetch = vi.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({ data: 'テストデータ' }),
      })
    )
    
    render(<DataLoader />)
    
    // ローディング表示を確認
    expect(screen.getByText('読み込み中...')).toBeInTheDocument()
    
    // データが表示されるまで待機
    await waitFor(() => {
      expect(screen.getByText('テストデータ')).toBeInTheDocument()
    })
    
    // ローディング表示が消えたことを確認
    expect(screen.queryByText('読み込み中...')).not.toBeInTheDocument()
  })
  
  it('エラーが表示される', async () => {
    // エラーを返すAPIのモック
    global.fetch = vi.fn(() => Promise.reject(new Error('ネットワークエラー')))
    
    render(<DataLoader />)
    
    // エラーメッセージが表示されるまで待機
    await waitFor(() => {
      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument()
    })
  })
})
```

### 実践例: findByを使用したテスト

```javascript
// src/components/UserProfile.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import UserProfile from './UserProfile'

describe('UserProfile', () => {
  it('ユーザー情報が表示される', async () => {
    global.fetch = vi.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({ name: '山田太郎', email: 'yamada@example.com' }),
      })
    )
    
    render(<UserProfile userId="1" />)
    
    // findByを使用して非同期要素を取得
    const name = await screen.findByText('山田太郎')
    const email = await screen.findByText('yamada@example.com')
    
    expect(name).toBeInTheDocument()
    expect(email).toBeInTheDocument()
  })
})
```

---

## まとめ

この章では、React Testing Libraryを使用したコンポーネントのレンダリングテストについて学びました。

### 学んだこと

- React Testing Library: ユーザー中心のテストライブラリ
- レンダリング: `render`関数でコンポーネントをレンダリング
- 要素の取得: `screen`オブジェクトで要素を取得
- アサーション: `jest-dom`のマッチャーで検証
- ユーザー操作: `user-event`で操作をシミュレーション
- 非同期処理: `waitFor`や`findBy`で非同期更新をテスト

### 重要なポイント

1. **ユーザー中心のテスト**: 実装の詳細ではなく、ユーザーの視点でテスト
2. **要素の取得**: `getByRole`を優先的に使用（アクセシビリティ重視）
3. **ユーザー操作**: `user-event`で実際のユーザー操作をシミュレーション
4. **非同期処理**: `waitFor`や`findBy`で非同期更新を適切に待機
5. **アサーション**: `jest-dom`のマッチャーで直感的に検証

### 次のステップ

次の章では、モックと非同期テストについて詳しく学びます。

---

## 演習問題

### 問題1: 基本的なレンダリングテスト

`Button`コンポーネントが正しくレンダリングされることを確認するテストを作成してください。

<details>
<summary>解答例</summary>

```javascript
// src/components/Button.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Button from './Button'

describe('Button', () => {
  it('ボタンがレンダリングされる', () => {
    render(<Button label="クリック" />)
    expect(screen.getByRole('button', { name: 'クリック' })).toBeInTheDocument()
  })
})
```
</details>

### 問題2: 要素の取得とアサーション

`LoginForm`コンポーネントのフォーム要素が正しく表示されることを確認するテストを作成してください。

<details>
<summary>解答例</summary>

```javascript
// src/components/LoginForm.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import LoginForm from './LoginForm'

describe('LoginForm', () => {
  it('フォーム要素がレンダリングされる', () => {
    render(<LoginForm />)
    
    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument()
    expect(screen.getByLabelText('パスワード')).toBeInTheDocument()
    expect(screen.getByRole('button', { name: '送信' })).toBeInTheDocument()
  })
})
```
</details>

### 問題3: ユーザー操作のシミュレーション

`Counter`コンポーネントで、ボタンをクリックしてカウントが増減することを確認するテストを作成してください。

<details>
<summary>解答例</summary>

```javascript
// src/components/Counter.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Counter from './Counter'

describe('Counter', () => {
  it('増やすボタンをクリックするとカウントが増える', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    expect(screen.getByText('カウント: 0')).toBeInTheDocument()
    
    const incrementButton = screen.getByRole('button', { name: '増やす' })
    await user.click(incrementButton)
    
    expect(screen.getByText('カウント: 1')).toBeInTheDocument()
  })
  
  it('減らすボタンをクリックするとカウントが減る', async () => {
    const user = userEvent.setup()
    render(<Counter initialCount={5} />)
    
    const decrementButton = screen.getByRole('button', { name: '減らす' })
    await user.click(decrementButton)
    
    expect(screen.getByText('カウント: 4')).toBeInTheDocument()
  })
})
```
</details>

### 問題4: フォーム入力のテスト

`ContactForm`コンポーネントで、フォームに入力して送信できることを確認するテストを作成してください。

<details>
<summary>解答例</summary>

```javascript
// src/components/ContactForm.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import ContactForm from './ContactForm'

describe('ContactForm', () => {
  it('フォームに入力して送信できる', async () => {
    const user = userEvent.setup()
    const handleSubmit = vi.fn()
    
    render(<ContactForm onSubmit={handleSubmit} />)
    
    await user.type(screen.getByLabelText('名前'), '山田太郎')
    await user.type(screen.getByLabelText('メールアドレス'), 'yamada@example.com')
    await user.type(screen.getByLabelText('メッセージ'), 'テストメッセージ')
    
    await user.click(screen.getByRole('button', { name: '送信' }))
    
    expect(handleSubmit).toHaveBeenCalledWith({
      name: '山田太郎',
      email: 'yamada@example.com',
      message: 'テストメッセージ',
    })
  })
})
```
</details>

### 問題5: 非同期処理のテスト

`DataLoader`コンポーネントで、データが非同期で読み込まれることを確認するテストを作成してください。

<details>
<summary>解答例</summary>

```javascript
// src/components/DataLoader.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import DataLoader from './DataLoader'

describe('DataLoader', () => {
  it('データが読み込まれる', async () => {
    global.fetch = vi.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({ data: 'テストデータ' }),
      })
    )
    
    render(<DataLoader />)
    
    expect(screen.getByText('読み込み中...')).toBeInTheDocument()
    
    await waitFor(() => {
      expect(screen.getByText('テストデータ')).toBeInTheDocument()
    })
    
    expect(screen.queryByText('読み込み中...')).not.toBeInTheDocument()
  })
})
```
</details>

---

お疲れ様でした！次の章に進みましょう。

