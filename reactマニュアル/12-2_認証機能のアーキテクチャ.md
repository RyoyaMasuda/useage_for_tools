# 12-2. 認証機能のアーキテクチャ

この章では、Reactアプリケーションでの認証機能のアーキテクチャについて学びます。ログイン状態の永続化と復元、保護されたルート（PrivateRoute）の実装、認証コンテキストの設計について学びます。認証機能を理解することで、セキュアで使いやすいReactアプリケーションを作成できるようになります。

---

## 目次

- [ログイン状態の永続化と復元](#ログイン状態の永続化と復元)
- [PrivateRoute (保護されたルート) の実装](#privateroute-保護されたルート-の実装)
- [認証コンテキストの設計](#認証コンテキストの設計)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## ログイン状態の永続化と復元

### ログイン状態の永続化とは
ログイン状態の永続化は、**ユーザーがログインした状態をブラウザに保存し、ページをリロードしても状態を維持する**機能です。

### 日常生活での例
- **ログイン状態の保存**: 一度ログインすると、次回訪問時に自動的にログイン状態が復元される
- **セッション管理**: 一定時間ログイン状態を維持する
- **認証トークンの保存**: 認証トークンを保存して、APIリクエストに使用する

### ローカルストレージを使った永続化

#### 基本的な実装

```typescript
// src/utils/storage.ts
export const storage = {
    set: (key: string, value: string) => {
        localStorage.setItem(key, value);
    },
    get: (key: string): string | null => {
        return localStorage.getItem(key);
    },
    remove: (key: string) => {
        localStorage.removeItem(key);
    },
    clear: () => {
        localStorage.clear();
    }
};

// src/types/auth.ts
export interface AuthUser {
    id: string;
    email: string;
    name: string;
}

export interface AuthState {
    user: AuthUser | null;
    token: string | null;
    isAuthenticated: boolean;
}
```

#### 認証状態の保存と復元

```typescript
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { AuthState, AuthUser } from '../types/auth';
import { storage } from '../utils/storage';

interface AuthContextType extends AuthState {
    login: (email: string, password: string) => Promise<void>;
    logout: () => void;
    isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<AuthUser | null>(null);
    const [token, setToken] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    
    // 初期化時にローカルストレージから状態を復元
    useEffect(() => {
        const savedToken = storage.get('token');
        const savedUser = storage.get('user');
        
        if (savedToken && savedUser) {
            try {
                setToken(savedToken);
                setUser(JSON.parse(savedUser));
            } catch (error) {
                console.error('状態の復元に失敗しました:', error);
                storage.remove('token');
                storage.remove('user');
            }
        }
        
        setIsLoading(false);
    }, []);
    
    const login = async (email: string, password: string) => {
        // ログインAPIを呼び出す（実際の実装ではAPIを呼び出す）
        const response = await fetch('/api/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
        });
        
        const data = await response.json();
        
        if (response.ok) {
            const { user: userData, token: authToken } = data;
            
            // 状態を更新
            setUser(userData);
            setToken(authToken);
            
            // ローカルストレージに保存
            storage.set('token', authToken);
            storage.set('user', JSON.stringify(userData));
        } else {
            throw new Error(data.message || 'ログインに失敗しました');
        }
    };
    
    const logout = () => {
        // 状態をクリア
        setUser(null);
        setToken(null);
        
        // ローカルストレージから削除
        storage.remove('token');
        storage.remove('user');
    };
    
    const value: AuthContextType = {
        user,
        token,
        isAuthenticated: !!user && !!token,
        login,
        logout,
        isLoading
    };
    
    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuthはAuthProvider内で使用する必要があります');
    }
    return context;
};
```

### 実践例: ログイン状態の永続化と復元

```typescript
// src/types/auth.ts
export interface AuthUser {
    id: string;
    email: string;
    name: string;
    role: 'admin' | 'user';
}

export interface LoginCredentials {
    email: string;
    password: string;
}

export interface AuthResponse {
    user: AuthUser;
    token: string;
    expiresIn: number;
}

// src/utils/storage.ts
export const storage = {
    set: (key: string, value: string) => {
        try {
            localStorage.setItem(key, value);
        } catch (error) {
            console.error('ストレージへの保存に失敗しました:', error);
        }
    },
    
    get: (key: string): string | null => {
        try {
            return localStorage.getItem(key);
        } catch (error) {
            console.error('ストレージからの取得に失敗しました:', error);
            return null;
        }
    },
    
    remove: (key: string) => {
        try {
            localStorage.removeItem(key);
        } catch (error) {
            console.error('ストレージからの削除に失敗しました:', error);
        }
    },
    
    clear: () => {
        try {
            localStorage.clear();
        } catch (error) {
            console.error('ストレージのクリアに失敗しました:', error);
        }
    }
};

// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { AuthUser, LoginCredentials, AuthResponse } from '../types/auth';
import { storage } from '../utils/storage';

interface AuthContextType {
    user: AuthUser | null;
    token: string | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    login: (credentials: LoginCredentials) => Promise<void>;
    logout: () => void;
    refreshToken: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const STORAGE_KEYS = {
    TOKEN: 'auth_token',
    USER: 'auth_user',
    EXPIRES_AT: 'auth_expires_at'
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<AuthUser | null>(null);
    const [token, setToken] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    
    // 状態の復元
    useEffect(() => {
        const restoreAuth = async () => {
            try {
                const savedToken = storage.get(STORAGE_KEYS.TOKEN);
                const savedUser = storage.get(STORAGE_KEYS.USER);
                const expiresAt = storage.get(STORAGE_KEYS.EXPIRES_AT);
                
                if (savedToken && savedUser && expiresAt) {
                    // トークンの有効期限をチェック
                    const expirationTime = parseInt(expiresAt, 10);
                    const now = Date.now();
                    
                    if (now < expirationTime) {
                        // トークンが有効
                        setToken(savedToken);
                        setUser(JSON.parse(savedUser));
                    } else {
                        // トークンが期限切れ
                        clearAuth();
                    }
                }
            } catch (error) {
                console.error('認証状態の復元に失敗しました:', error);
                clearAuth();
            } finally {
                setIsLoading(false);
            }
        };
        
        restoreAuth();
    }, []);
    
    // 認証情報のクリア
    const clearAuth = useCallback(() => {
        setUser(null);
        setToken(null);
        storage.remove(STORAGE_KEYS.TOKEN);
        storage.remove(STORAGE_KEYS.USER);
        storage.remove(STORAGE_KEYS.EXPIRES_AT);
    }, []);
    
    // ログイン
    const login = useCallback(async (credentials: LoginCredentials) => {
        try {
            // 実際のAPIを呼び出す
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(credentials)
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.message || 'ログインに失敗しました');
            }
            
            const data: AuthResponse = await response.json();
            const expiresAt = Date.now() + data.expiresIn * 1000;
            
            // 状態を更新
            setUser(data.user);
            setToken(data.token);
            
            // ローカルストレージに保存
            storage.set(STORAGE_KEYS.TOKEN, data.token);
            storage.set(STORAGE_KEYS.USER, JSON.stringify(data.user));
            storage.set(STORAGE_KEYS.EXPIRES_AT, expiresAt.toString());
        } catch (error) {
            console.error('ログインエラー:', error);
            throw error;
        }
    }, []);
    
    // ログアウト
    const logout = useCallback(() => {
        clearAuth();
    }, [clearAuth]);
    
    // トークンのリフレッシュ
    const refreshToken = useCallback(async () => {
        try {
            const currentToken = storage.get(STORAGE_KEYS.TOKEN);
            if (!currentToken) {
                throw new Error('トークンがありません');
            }
            
            const response = await fetch('/api/auth/refresh', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${currentToken}`
                }
            });
            
            if (!response.ok) {
                throw new Error('トークンのリフレッシュに失敗しました');
            }
            
            const data: AuthResponse = await response.json();
            const expiresAt = Date.now() + data.expiresIn * 1000;
            
            setToken(data.token);
            storage.set(STORAGE_KEYS.TOKEN, data.token);
            storage.set(STORAGE_KEYS.EXPIRES_AT, expiresAt.toString());
        } catch (error) {
            console.error('トークンリフレッシュエラー:', error);
            clearAuth();
            throw error;
        }
    }, [clearAuth]);
    
    const value: AuthContextType = {
        user,
        token,
        isAuthenticated: !!user && !!token,
        isLoading,
        login,
        logout,
        refreshToken
    };
    
    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuthはAuthProvider内で使用する必要があります');
    }
    return context;
};
```

---

## PrivateRoute (保護されたルート) の実装

### PrivateRouteとは
PrivateRouteは、**認証が必要なページへのアクセスを制御するコンポーネント**です。未認証のユーザーはログインページにリダイレクトされます。

### 基本的な実装

```typescript
// src/components/PrivateRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface PrivateRouteProps {
    children: React.ReactNode;
}

export const PrivateRoute: React.FC<PrivateRouteProps> = ({ children }) => {
    const { isAuthenticated, isLoading } = useAuth();
    
    if (isLoading) {
        return <div>読み込み中...</div>;
    }
    
    if (!isAuthenticated) {
        return <Navigate to="/login" replace />;
    }
    
    return <>{children}</>;
};
```

### 実践例: PrivateRouteの実装

```typescript
// src/components/PrivateRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface PrivateRouteProps {
    children: React.ReactNode;
    requiredRole?: 'admin' | 'user';
}

export const PrivateRoute: React.FC<PrivateRouteProps> = ({ 
    children, 
    requiredRole 
}) => {
    const { isAuthenticated, isLoading, user } = useAuth();
    const location = useLocation();
    
    // ローディング中
    if (isLoading) {
        return (
            <div style={{ 
                display: 'flex', 
                justifyContent: 'center', 
                alignItems: 'center', 
                height: '100vh' 
            }}>
                <div>読み込み中...</div>
            </div>
        );
    }
    
    // 未認証の場合、ログインページにリダイレクト
    if (!isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }
    
    // ロールチェック
    if (requiredRole && user?.role !== requiredRole && user?.role !== 'admin') {
        return <Navigate to="/unauthorized" replace />;
    }
    
    return <>{children}</>;
};

// src/App.tsx
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { PrivateRoute } from './components/PrivateRoute';
import { LoginPage } from './pages/LoginPage';
import { DashboardPage } from './pages/DashboardPage';
import { AdminPage } from './pages/AdminPage';
import { PublicPage } from './pages/PublicPage';

function App() {
    return (
        <AuthProvider>
            <BrowserRouter>
                <Routes>
                    {/* 公開ページ */}
                    <Route path="/" element={<PublicPage />} />
                    <Route path="/login" element={<LoginPage />} />
                    
                    {/* 保護されたページ */}
                    <Route
                        path="/dashboard"
                        element={
                            <PrivateRoute>
                                <DashboardPage />
                            </PrivateRoute>
                        }
                    />
                    
                    {/* 管理者専用ページ */}
                    <Route
                        path="/admin"
                        element={
                            <PrivateRoute requiredRole="admin">
                                <AdminPage />
                            </PrivateRoute>
                        }
                    />
                    
                    {/* 404ページ */}
                    <Route path="*" element={<Navigate to="/" replace />} />
                </Routes>
            </BrowserRouter>
        </AuthProvider>
    );
}

export default App;
```

### ログインページでのリダイレクト処理

```typescript
// src/pages/LoginPage.tsx
import React, { useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

export const LoginPage: React.FC = () => {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    
    const { login, isAuthenticated } = useAuth();
    const navigate = useNavigate();
    const location = useLocation();
    
    // 既にログインしている場合はリダイレクト
    React.useEffect(() => {
        if (isAuthenticated) {
            const from = (location.state as { from?: Location })?.from;
            navigate(from?.pathname || '/dashboard', { replace: true });
        }
    }, [isAuthenticated, navigate, location]);
    
    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setError('');
        setIsLoading(true);
        
        try {
            await login({ email, password });
            const from = (location.state as { from?: Location })?.from;
            navigate(from?.pathname || '/dashboard', { replace: true });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'ログインに失敗しました');
        } finally {
            setIsLoading(false);
        }
    };
    
    return (
        <div style={{ maxWidth: '400px', margin: '50px auto' }}>
            <h1>ログイン</h1>
            <form onSubmit={handleSubmit}>
                <div>
                    <label>メールアドレス</label>
                    <input
                        type="email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        required
                    />
                </div>
                <div>
                    <label>パスワード</label>
                    <input
                        type="password"
                        value={password}
                        onChange={(e) => setPassword(e.target.value)}
                        required
                    />
                </div>
                {error && <div style={{ color: 'red' }}>{error}</div>}
                <button type="submit" disabled={isLoading}>
                    {isLoading ? 'ログイン中...' : 'ログイン'}
                </button>
            </form>
        </div>
    );
};
```

---

## 認証コンテキストの設計

### 認証コンテキストとは
認証コンテキストは、**アプリケーション全体で認証状態を管理し、共有するためのコンテキスト**です。

### 認証コンテキストの設計パターン

#### 1. 基本的な認証コンテキスト

```typescript
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState } from 'react';

interface AuthContextType {
    user: User | null;
    isAuthenticated: boolean;
    login: (email: string, password: string) => Promise<void>;
    logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    
    const login = async (email: string, password: string) => {
        // ログイン処理
    };
    
    const logout = () => {
        setUser(null);
    };
    
    const value: AuthContextType = {
        user,
        isAuthenticated: !!user,
        login,
        logout
    };
    
    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuthはAuthProvider内で使用する必要があります');
    }
    return context;
};
```

### 実践例: 認証コンテキストの設計

```typescript
// src/types/auth.ts
export interface AuthUser {
    id: string;
    email: string;
    name: string;
    role: 'admin' | 'user';
    avatar?: string;
}

export interface LoginCredentials {
    email: string;
    password: string;
}

export interface RegisterCredentials {
    email: string;
    password: string;
    name: string;
}

export interface AuthResponse {
    user: AuthUser;
    token: string;
    refreshToken: string;
    expiresIn: number;
}

// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { AuthUser, LoginCredentials, RegisterCredentials, AuthResponse } from '../types/auth';
import { storage } from '../utils/storage';

interface AuthContextType {
    // 状態
    user: AuthUser | null;
    token: string | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    error: string | null;
    
    // アクション
    login: (credentials: LoginCredentials) => Promise<void>;
    register: (credentials: RegisterCredentials) => Promise<void>;
    logout: () => void;
    refreshToken: () => Promise<void>;
    clearError: () => void;
    
    // ユーティリティ
    hasRole: (role: 'admin' | 'user') => boolean;
    updateUser: (user: Partial<AuthUser>) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

const STORAGE_KEYS = {
    TOKEN: 'auth_token',
    REFRESH_TOKEN: 'auth_refresh_token',
    USER: 'auth_user',
    EXPIRES_AT: 'auth_expires_at'
};

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<AuthUser | null>(null);
    const [token, setToken] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    
    // 初期化時に状態を復元
    useEffect(() => {
        const restoreAuth = async () => {
            try {
                const savedToken = storage.get(STORAGE_KEYS.TOKEN);
                const savedUser = storage.get(STORAGE_KEYS.USER);
                const expiresAt = storage.get(STORAGE_KEYS.EXPIRES_AT);
                
                if (savedToken && savedUser && expiresAt) {
                    const expirationTime = parseInt(expiresAt, 10);
                    const now = Date.now();
                    
                    if (now < expirationTime) {
                        setToken(savedToken);
                        setUser(JSON.parse(savedUser));
                    } else {
                        // トークンが期限切れの場合、リフレッシュを試みる
                        const refreshTokenValue = storage.get(STORAGE_KEYS.REFRESH_TOKEN);
                        if (refreshTokenValue) {
                            try {
                                await refreshAuthToken(refreshTokenValue);
                            } catch {
                                clearAuth();
                            }
                        } else {
                            clearAuth();
                        }
                    }
                }
            } catch (err) {
                console.error('認証状態の復元に失敗しました:', err);
                clearAuth();
            } finally {
                setIsLoading(false);
            }
        };
        
        restoreAuth();
    }, []);
    
    // 認証情報のクリア
    const clearAuth = useCallback(() => {
        setUser(null);
        setToken(null);
        Object.values(STORAGE_KEYS).forEach(key => storage.remove(key));
    }, []);
    
    // トークンのリフレッシュ（内部関数）
    const refreshAuthToken = async (refreshTokenValue: string) => {
        const response = await fetch('/api/auth/refresh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ refreshToken: refreshTokenValue })
        });
        
        if (!response.ok) {
            throw new Error('トークンのリフレッシュに失敗しました');
        }
        
        const data: AuthResponse = await response.json();
        const expiresAt = Date.now() + data.expiresIn * 1000;
        
        setUser(data.user);
        setToken(data.token);
        storage.set(STORAGE_KEYS.TOKEN, data.token);
        storage.set(STORAGE_KEYS.REFRESH_TOKEN, data.refreshToken);
        storage.set(STORAGE_KEYS.USER, JSON.stringify(data.user));
        storage.set(STORAGE_KEYS.EXPIRES_AT, expiresAt.toString());
    };
    
    // ログイン
    const login = useCallback(async (credentials: LoginCredentials) => {
        try {
            setError(null);
            setIsLoading(true);
            
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(credentials)
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || 'ログインに失敗しました');
            }
            
            const data: AuthResponse = await response.json();
            const expiresAt = Date.now() + data.expiresIn * 1000;
            
            setUser(data.user);
            setToken(data.token);
            storage.set(STORAGE_KEYS.TOKEN, data.token);
            storage.set(STORAGE_KEYS.REFRESH_TOKEN, data.refreshToken);
            storage.set(STORAGE_KEYS.USER, JSON.stringify(data.user));
            storage.set(STORAGE_KEYS.EXPIRES_AT, expiresAt.toString());
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'ログインに失敗しました';
            setError(errorMessage);
            throw err;
        } finally {
            setIsLoading(false);
        }
    }, []);
    
    // 登録
    const register = useCallback(async (credentials: RegisterCredentials) => {
        try {
            setError(null);
            setIsLoading(true);
            
            const response = await fetch('/api/auth/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(credentials)
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.message || '登録に失敗しました');
            }
            
            const data: AuthResponse = await response.json();
            const expiresAt = Date.now() + data.expiresIn * 1000;
            
            setUser(data.user);
            setToken(data.token);
            storage.set(STORAGE_KEYS.TOKEN, data.token);
            storage.set(STORAGE_KEYS.REFRESH_TOKEN, data.refreshToken);
            storage.set(STORAGE_KEYS.USER, JSON.stringify(data.user));
            storage.set(STORAGE_KEYS.EXPIRES_AT, expiresAt.toString());
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : '登録に失敗しました';
            setError(errorMessage);
            throw err;
        } finally {
            setIsLoading(false);
        }
    }, []);
    
    // ログアウト
    const logout = useCallback(() => {
        clearAuth();
        // ログアウトAPIを呼び出す（オプション）
        fetch('/api/auth/logout', { method: 'POST' }).catch(console.error);
    }, [clearAuth]);
    
    // トークンのリフレッシュ（公開関数）
    const refreshToken = useCallback(async () => {
        const refreshTokenValue = storage.get(STORAGE_KEYS.REFRESH_TOKEN);
        if (!refreshTokenValue) {
            throw new Error('リフレッシュトークンがありません');
        }
        
        try {
            await refreshAuthToken(refreshTokenValue);
        } catch (err) {
            clearAuth();
            throw err;
        }
    }, [clearAuth]);
    
    // エラーのクリア
    const clearError = useCallback(() => {
        setError(null);
    }, []);
    
    // ロールチェック
    const hasRole = useCallback((role: 'admin' | 'user'): boolean => {
        if (!user) return false;
        return user.role === role || user.role === 'admin';
    }, [user]);
    
    // ユーザー情報の更新
    const updateUser = useCallback((updatedUser: Partial<AuthUser>) => {
        if (user) {
            const newUser = { ...user, ...updatedUser };
            setUser(newUser);
            storage.set(STORAGE_KEYS.USER, JSON.stringify(newUser));
        }
    }, [user]);
    
    const value: AuthContextType = {
        user,
        token,
        isAuthenticated: !!user && !!token,
        isLoading,
        error,
        login,
        register,
        logout,
        refreshToken,
        clearError,
        hasRole,
        updateUser
    };
    
    return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (context === undefined) {
        throw new Error('useAuthはAuthProvider内で使用する必要があります');
    }
    return context;
};
```

---

## まとめ

この章では、Reactアプリケーションでの認証機能のアーキテクチャについて学びました。

### 学んだこと
- **ログイン状態の永続化**: ローカルストレージを使って認証状態を保存・復元
- **PrivateRoute**: 認証が必要なページへのアクセスを制御
- **認証コンテキスト**: アプリケーション全体で認証状態を管理

### 重要なポイント
1. **ローカルストレージ**: 認証トークンとユーザー情報を保存
2. **状態の復元**: アプリ起動時に保存された状態を復元
3. **PrivateRoute**: 未認証ユーザーをログインページにリダイレクト
4. **認証コンテキスト**: 認証状態をアプリ全体で共有
5. **トークンのリフレッシュ**: トークンの有効期限を管理

### セキュリティの注意点
- **トークンの保存**: 機密情報は適切に管理
- **HTTPS**: 本番環境では必ずHTTPSを使用
- **トークンの有効期限**: 適切な有効期限を設定
- **XSS対策**: ローカルストレージの使用に注意

### 次のステップ
認証機能を理解することで、セキュアで使いやすいReactアプリケーションを作成できるようになります。実際のプロジェクトで積極的に認証機能を実装して、セキュリティのベストプラクティスを学びましょう。

---

## 演習問題

### 問題1: 基本的な認証コンテキスト
認証コンテキストを作成し、ログインとログアウト機能を実装してください。

<details>
<summary>解答例</summary>

```typescript
// src/contexts/AuthContext.tsx
import React, { createContext, useContext, useState } from 'react';

interface AuthContextType {
    user: { id: string; email: string } | null;
    isAuthenticated: boolean;
    login: (email: string, password: string) => Promise<void>;
    logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<{ id: string; email: string } | null>(null);
    
    const login = async (email: string, password: string) => {
        // ログイン処理
        setUser({ id: '1', email });
    };
    
    const logout = () => {
        setUser(null);
    };
    
    return (
        <AuthContext.Provider value={{ user, isAuthenticated: !!user, login, logout }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuthはAuthProvider内で使用する必要があります');
    }
    return context;
};
```
</details>

### 問題2: PrivateRouteの実装
PrivateRouteコンポーネントを作成し、未認証ユーザーをログインページにリダイレクトしてください。

<details>
<summary>解答例</summary>

```typescript
// src/components/PrivateRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface PrivateRouteProps {
    children: React.ReactNode;
}

export const PrivateRoute: React.FC<PrivateRouteProps> = ({ children }) => {
    const { isAuthenticated, isLoading } = useAuth();
    
    if (isLoading) {
        return <div>読み込み中...</div>;
    }
    
    if (!isAuthenticated) {
        return <Navigate to="/login" replace />;
    }
    
    return <>{children}</>;
};
```
</details>

### 問題3: ローカルストレージへの保存
認証状態をローカルストレージに保存し、復元する機能を実装してください。

<details>
<summary>解答例</summary>

```typescript
// src/contexts/AuthContext.tsx
import { useEffect } from 'react';

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        // 復元
        const savedUser = localStorage.getItem('user');
        if (savedUser) {
            setUser(JSON.parse(savedUser));
        }
    }, []);
    
    const login = async (email: string, password: string) => {
        const userData = { id: '1', email };
        setUser(userData);
        localStorage.setItem('user', JSON.stringify(userData));
    };
    
    const logout = () => {
        setUser(null);
        localStorage.removeItem('user');
    };
    
    // ...
};
```
</details>

### 問題4: ロールベースのアクセス制御
管理者のみアクセスできるPrivateRouteを作成してください。

<details>
<summary>解答例</summary>

```typescript
// src/components/PrivateRoute.tsx
import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';

interface PrivateRouteProps {
    children: React.ReactNode;
    requiredRole?: 'admin' | 'user';
}

export const PrivateRoute: React.FC<PrivateRouteProps> = ({ children, requiredRole }) => {
    const { isAuthenticated, isLoading, user } = useAuth();
    
    if (isLoading) return <div>読み込み中...</div>;
    if (!isAuthenticated) return <Navigate to="/login" replace />;
    
    if (requiredRole && user?.role !== requiredRole && user?.role !== 'admin') {
        return <Navigate to="/unauthorized" replace />;
    }
    
    return <>{children}</>;
};
```
</details>

### 問題5: トークンのリフレッシュ
トークンのリフレッシュ機能を実装してください。

<details>
<summary>解答例</summary>

```typescript
// src/contexts/AuthContext.tsx
const refreshToken = async () => {
    const refreshTokenValue = localStorage.getItem('refreshToken');
    if (!refreshTokenValue) {
        throw new Error('リフレッシュトークンがありません');
    }
    
    const response = await fetch('/api/auth/refresh', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ refreshToken: refreshTokenValue })
    });
    
    if (!response.ok) {
        throw new Error('トークンのリフレッシュに失敗しました');
    }
    
    const data = await response.json();
    setToken(data.token);
    localStorage.setItem('token', data.token);
};
```
</details>

---

お疲れ様でした！次の章に進みましょう。


