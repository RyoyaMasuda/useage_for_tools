# 11-2. モックと非同期テスト

この章では、テストにおけるモックと非同期テストについて学びます。MSW（Mock Service Worker）を使ったAPIモックと、非同期更新のテスト方法を理解することで、より実践的なテストを書けるようになります。

---

## 目次

- [APIモック (MSW)](#apiモック-msw)
- [非同期更新のテスト](#非同期更新のテスト)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## APIモック (MSW)

### MSWとは
MSW（Mock Service Worker）は、**Service Workerを使ってHTTPリクエストをインターセプトし、モックレスポンスを返す**ライブラリです。実際のAPIサーバーを使わずに、テスト環境でAPIをモックできます。

### 日常生活での例
- **スタントマン**: 実際の俳優の代わりに危険なシーンを演じる（モック）
- **模型**: 実際の建物の代わりに模型を使って説明する（モック）
- **試着**: 実際に買う前に試着して確認する（モック）

### MSWのメリット
1. **実際のAPIを使わない**: テストが高速で安定
2. **ネットワークエラーをシミュレート**: エラーケースのテストが容易
3. **開発環境でも使用可能**: 開発中にAPIをモックできる

### MSWのインストール

```bash
npm install msw --save-dev
```

### MSWの基本設定

#### 1. ハンドラーの定義

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
    // GETリクエストのモック
    http.get('/api/users', () => {
        return HttpResponse.json([
            { id: 1, name: '太郎', email: 'taro@example.com' },
            { id: 2, name: '花子', email: 'hanako@example.com' }
        ]);
    }),
    
    // POSTリクエストのモック
    http.post('/api/users', async ({ request }) => {
        const body = await request.json();
        return HttpResponse.json({
            id: 3,
            ...body
        }, { status: 201 });
    })
];
```

#### 2. テスト環境での設定

```typescript
// src/mocks/server.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);
```

#### 3. テストファイルでの使用

```typescript
// src/__tests__/UserList.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { server } from '../mocks/server';
import { UserList } from '../components/UserList';

// テスト前にサーバーを起動
beforeAll(() => server.listen());

// 各テスト後にハンドラーをリセット
afterEach(() => server.resetHandlers());

// すべてのテスト後にサーバーを停止
afterAll(() => server.close());

test('ユーザーリストを表示', async () => {
    render(<UserList />);
    
    await waitFor(() => {
        expect(screen.getByText('太郎')).toBeInTheDocument();
    });
    
    expect(screen.getByText('花子')).toBeInTheDocument();
});
```

### 実践例: MSWを使ったAPIモック

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
    // ユーザー一覧の取得
    http.get('/api/users', () => {
        return HttpResponse.json([
            { id: 1, name: '太郎', email: 'taro@example.com' },
            { id: 2, name: '花子', email: 'hanako@example.com' },
            { id: 3, name: '次郎', email: 'jiro@example.com' }
        ]);
    }),
    
    // 特定のユーザーの取得
    http.get('/api/users/:id', ({ params }) => {
        const { id } = params;
        return HttpResponse.json({
            id: Number(id),
            name: '太郎',
            email: 'taro@example.com'
        });
    }),
    
    // ユーザーの作成
    http.post('/api/users', async ({ request }) => {
        const body = await request.json() as { name: string; email: string };
        return HttpResponse.json({
            id: 4,
            name: body.name,
            email: body.email
        }, { status: 201 });
    }),
    
    // ユーザーの更新
    http.put('/api/users/:id', async ({ params, request }) => {
        const { id } = params;
        const body = await request.json();
        return HttpResponse.json({
            id: Number(id),
            ...body
        });
    }),
    
    // ユーザーの削除
    http.delete('/api/users/:id', ({ params }) => {
        const { id } = params;
        return HttpResponse.json({ id: Number(id) }, { status: 200 });
    }),
    
    // エラーレスポンスのモック
    http.get('/api/error', () => {
        return HttpResponse.json(
            { message: 'エラーが発生しました' },
            { status: 500 }
        );
    })
];

// src/mocks/server.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

// src/setupTests.ts
import { server } from './mocks/server';

// テスト前にサーバーを起動
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));

// 各テスト後にハンドラーをリセット
afterEach(() => server.resetHandlers());

// すべてのテスト後にサーバーを停止
afterAll(() => server.close());

// src/components/UserList.tsx
import React, { useState, useEffect } from 'react';

interface User {
    id: number;
    name: string;
    email: string;
}

export const UserList: React.FC = () => {
    const [users, setUsers] = useState<User[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    
    useEffect(() => {
        fetch('/api/users')
            .then(response => {
                if (!response.ok) {
                    throw new Error('データの取得に失敗しました');
                }
                return response.json();
            })
            .then(data => {
                setUsers(data);
                setLoading(false);
            })
            .catch(err => {
                setError(err.message);
                setLoading(false);
            });
    }, []);
    
    if (loading) return <div>読み込み中...</div>;
    if (error) return <div>エラー: {error}</div>;
    
    return (
        <ul>
            {users.map(user => (
                <li key={user.id}>
                    {user.name} ({user.email})
                </li>
            ))}
        </ul>
    );
};

// src/__tests__/UserList.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { UserList } from '../components/UserList';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';

describe('UserList', () => {
    test('ユーザーリストを表示', async () => {
        render(<UserList />);
        
        // ローディング状態を確認
        expect(screen.getByText('読み込み中...')).toBeInTheDocument();
        
        // ユーザーが表示されるまで待機
        await waitFor(() => {
            expect(screen.getByText('太郎')).toBeInTheDocument();
        });
        
        expect(screen.getByText('花子')).toBeInTheDocument();
        expect(screen.getByText('次郎')).toBeInTheDocument();
    });
    
    test('エラーが発生した場合にエラーメッセージを表示', async () => {
        // エラーレスポンスをモック
        server.use(
            http.get('/api/users', () => {
                return HttpResponse.json(
                    { message: 'エラーが発生しました' },
                    { status: 500 }
                );
            })
        );
        
        render(<UserList />);
        
        await waitFor(() => {
            expect(screen.getByText(/エラー/)).toBeInTheDocument();
        });
    });
    
    test('空のユーザーリストを表示', async () => {
        // 空の配列を返すモック
        server.use(
            http.get('/api/users', () => {
                return HttpResponse.json([]);
            })
        );
        
        render(<UserList />);
        
        await waitFor(() => {
            expect(screen.queryByText('太郎')).not.toBeInTheDocument();
        });
    });
});
```

### 動的なハンドラーの設定

```typescript
// テスト内でハンドラーを動的に変更
test('動的なハンドラーの設定', async () => {
    server.use(
        http.get('/api/users', () => {
            return HttpResponse.json([
                { id: 1, name: 'テストユーザー', email: 'test@example.com' }
            ]);
        })
    );
    
    render(<UserList />);
    
    await waitFor(() => {
        expect(screen.getByText('テストユーザー')).toBeInTheDocument();
    });
});
```

---

## 非同期更新のテスト

### 非同期テストとは
非同期テストは、**非同期処理（API呼び出し、タイマーなど）の結果を待ってから検証する**テストです。

### 非同期テストの基本

#### waitForを使ったテスト

```typescript
import { render, screen, waitFor } from '@testing-library/react';

test('非同期データの表示', async () => {
    render(<AsyncComponent />);
    
    // データが表示されるまで待機
    await waitFor(() => {
        expect(screen.getByText('データ')).toBeInTheDocument();
    });
});
```

#### findByを使ったテスト

```typescript
import { render, screen } from '@testing-library/react';

test('非同期データの表示', async () => {
    render(<AsyncComponent />);
    
    // findByは自動的に待機する
    const element = await screen.findByText('データ');
    expect(element).toBeInTheDocument();
});
```

### 実践例: 非同期更新のテスト

```typescript
// src/components/AsyncUserList.tsx
import React, { useState, useEffect } from 'react';

interface User {
    id: number;
    name: string;
    email: string;
}

export const AsyncUserList: React.FC = () => {
    const [users, setUsers] = useState<User[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    
    useEffect(() => {
        const fetchUsers = async () => {
            try {
                const response = await fetch('/api/users');
                if (!response.ok) {
                    throw new Error('データの取得に失敗しました');
                }
                const data = await response.json();
                setUsers(data);
                setLoading(false);
            } catch (err) {
                setError(err instanceof Error ? err.message : 'エラーが発生しました');
                setLoading(false);
            }
        };
        
        fetchUsers();
    }, []);
    
    if (loading) return <div data-testid="loading">読み込み中...</div>;
    if (error) return <div data-testid="error">エラー: {error}</div>;
    
    return (
        <ul data-testid="user-list">
            {users.map(user => (
                <li key={user.id} data-testid={`user-${user.id}`}>
                    {user.name} ({user.email})
                </li>
            ))}
        </ul>
    );
};

// src/__tests__/AsyncUserList.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import { AsyncUserList } from '../components/AsyncUserList';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';

describe('AsyncUserList', () => {
    test('ユーザーリストを非同期で取得して表示', async () => {
        render(<AsyncUserList />);
        
        // ローディング状態を確認
        expect(screen.getByTestId('loading')).toBeInTheDocument();
        
        // ユーザーが表示されるまで待機
        await waitFor(() => {
            expect(screen.queryByTestId('loading')).not.toBeInTheDocument();
        });
        
        // ユーザーが表示されていることを確認
        expect(screen.getByTestId('user-list')).toBeInTheDocument();
        expect(screen.getByText('太郎')).toBeInTheDocument();
        expect(screen.getByText('花子')).toBeInTheDocument();
    });
    
    test('findByを使った非同期テスト', async () => {
        render(<AsyncUserList />);
        
        // findByは自動的に待機する
        const userList = await screen.findByTestId('user-list');
        expect(userList).toBeInTheDocument();
        
        const taro = await screen.findByText('太郎');
        expect(taro).toBeInTheDocument();
    });
    
    test('エラー状態の非同期テスト', async () => {
        // エラーレスポンスをモック
        server.use(
            http.get('/api/users', () => {
                return HttpResponse.json(
                    { message: 'エラーが発生しました' },
                    { status: 500 }
                );
            })
        );
        
        render(<AsyncUserList />);
        
        // エラーメッセージが表示されるまで待機
        await waitFor(() => {
            expect(screen.getByTestId('error')).toBeInTheDocument();
        });
        
        expect(screen.getByText(/エラー/)).toBeInTheDocument();
    });
    
    test('ローディング状態から完了状態への遷移', async () => {
        render(<AsyncUserList />);
        
        // 初期状態: ローディング中
        expect(screen.getByTestId('loading')).toBeInTheDocument();
        expect(screen.queryByTestId('user-list')).not.toBeInTheDocument();
        
        // 完了状態: ユーザーリストが表示
        await waitFor(() => {
            expect(screen.queryByTestId('loading')).not.toBeInTheDocument();
        });
        
        expect(screen.getByTestId('user-list')).toBeInTheDocument();
    });
});

// src/components/UserForm.tsx
import React, { useState } from 'react';

interface UserFormProps {
    onSubmit: (user: { name: string; email: string }) => Promise<void>;
}

export const UserForm: React.FC<UserFormProps> = ({ onSubmit }) => {
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState('');
    
    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);
        setMessage('');
        
        try {
            await onSubmit({ name, email });
            setMessage('ユーザーが作成されました');
            setName('');
            setEmail('');
        } catch (error) {
            setMessage('エラーが発生しました');
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <form onSubmit={handleSubmit}>
            <input
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="名前"
                data-testid="name-input"
            />
            <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="メールアドレス"
                data-testid="email-input"
            />
            <button type="submit" disabled={loading} data-testid="submit-button">
                {loading ? '送信中...' : '送信'}
            </button>
            {message && <div data-testid="message">{message}</div>}
        </form>
    );
};

// src/__tests__/UserForm.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserForm } from '../components/UserForm';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';

describe('UserForm', () => {
    test('フォーム送信の非同期テスト', async () => {
        const user = userEvent.setup();
        const mockOnSubmit = jest.fn().mockResolvedValue(undefined);
        
        render(<UserForm onSubmit={mockOnSubmit} />);
        
        // フォームに入力
        await user.type(screen.getByTestId('name-input'), '太郎');
        await user.type(screen.getByTestId('email-input'), 'taro@example.com');
        
        // 送信ボタンをクリック
        await user.click(screen.getByTestId('submit-button'));
        
        // ローディング状態を確認
        expect(screen.getByText('送信中...')).toBeInTheDocument();
        
        // 送信が完了するまで待機
        await waitFor(() => {
            expect(mockOnSubmit).toHaveBeenCalledWith({
                name: '太郎',
                email: 'taro@example.com'
            });
        });
        
        // 成功メッセージが表示されることを確認
        await waitFor(() => {
            expect(screen.getByTestId('message')).toHaveTextContent('ユーザーが作成されました');
        });
    });
    
    test('API呼び出しを含む非同期テスト', async () => {
        const user = userEvent.setup();
        let resolveSubmit: () => void;
        const submitPromise = new Promise<void>((resolve) => {
            resolveSubmit = resolve;
        });
        
        const mockOnSubmit = jest.fn().mockReturnValue(submitPromise);
        
        render(<UserForm onSubmit={mockOnSubmit} />);
        
        await user.type(screen.getByTestId('name-input'), '太郎');
        await user.type(screen.getByTestId('email-input'), 'taro@example.com');
        await user.click(screen.getByTestId('submit-button'));
        
        // 送信中であることを確認
        expect(screen.getByText('送信中...')).toBeInTheDocument();
        
        // 非同期処理を完了
        resolveSubmit!();
        
        // 完了状態を確認
        await waitFor(() => {
            expect(screen.queryByText('送信中...')).not.toBeInTheDocument();
        });
    });
});

// src/components/Counter.tsx
import React, { useState, useEffect } from 'react';

export const Counter: React.FC = () => {
    const [count, setCount] = useState(0);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        // 非同期で初期値を取得
        const fetchInitialCount = async () => {
            const response = await fetch('/api/count');
            const data = await response.json();
            setCount(data.count);
            setLoading(false);
        };
        
        fetchInitialCount();
    }, []);
    
    const handleIncrement = async () => {
        const response = await fetch('/api/count', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action: 'increment' })
        });
        const data = await response.json();
        setCount(data.count);
    };
    
    if (loading) return <div data-testid="loading">読み込み中...</div>;
    
    return (
        <div>
            <p data-testid="count">カウント: {count}</p>
            <button onClick={handleIncrement} data-testid="increment-button">
                増やす
            </button>
        </div>
    );
};

// src/__tests__/Counter.test.tsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Counter } from '../components/Counter';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';

describe('Counter', () => {
    test('初期値の非同期取得', async () => {
        server.use(
            http.get('/api/count', () => {
                return HttpResponse.json({ count: 10 });
            })
        );
        
        render(<Counter />);
        
        // ローディング状態を確認
        expect(screen.getByTestId('loading')).toBeInTheDocument();
        
        // カウントが表示されるまで待機
        await waitFor(() => {
            expect(screen.getByTestId('count')).toHaveTextContent('カウント: 10');
        });
    });
    
    test('カウントの非同期更新', async () => {
        const user = userEvent.setup();
        let count = 10;
        
        server.use(
            http.get('/api/count', () => {
                return HttpResponse.json({ count });
            }),
            http.post('/api/count', async () => {
                count += 1;
                return HttpResponse.json({ count });
            })
        );
        
        render(<Counter />);
        
        // 初期値が表示されるまで待機
        await waitFor(() => {
            expect(screen.getByTestId('count')).toHaveTextContent('カウント: 10');
        });
        
        // 増やすボタンをクリック
        await user.click(screen.getByTestId('increment-button'));
        
        // カウントが更新されるまで待機
        await waitFor(() => {
            expect(screen.getByTestId('count')).toHaveTextContent('カウント: 11');
        });
    });
});
```

### 非同期テストのベストプラクティス

1. **waitForを使用**: 非同期更新を待つ場合は`waitFor`を使用
2. **findByを使用**: 要素の存在を確認する場合は`findBy`を使用
3. **タイムアウトの設定**: 必要に応じてタイムアウトを設定
4. **エラーケースのテスト**: エラーケースもテストする

---

## まとめ

この章では、モックと非同期テストについて学びました。

### 学んだこと
- **MSW**: Service Workerを使ったAPIモック
- **ハンドラーの定義**: HTTPリクエストに対するモックレスポンスの定義
- **非同期テスト**: waitForやfindByを使った非同期更新のテスト
- **動的なハンドラー**: テスト内でハンドラーを動的に変更

### 重要なポイント
1. **MSW**: 実際のAPIを使わずにテストできる
2. **ハンドラー**: リクエストに対するレスポンスを定義
3. **waitFor**: 非同期更新を待ってから検証
4. **findBy**: 要素の存在を自動的に待つ
5. **エラーケース**: エラーケースもテストする

### 使い分けの目安
- **waitFor**: 複雑な非同期更新を待つ場合
- **findBy**: 要素の存在を確認する場合
- **MSW**: APIをモックする場合

### 次のステップ
モックと非同期テストを理解することで、より実践的なテストを書けるようになります。実際のプロジェクトで積極的にMSWと非同期テストを活用して、テストの品質を向上させましょう。

---

## 演習問題

### 問題1: MSWの基本設定
MSWを使って、GETリクエストに対するモックレスポンスを定義してください。

<details>
<summary>解答例</summary>

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
    http.get('/api/users', () => {
        return HttpResponse.json([
            { id: 1, name: '太郎', email: 'taro@example.com' }
        ]);
    })
];
```
</details>

### 問題2: POSTリクエストのモック
MSWを使って、POSTリクエストに対するモックレスポンスを定義してください。

<details>
<summary>解答例</summary>

```typescript
// src/mocks/handlers.ts
import { http, HttpResponse } from 'msw';

export const handlers = [
    http.post('/api/users', async ({ request }) => {
        const body = await request.json();
        return HttpResponse.json({
            id: 1,
            ...body
        }, { status: 201 });
    })
];
```
</details>

### 問題3: waitForを使った非同期テスト
waitForを使って、非同期でデータが表示されることをテストしてください。

<details>
<summary>解答例</summary>

```typescript
import { render, screen, waitFor } from '@testing-library/react';

test('非同期データの表示', async () => {
    render(<AsyncComponent />);
    
    await waitFor(() => {
        expect(screen.getByText('データ')).toBeInTheDocument();
    });
});
```
</details>

### 問題4: findByを使った非同期テスト
findByを使って、非同期で要素が表示されることをテストしてください。

<details>
<summary>解答例</summary>

```typescript
import { render, screen } from '@testing-library/react';

test('非同期データの表示', async () => {
    render(<AsyncComponent />);
    
    const element = await screen.findByText('データ');
    expect(element).toBeInTheDocument();
});
```
</details>

### 問題5: エラーケースのテスト
MSWを使って、エラーレスポンスをモックし、エラーケースをテストしてください。

<details>
<summary>解答例</summary>

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import { server } from '../mocks/server';
import { http, HttpResponse } from 'msw';

test('エラーケースのテスト', async () => {
    server.use(
        http.get('/api/users', () => {
            return HttpResponse.json(
                { message: 'エラーが発生しました' },
                { status: 500 }
            );
        })
    );
    
    render(<AsyncComponent />);
    
    await waitFor(() => {
        expect(screen.getByText(/エラー/)).toBeInTheDocument();
    });
});
```
</details>

---

お疲れ様でした！次の章に進みましょう。

