# 6-3. レンダリングの計測

この章では、React Developer ToolsのProfiler機能を使って、レンダリングの計測とパフォーマンス分析を行う方法について学びます。Profilerを使うことで、どのコンポーネントが再レンダリングされているか、どのくらい時間がかかっているかを可視化し、パフォーマンスのボトルネックを特定できるようになります。

---

## 目次

- [React Developer Toolsとは](#react-developer-toolsとは)
- [Profilerの基本操作](#profilerの基本操作)
- [レンダリング情報の読み方](#レンダリング情報の読み方)
- [パフォーマンス問題の特定](#パフォーマンス問題の特定)
- [実践例: パフォーマンス分析](#実践例-パフォーマンス分析)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## React Developer Toolsとは

### React Developer Toolsとは
React Developer Toolsは、**Reactアプリケーションをデバッグ・分析するためのブラウザ拡張機能**です。Chrome、Firefox、Edgeなどの主要なブラウザで使用できます。

### 日常生活での例
- **健康診断**: 体の状態を計測して問題を特定（Profiler）
- **車の診断**: エンジンの状態を計測して問題を特定（Profiler）
- **家電の診断**: 動作状態を計測して問題を特定（Profiler）

### React Developer Toolsの機能

1. **Components**: コンポーネントツリーの表示とProps/Stateの確認
2. **Profiler**: レンダリングの計測とパフォーマンス分析

### インストール方法

#### Chrome
1. [Chrome Web Store](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)からインストール
2. ブラウザを再起動

#### Firefox
1. [Firefox Add-ons](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)からインストール
2. ブラウザを再起動

#### Edge
1. [Microsoft Edge Add-ons](https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/gpphkfbcpidddadnkolkpfckpihlkkil)からインストール
2. ブラウザを再起動

### インストールの確認

React Developer Toolsをインストールすると、ブラウザの開発者ツールに「Components」と「Profiler」のタブが追加されます。

---

## Profilerの基本操作

### Profilerタブの開き方

1. **開発者ツールを開く**: `F12`キーまたは`Ctrl+Shift+I`（Windows/Linux）、`Cmd+Option+I`（Mac）
2. **Profilerタブを選択**: 開発者ツールの上部にある「Profiler」タブをクリック

### レンダリングの記録

#### 1. 記録の開始

Profilerタブを開くと、左上に「●」（記録ボタン）が表示されます。このボタンをクリックして記録を開始します。

```
[●] 記録を開始
```

#### 2. アプリケーションの操作

記録を開始したら、アプリケーションを操作します（ボタンをクリック、フォームに入力など）。

#### 3. 記録の停止

もう一度「●」ボタンをクリックして記録を停止します。

### 記録結果の表示

記録を停止すると、以下の情報が表示されます：

1. **フレームグラフ**: 各コンポーネントのレンダリング時間を視覚的に表示
2. **ランキング**: レンダリング時間が長いコンポーネントの順位
3. **インタラクション**: ユーザーの操作とそれに伴うレンダリング

### 実践例: Profilerの基本操作

```jsx
// src/App.jsx
import React, { useState } from 'react';

// 重い計算をシミュレート
function heavyCalculation(n) {
    let result = 0;
    for (let i = 0; i < n * 1000000; i++) {
        result += i;
    }
    return result;
}

// 重い計算を行うコンポーネント
function HeavyComponent({ count }) {
    const result = heavyCalculation(count);
    return <p>計算結果: {result}</p>;
}

// 軽いコンポーネント
function LightComponent({ name }) {
    return <p>名前: {name}</p>;
}

function App() {
    const [count, setCount] = useState(1);
    const [name, setName] = useState('太郎');
    
    return (
        <div className="app">
            <h1>Profilerの基本操作</h1>
            <p>開発者ツールのProfilerタブを開いて、記録を開始してください</p>
            
            <div>
                <button onClick={() => setCount(count + 1)}>
                    カウントアップ（重い計算をトリガー）
                </button>
                <button onClick={() => setName(name === '太郎' ? '花子' : '太郎')}>
                    名前を変更（軽い操作）
                </button>
            </div>
            
            <HeavyComponent count={count} />
            <LightComponent name={name} />
            
            <p>操作手順:</p>
            <ol>
                <li>開発者ツールを開く（F12）</li>
                <li>Profilerタブを選択</li>
                <li>記録ボタン（●）をクリック</li>
                <li>「カウントアップ」ボタンをクリック</li>
                <li>記録ボタンを再度クリックして停止</li>
                <li>結果を確認</li>
            </ol>
        </div>
    );
}

export default App;
```

---

## レンダリング情報の読み方

### フレームグラフの見方

フレームグラフは、各コンポーネントのレンダリング時間を視覚的に表示します。

#### 色の意味

- **緑**: レンダリングが速い（短時間）
- **黄**: レンダリングが中程度（やや時間がかかる）
- **赤**: レンダリングが遅い（長時間かかる）

#### バーの長さ

バーの長さは、レンダリングにかかった時間を表します。長いバーほど時間がかかっています。

### ランキングの見方

ランキングは、レンダリング時間が長いコンポーネントを順位付けして表示します。

#### 表示される情報

- **Component**: コンポーネント名
- **Render duration**: レンダリング時間（ミリ秒）
- **Rank**: ランキング順位

### インタラクションの見方

インタラクションは、ユーザーの操作（クリック、入力など）とそれに伴うレンダリングを表示します。

#### 表示される情報

- **Interaction**: 操作の種類（クリック、入力など）
- **Duration**: 操作からレンダリング完了までの時間
- **Components**: 影響を受けたコンポーネント

### 実践例: レンダリング情報の読み方

```jsx
// src/App.jsx
import React, { useState } from 'react';

// 例1: 重い計算を行うコンポーネント
function ExpensiveComponent({ value }) {
    // 重い計算をシミュレート
    const result = Array.from({ length: value * 1000 }, (_, i) => i)
        .reduce((sum, num) => sum + num, 0);
    
    return (
        <div>
            <h3>重い計算コンポーネント</h3>
            <p>計算結果: {result}</p>
            <p>※Profilerで赤色（遅い）と表示される可能性があります</p>
        </div>
    );
}

// 例2: 軽いコンポーネント
function CheapComponent({ text }) {
    return (
        <div>
            <h3>軽いコンポーネント</h3>
            <p>テキスト: {text}</p>
            <p>※Profilerで緑色（速い）と表示される可能性があります</p>
        </div>
    );
}

// 例3: 条件付きレンダリング
function ConditionalComponent({ show }) {
    if (!show) return null;
    
    return (
        <div>
            <h3>条件付きコンポーネント</h3>
            <p>表示されています</p>
        </div>
    );
}

function App() {
    const [value, setValue] = useState(100);
    const [text, setText] = useState('Hello');
    const [show, setShow] = useState(true);
    
    return (
        <div className="app">
            <h1>レンダリング情報の読み方</h1>
            <p>Profilerで記録して、以下の情報を確認してください:</p>
            
            <div>
                <button onClick={() => setValue(value + 10)}>
                    値を増やす（重い計算をトリガー）
                </button>
                <button onClick={() => setText(text + '!')}>
                    テキストを変更（軽い操作）
                </button>
                <button onClick={() => setShow(!show)}>
                    表示/非表示を切り替え
                </button>
            </div>
            
            <ExpensiveComponent value={value} />
            <CheapComponent text={text} />
            <ConditionalComponent show={show} />
            
            <div style={{ marginTop: '20px', padding: '10px', backgroundColor: '#f0f0f0' }}>
                <h3>確認ポイント</h3>
                <ul>
                    <li>フレームグラフで色とバーの長さを確認</li>
                    <li>ランキングでレンダリング時間の長いコンポーネントを確認</li>
                    <li>インタラクションで操作とレンダリングの関係を確認</li>
                </ul>
            </div>
        </div>
    );
}

export default App;
```

---

## パフォーマンス問題の特定

### パフォーマンス問題の特定手順

1. **Profilerで記録**: 問題が発生する操作を記録
2. **ランキングを確認**: レンダリング時間が長いコンポーネントを特定
3. **フレームグラフを確認**: どのコンポーネントが遅いか視覚的に確認
4. **原因を分析**: なぜ遅いのかを分析（重い計算、不要な再レンダリングなど）
5. **最適化を実施**: 問題を解決（React.memo、useMemo、useCallbackなど）

### よくあるパフォーマンス問題

#### 1. 不要な再レンダリング

親コンポーネントが再レンダリングされると、Propsが変更されていなくても子コンポーネントが再レンダリングされる。

**解決策**: `React.memo`を使う

#### 2. 重い計算の繰り返し

レンダリングのたびに重い計算が実行される。

**解決策**: `useMemo`を使う

#### 3. 関数の再作成

レンダリングのたびに新しい関数が作成され、子コンポーネントが再レンダリングされる。

**解決策**: `useCallback`を使う

### 実践例: パフォーマンス問題の特定と解決

```jsx
// src/App.jsx
import React, { useState, memo, useMemo, useCallback } from 'react';

// 重い計算をシミュレート
function heavyCalculation(n) {
    let result = 0;
    for (let i = 0; i < n * 1000000; i++) {
        result += i;
    }
    return result;
}

// 問題のあるコンポーネント（最適化なし）
function UnoptimizedExpensiveComponent({ value }) {
    // 毎回計算が実行される（問題）
    const result = heavyCalculation(value);
    console.log('UnoptimizedExpensiveComponentがレンダリングされました');
    
    return (
        <div>
            <h3>最適化なし（遅い）</h3>
            <p>計算結果: {result}</p>
        </div>
    );
}

// 最適化されたコンポーネント（useMemo使用）
function OptimizedExpensiveComponent({ value }) {
    // useMemoで計算結果をメモ化（解決策）
    const result = useMemo(() => heavyCalculation(value), [value]);
    console.log('OptimizedExpensiveComponentがレンダリングされました');
    
    return (
        <div>
            <h3>最適化あり（速い）</h3>
            <p>計算結果: {result}</p>
        </div>
    );
}

// 問題のあるコンポーネント（メモ化なし）
function UnoptimizedChild({ name, onUpdate }) {
    console.log('UnoptimizedChildがレンダリングされました');
    return (
        <div>
            <p>名前: {name}</p>
            <button onClick={onUpdate}>更新</button>
        </div>
    );
}

// 最適化されたコンポーネント（React.memo使用）
const OptimizedChild = memo(function OptimizedChild({ name, onUpdate }) {
    console.log('OptimizedChildがレンダリングされました');
    return (
        <div>
            <p>名前: {name}</p>
            <button onClick={onUpdate}>更新</button>
        </div>
    );
});

function App() {
    const [count, setCount] = useState(0);
    const [value, setValue] = useState(10);
    const [name, setName] = useState('太郎');
    
    // 問題のある関数（毎回新しい関数が作成される）
    const handleUpdate1 = () => {
        setName(name === '太郎' ? '花子' : '太郎');
    };
    
    // 最適化された関数（useCallback使用）
    const handleUpdate2 = useCallback(() => {
        setName(name === '太郎' ? '花子' : '太郎');
    }, [name]);
    
    return (
        <div className="app">
            <h1>パフォーマンス問題の特定と解決</h1>
            <p>Profilerで記録して、最適化前後の違いを確認してください</p>
            
            <div>
                <p>カウント: {count}</p>
                <button onClick={() => setCount(count + 1)}>
                    カウントアップ（親を再レンダリング）
                </button>
            </div>
            
            <div style={{ marginTop: '20px' }}>
                <h2>重い計算の最適化</h2>
                <p>値: {value}</p>
                <button onClick={() => setValue(value + 1)}>値を増やす</button>
                <UnoptimizedExpensiveComponent value={value} />
                <OptimizedExpensiveComponent value={value} />
            </div>
            
            <div style={{ marginTop: '20px' }}>
                <h2>不要な再レンダリングの最適化</h2>
                <p>名前: {name}</p>
                <UnoptimizedChild name={name} onUpdate={handleUpdate1} />
                <OptimizedChild name={name} onUpdate={handleUpdate2} />
                <p>※カウントアップをクリックすると、UnoptimizedChildは再レンダリングされますが、OptimizedChildは再レンダリングされません（コンソールを確認）</p>
            </div>
            
            <div style={{ marginTop: '20px', padding: '10px', backgroundColor: '#f0f0f0' }}>
                <h3>確認ポイント</h3>
                <ul>
                    <li>Profilerで最適化前後のレンダリング時間を比較</li>
                    <li>コンソールで再レンダリング回数を確認</li>
                    <li>ランキングで最適化の効果を確認</li>
                </ul>
            </div>
        </div>
    );
}

export default App;
```

---

## 実践例: パフォーマンス分析

### 実践的なパフォーマンス分析の流れ

1. **ベースラインの測定**: 最適化前のパフォーマンスを記録
2. **問題の特定**: ランキングやフレームグラフで問題箇所を特定
3. **最適化の実施**: React.memo、useMemo、useCallbackなどを適用
4. **改善の確認**: 最適化後のパフォーマンスを記録して比較

### 実践例: リストコンポーネントの最適化

```jsx
// src/App.jsx
import React, { useState, memo, useCallback } from 'react';

// 最適化されていないリストアイテム
function UnoptimizedListItem({ item, onDelete }) {
    console.log(`UnoptimizedListItem ${item.id} がレンダリングされました`);
    return (
        <div style={{ padding: '10px', border: '1px solid #ccc', margin: '5px' }}>
            <span>{item.name}</span>
            <button onClick={() => onDelete(item.id)}>削除</button>
        </div>
    );
}

// 最適化されたリストアイテム
const OptimizedListItem = memo(function OptimizedListItem({ item, onDelete }) {
    console.log(`OptimizedListItem ${item.id} がレンダリングされました`);
    return (
        <div style={{ padding: '10px', border: '1px solid #ccc', margin: '5px' }}>
            <span>{item.name}</span>
            <button onClick={() => onDelete(item.id)}>削除</button>
        </div>
    );
});

function App() {
    const [items, setItems] = useState([
        { id: 1, name: 'アイテム1' },
        { id: 2, name: 'アイテム2' },
        { id: 3, name: 'アイテム3' },
        { id: 4, name: 'アイテム4' },
        { id: 5, name: 'アイテム5' }
    ]);
    const [count, setCount] = useState(0);
    
    // 最適化されていない削除関数
    const handleDelete1 = (id) => {
        setItems(items.filter(item => item.id !== id));
    };
    
    // 最適化された削除関数
    const handleDelete2 = useCallback((id) => {
        setItems(prevItems => prevItems.filter(item => item.id !== id));
    }, []);
    
    return (
        <div className="app">
            <h1>リストコンポーネントの最適化</h1>
            <p>Profilerで記録して、最適化前後の違いを確認してください</p>
            
            <div>
                <p>カウント: {count}</p>
                <button onClick={() => setCount(count + 1)}>
                    カウントアップ（親を再レンダリング）
                </button>
            </div>
            
            <div style={{ marginTop: '20px' }}>
                <h2>最適化なし</h2>
                {items.map(item => (
                    <UnoptimizedListItem 
                        key={item.id} 
                        item={item} 
                        onDelete={handleDelete1}
                    />
                ))}
            </div>
            
            <div style={{ marginTop: '20px' }}>
                <h2>最適化あり</h2>
                {items.map(item => (
                    <OptimizedListItem 
                        key={item.id} 
                        item={item} 
                        onDelete={handleDelete2}
                    />
                ))}
            </div>
            
            <div style={{ marginTop: '20px', padding: '10px', backgroundColor: '#f0f0f0' }}>
                <h3>確認ポイント</h3>
                <ul>
                    <li>カウントアップをクリックしたときの再レンダリングを確認</li>
                    <li>最適化なしのリストアイテムはすべて再レンダリングされる</li>
                    <li>最適化ありのリストアイテムは再レンダリングされない</li>
                    <li>Profilerでレンダリング時間の違いを確認</li>
                </ul>
            </div>
        </div>
    );
}

export default App;
```

### Profilerの高度な機能

#### 1. コミットの比較

複数の記録を比較して、最適化の効果を確認できます。

#### 2. インタラクションの追跡

特定の操作（クリック、入力など）がどのコンポーネントに影響を与えたかを追跡できます。

#### 3. フレームレートの確認

60fpsを維持できているか、フレームがドロップしていないかを確認できます。

---

## まとめ

この章では、React Developer ToolsのProfiler機能を使ったレンダリングの計測について学びました。

### 学んだこと
- **React Developer Tools**: Reactアプリケーションをデバッグ・分析するツール
- **Profilerの基本操作**: 記録の開始・停止、結果の確認
- **レンダリング情報の読み方**: フレームグラフ、ランキング、インタラクション
- **パフォーマンス問題の特定**: 問題の特定手順と解決策
- **実践的な分析**: ベースライン測定から最適化までの流れ

### 重要なポイント
1. **記録の開始**: Profilerタブで記録ボタンをクリック
2. **フレームグラフ**: 色とバーの長さでレンダリング時間を確認
3. **ランキング**: レンダリング時間が長いコンポーネントを特定
4. **最適化**: React.memo、useMemo、useCallbackで問題を解決

### 使い分けの目安
- **Profilerを使う**: パフォーマンス問題を特定したい場合、最適化の効果を確認したい場合
- **定期的な計測**: 開発中に定期的にProfilerで計測して、問題を早期に発見

### 次のステップ
Profilerを理解することで、パフォーマンス問題を特定し、効果的な最適化ができるようになります。実際のプロジェクトで積極的にProfilerを活用して、パフォーマンスの改善に取り組みましょう。

---

## 演習問題

### 問題1: Profilerの基本操作
Profilerを使って、ボタンをクリックしたときのレンダリングを記録してください。

<details>
<summary>解答例</summary>

```jsx
import { useState } from 'react';

function App() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <p>操作手順:</p>
            <ol>
                <li>開発者ツールを開く（F12）</li>
                <li>Profilerタブを選択</li>
                <li>記録ボタン（●）をクリック</li>
                <li>「カウントアップ」ボタンをクリック</li>
                <li>記録ボタンを再度クリックして停止</li>
                <li>結果を確認</li>
            </ol>
        </div>
    );
}
```
</details>

### 問題2: レンダリング時間の確認
重い計算を行うコンポーネントを作成し、Profilerでレンダリング時間を確認してください。

<details>
<summary>解答例</summary>

```jsx
import { useState } from 'react';

function HeavyComponent({ value }) {
    // 重い計算をシミュレート
    const result = Array.from({ length: value * 1000 }, (_, i) => i)
        .reduce((sum, num) => sum + num, 0);
    
    return <p>計算結果: {result}</p>;
}

function App() {
    const [value, setValue] = useState(100);
    
    return (
        <div>
            <p>値: {value}</p>
            <button onClick={() => setValue(value + 10)}>値を増やす</button>
            <HeavyComponent value={value} />
            <p>※Profilerでレンダリング時間を確認してください</p>
        </div>
    );
}
```
</details>

### 問題3: ランキングの確認
複数のコンポーネントを作成し、Profilerのランキング機能でレンダリング時間を比較してください。

<details>
<summary>解答例</summary>

```jsx
import { useState } from 'react';

function Component1({ value }) {
    const result = Array.from({ length: value * 100 }, (_, i) => i)
        .reduce((sum, num) => sum + num, 0);
    return <p>コンポーネント1: {result}</p>;
}

function Component2({ value }) {
    const result = Array.from({ length: value * 50 }, (_, i) => i)
        .reduce((sum, num) => sum + num, 0);
    return <p>コンポーネント2: {result}</p>;
}

function Component3({ text }) {
    return <p>コンポーネント3: {text}</p>;
}

function App() {
    const [value, setValue] = useState(100);
    const [text, setText] = useState('Hello');
    
    return (
        <div>
            <button onClick={() => setValue(value + 10)}>値を増やす</button>
            <button onClick={() => setText(text + '!')}>テキストを変更</button>
            <Component1 value={value} />
            <Component2 value={value} />
            <Component3 text={text} />
            <p>※Profilerのランキングでレンダリング時間を比較してください</p>
        </div>
    );
}
```
</details>

### 問題4: 最適化前後の比較
最適化されていないコンポーネントと最適化されたコンポーネントを作成し、Profilerで比較してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, memo, useMemo } from 'react';

function heavyCalculation(n) {
    let result = 0;
    for (let i = 0; i < n * 1000000; i++) {
        result += i;
    }
    return result;
}

function UnoptimizedComponent({ value }) {
    const result = heavyCalculation(value);
    return <p>最適化なし: {result}</p>;
}

function OptimizedComponent({ value }) {
    const result = useMemo(() => heavyCalculation(value), [value]);
    return <p>最適化あり: {result}</p>;
}

function App() {
    const [value, setValue] = useState(10);
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <button onClick={() => setValue(value + 1)}>値を増やす</button>
            <UnoptimizedComponent value={value} />
            <OptimizedComponent value={value} />
            <p>※Profilerで最適化前後のレンダリング時間を比較してください</p>
        </div>
    );
}
```
</details>

### 問題5: インタラクションの追跡
複数の操作を行うコンポーネントを作成し、Profilerのインタラクション機能で操作とレンダリングの関係を確認してください。

<details>
<summary>解答例</summary>

```jsx
import { useState } from 'react';

function App() {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);
    const [text, setText] = useState('');
    
    return (
        <div>
            <div>
                <p>カウント1: {count1}</p>
                <button onClick={() => setCount1(count1 + 1)}>カウント1アップ</button>
            </div>
            
            <div>
                <p>カウント2: {count2}</p>
                <button onClick={() => setCount2(count2 + 1)}>カウント2アップ</button>
            </div>
            
            <div>
                <input 
                    value={text} 
                    onChange={(e) => setText(e.target.value)} 
                    placeholder="テキストを入力"
                />
            </div>
            
            <p>操作手順:</p>
            <ol>
                <li>Profilerで記録を開始</li>
                <li>「カウント1アップ」をクリック</li>
                <li>「カウント2アップ」をクリック</li>
                <li>テキストを入力</li>
                <li>記録を停止</li>
                <li>インタラクションで各操作とレンダリングの関係を確認</li>
            </ol>
        </div>
    );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。


