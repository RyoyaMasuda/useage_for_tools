# 8-2. グローバルステートの更新と参照 (Recoil / Jotai / Zustand)

この章では、Recoil、Jotai、Zustandなどの状態管理ライブラリを使用して、グローバルステートを更新・参照する方法について学びます。これらのライブラリを理解することで、アプリケーション全体で状態を効率的に管理できるようになります。

---

## 目次

- [Atomの概念](#atomの概念)
- [Recoilでのグローバルステート管理](#recoilでのグローバルステート管理)
- [Jotaiでのグローバルステート管理](#jotaiでのグローバルステート管理)
- [Zustandでのグローバルステート管理](#zustandでのグローバルステート管理)
- [ライブラリの選び方](#ライブラリの選び方)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Atomの概念

### Atomとは

Atomは、**状態の最小単位**です。RecoilやJotaiでは、Atomという概念を使用して状態を管理します。各Atomは独立しており、他のAtomに依存することもできます。

### Atomの特徴

- **独立性**: 各Atomは独立した状態を持つ
- **再利用性**: 複数のコンポーネントで同じAtomを使用できる
- **依存関係**: Atom同士で依存関係を定義できる
- **細かい更新**: 必要な部分だけを更新できる

### AtomとuseStateの違い

| 特徴 | useState | Atom |
|------|----------|------|
| **スコープ** | コンポーネント内 | アプリケーション全体 |
| **共有** | Propsで渡す必要がある | 直接共有可能 |
| **更新** | コンポーネント内のみ | どこからでも更新可能 |

### 日常生活での例

- **グローバル設定**: アプリ全体で使用する言語やテーマ
- **ユーザー情報**: ログイン状態やユーザープロフィール
- **ショッピングカート**: 複数のページで共有するカート情報
- **通知**: アプリ全体で表示する通知メッセージ

### Atomの基本構造

```javascript
// Atomの基本構造
const myAtom = atom({
  key: 'uniqueKey',  // 一意のキー
  default: 初期値      // デフォルト値
})
```

---

## Recoilでのグローバルステート管理

### Recoilとは

Recoilは、**Facebookが開発した状態管理ライブラリ**です。Atomベースのアプローチで、Reactのエコシステムと統合されています。

### インストール

```bash
npm install recoil
```

### RecoilRootでアプリをラップ

```jsx
// src/main.jsx
import { RecoilRoot } from 'recoil'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')).render(
  <RecoilRoot>
    <App />
  </RecoilRoot>
)
```

### Atomの定義

```jsx
// src/atoms/counterAtom.js
import { atom } from 'recoil'

export const counterAtom = atom({
  key: 'counterAtom',
  default: 0,
})
```

### Atomの使用（参照と更新）

#### useRecoilState: 状態の参照と更新

```jsx
// src/components/Counter.jsx
import { useRecoilState } from 'recoil'
import { counterAtom } from '../atoms/counterAtom'

function Counter() {
  const [count, setCount] = useRecoilState(counterAtom)
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>増やす</button>
      <button onClick={() => setCount(count - 1)}>減らす</button>
    </div>
  )
}
```

#### useRecoilValue: 状態の参照のみ

```jsx
// src/components/CounterDisplay.jsx
import { useRecoilValue } from 'recoil'
import { counterAtom } from '../atoms/counterAtom'

function CounterDisplay() {
  const count = useRecoilValue(counterAtom)
  
  return <p>カウント: {count}</p>
}
```

#### useSetRecoilState: 状態の更新のみ

```jsx
// src/components/CounterControls.jsx
import { useSetRecoilState } from 'recoil'
import { counterAtom } from '../atoms/counterAtom'

function CounterControls() {
  const setCount = useSetRecoilState(counterAtom)
  
  return (
    <div>
      <button onClick={() => setCount(prev => prev + 1)}>増やす</button>
      <button onClick={() => setCount(prev => prev - 1)}>減らす</button>
    </div>
  )
}
```

### 実践例: ユーザー情報の管理

```jsx
// src/atoms/userAtom.js
import { atom } from 'recoil'

export const userAtom = atom({
  key: 'userAtom',
  default: {
    name: '',
    email: '',
    isLoggedIn: false
  }
})
```

```jsx
// src/components/UserProfile.jsx
import { useRecoilState } from 'recoil'
import { userAtom } from '../atoms/userAtom'

function UserProfile() {
  const [user, setUser] = useRecoilState(userAtom)
  
  const handleLogin = () => {
    setUser({
      name: '太郎',
      email: 'taro@example.com',
      isLoggedIn: true
    })
  }
  
  const handleLogout = () => {
    setUser({
      name: '',
      email: '',
      isLoggedIn: false
    })
  }
  
  return (
    <div>
      {user.isLoggedIn ? (
        <div>
          <p>名前: {user.name}</p>
          <p>メール: {user.email}</p>
          <button onClick={handleLogout}>ログアウト</button>
        </div>
      ) : (
        <button onClick={handleLogin}>ログイン</button>
      )}
    </div>
  )
}
```

```jsx
// src/components/UserDisplay.jsx
import { useRecoilValue } from 'recoil'
import { userAtom } from '../atoms/userAtom'

function UserDisplay() {
  const user = useRecoilValue(userAtom)
  
  return (
    <div>
      {user.isLoggedIn && (
        <p>ようこそ、{user.name}さん</p>
      )}
    </div>
  )
}
```

### 実践例: Selector（派生状態）

```jsx
// src/atoms/todosAtom.js
import { atom } from 'recoil'

export const todosAtom = atom({
  key: 'todosAtom',
  default: []
})
```

```jsx
// src/selectors/todosStatsSelector.js
import { selector } from 'recoil'
import { todosAtom } from '../atoms/todosAtom'

export const todosStatsSelector = selector({
  key: 'todosStatsSelector',
  get: ({ get }) => {
    const todos = get(todosAtom)
    return {
      total: todos.length,
      completed: todos.filter(todo => todo.completed).length,
      incomplete: todos.filter(todo => !todo.completed).length
    }
  }
})
```

```jsx
// src/components/TodosStats.jsx
import { useRecoilValue } from 'recoil'
import { todosStatsSelector } from '../selectors/todosStatsSelector'

function TodosStats() {
  const stats = useRecoilValue(todosStatsSelector)
  
  return (
    <div>
      <p>合計: {stats.total}</p>
      <p>完了: {stats.completed}</p>
      <p>未完了: {stats.incomplete}</p>
    </div>
  )
}
```

---

## Jotaiでのグローバルステート管理

### Jotaiとは

Jotaiは、**軽量でシンプルな状態管理ライブラリ**です。Recoilと同様にAtomベースですが、よりシンプルなAPIを提供します。

### インストール

```bash
npm install jotai
```

### Atomの定義

```jsx
// src/atoms/counterAtom.js
import { atom } from 'jotai'

export const counterAtom = atom(0)
```

### Atomの使用（参照と更新）

#### useAtom: 状態の参照と更新

```jsx
// src/components/Counter.jsx
import { useAtom } from 'jotai'
import { counterAtom } from '../atoms/counterAtom'

function Counter() {
  const [count, setCount] = useAtom(counterAtom)
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>増やす</button>
      <button onClick={() => setCount(count - 1)}>減らす</button>
    </div>
  )
}
```

#### useAtomValue: 状態の参照のみ

```jsx
// src/components/CounterDisplay.jsx
import { useAtomValue } from 'jotai'
import { counterAtom } from '../atoms/counterAtom'

function CounterDisplay() {
  const count = useAtomValue(counterAtom)
  
  return <p>カウント: {count}</p>
}
```

#### useSetAtom: 状態の更新のみ

```jsx
// src/components/CounterControls.jsx
import { useSetAtom } from 'jotai'
import { counterAtom } from '../atoms/counterAtom'

function CounterControls() {
  const setCount = useSetAtom(counterAtom)
  
  return (
    <div>
      <button onClick={() => setCount(prev => prev + 1)}>増やす</button>
      <button onClick={() => setCount(prev => prev - 1)}>減らす</button>
    </div>
  )
}
```

### 実践例: ユーザー情報の管理

```jsx
// src/atoms/userAtom.js
import { atom } from 'jotai'

export const userAtom = atom({
  name: '',
  email: '',
  isLoggedIn: false
})
```

```jsx
// src/components/UserProfile.jsx
import { useAtom } from 'jotai'
import { userAtom } from '../atoms/userAtom'

function UserProfile() {
  const [user, setUser] = useAtom(userAtom)
  
  const handleLogin = () => {
    setUser({
      name: '太郎',
      email: 'taro@example.com',
      isLoggedIn: true
    })
  }
  
  const handleLogout = () => {
    setUser({
      name: '',
      email: '',
      isLoggedIn: false
    })
  }
  
  return (
    <div>
      {user.isLoggedIn ? (
        <div>
          <p>名前: {user.name}</p>
          <p>メール: {user.email}</p>
          <button onClick={handleLogout}>ログアウト</button>
        </div>
      ) : (
        <button onClick={handleLogin}>ログイン</button>
      )}
    </div>
  )
}
```

### 実践例: 派生Atom（computed）

```jsx
// src/atoms/todosAtom.js
import { atom } from 'jotai'

export const todosAtom = atom([])
```

```jsx
// src/atoms/todosStatsAtom.js
import { atom } from 'jotai'
import { todosAtom } from './todosAtom'

export const todosStatsAtom = atom((get) => {
  const todos = get(todosAtom)
  return {
    total: todos.length,
    completed: todos.filter(todo => todo.completed).length,
    incomplete: todos.filter(todo => !todo.completed).length
  }
})
```

```jsx
// src/components/TodosStats.jsx
import { useAtomValue } from 'jotai'
import { todosStatsAtom } from '../atoms/todosStatsAtom'

function TodosStats() {
  const stats = useAtomValue(todosStatsAtom)
  
  return (
    <div>
      <p>合計: {stats.total}</p>
      <p>完了: {stats.completed}</p>
      <p>未完了: {stats.incomplete}</p>
    </div>
  )
}
```

---

## Zustandでのグローバルステート管理

### Zustandとは

Zustandは、**シンプルで軽量な状態管理ライブラリ**です。Storeベースのアプローチで、Reduxのような複雑さを避けています。

### インストール

```bash
npm install zustand
```

### Storeの定義

```jsx
// src/stores/counterStore.js
import { create } from 'zustand'

export const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}))
```

### Storeの使用（参照と更新）

```jsx
// src/components/Counter.jsx
import { useCounterStore } from '../stores/counterStore'

function Counter() {
  const { count, increment, decrement } = useCounterStore()
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={increment}>増やす</button>
      <button onClick={decrement}>減らす</button>
    </div>
  )
}
```

### 選択的な値の取得

```jsx
// src/components/CounterDisplay.jsx
import { useCounterStore } from '../stores/counterStore'

function CounterDisplay() {
  // 必要な値だけを取得（再レンダリングを最適化）
  const count = useCounterStore((state) => state.count)
  
  return <p>カウント: {count}</p>
}
```

```jsx
// src/components/CounterControls.jsx
import { useCounterStore } from '../stores/counterStore'

function CounterControls() {
  // 必要な関数だけを取得
  const increment = useCounterStore((state) => state.increment)
  const decrement = useCounterStore((state) => state.decrement)
  
  return (
    <div>
      <button onClick={increment}>増やす</button>
      <button onClick={decrement}>減らす</button>
    </div>
  )
}
```

### 実践例: ユーザー情報の管理

```jsx
// src/stores/userStore.js
import { create } from 'zustand'

export const useUserStore = create((set) => ({
  user: {
    name: '',
    email: '',
    isLoggedIn: false
  },
  login: (name, email) => set({
    user: {
      name,
      email,
      isLoggedIn: true
    }
  }),
  logout: () => set({
    user: {
      name: '',
      email: '',
      isLoggedIn: false
    }
  }),
}))
```

```jsx
// src/components/UserProfile.jsx
import { useUserStore } from '../stores/userStore'

function UserProfile() {
  const { user, login, logout } = useUserStore()
  
  const handleLogin = () => {
    login('太郎', 'taro@example.com')
  }
  
  return (
    <div>
      {user.isLoggedIn ? (
        <div>
          <p>名前: {user.name}</p>
          <p>メール: {user.email}</p>
          <button onClick={logout}>ログアウト</button>
        </div>
      ) : (
        <button onClick={handleLogin}>ログイン</button>
      )}
    </div>
  )
}
```

### 実践例: 非同期処理

```jsx
// src/stores/userStore.js
import { create } from 'zustand'

export const useUserStore = create((set) => ({
  user: null,
  loading: false,
  error: null,
  fetchUser: async (userId) => {
    set({ loading: true, error: null })
    try {
      const response = await fetch(`/api/users/${userId}`)
      const user = await response.json()
      set({ user, loading: false })
    } catch (error) {
      set({ error: error.message, loading: false })
    }
  },
}))
```

```jsx
// src/components/UserProfile.jsx
import { useEffect } from 'react'
import { useUserStore } from '../stores/userStore'

function UserProfile({ userId }) {
  const { user, loading, error, fetchUser } = useUserStore()
  
  useEffect(() => {
    fetchUser(userId)
  }, [userId, fetchUser])
  
  if (loading) return <div>読み込み中...</div>
  if (error) return <div>エラー: {error}</div>
  if (!user) return <div>ユーザーが見つかりません</div>
  
  return (
    <div>
      <p>名前: {user.name}</p>
      <p>メール: {user.email}</p>
    </div>
  )
}
```

---

## ライブラリの選び方

### 各ライブラリの特徴比較

| 特徴 | Recoil | Jotai | Zustand |
|------|--------|-------|---------|
| **開発元** | Facebook | コミュニティ | コミュニティ |
| **バンドルサイズ** | 約50KB | 約3KB | 約1KB |
| **学習コスト** | 中 | 低 | 低 |
| **TypeScript** | 完全サポート | 完全サポート | 完全サポート |
| **DevTools** | あり | あり（別パッケージ） | あり（別パッケージ） |
| **パフォーマンス** | 高 | 高 | 高 |
| **APIの複雑さ** | 中 | 低 | 低 |

### 選び方の指針

#### Recoilを選ぶべき場合

- **大規模なアプリケーション**: 複雑な状態管理が必要
- **Facebook製を信頼**: 公式サポートを重視
- **Selectorが必要**: 派生状態の管理が重要
- **DevToolsが重要**: デバッグツールが必要

#### Jotaiを選ぶべき場合

- **軽量性を重視**: バンドルサイズを最小限に
- **シンプルなAPI**: 学習コストを下げたい
- **Atomベース**: Recoilと似た概念だが、よりシンプル
- **TypeScript**: 完全な型サポートが必要

#### Zustandを選ぶべき場合

- **最小限の設定**: すぐに使いたい
- **Storeベース**: Reduxライクなアプローチを好む
- **軽量**: 最小限のバンドルサイズ
- **柔軟性**: カスタマイズ性が高い

### 実践例: プロジェクトタイプ別の推奨

#### 小規模プロジェクト

```javascript
// Zustandがおすすめ
// シンプルで軽量、すぐに使える
import { create } from 'zustand'

export const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}))
```

#### 中規模プロジェクト

```javascript
// Jotaiがおすすめ
// Atomベースで柔軟、軽量
import { atom } from 'jotai'

export const countAtom = atom(0)
```

#### 大規模プロジェクト

```javascript
// Recoilがおすすめ
// SelectorやDevToolsが充実
import { atom, selector } from 'recoil'

export const countAtom = atom({
  key: 'countAtom',
  default: 0,
})

export const doubleCountSelector = selector({
  key: 'doubleCountSelector',
  get: ({ get }) => get(countAtom) * 2,
})
```

### 移行の考慮事項

#### Context APIから移行する場合

- **Recoil**: 段階的な移行が可能、Atom単位で導入
- **Jotai**: 軽量で移行しやすい、APIがシンプル
- **Zustand**: Store単位で移行、既存コードとの統合が容易

#### Reduxから移行する場合

- **Zustand**: Storeベースで移行しやすい
- **Recoil**: 概念が異なるため、再設計が必要
- **Jotai**: 概念が異なるため、再設計が必要

### まとめ: 選び方のチェックリスト

1. **プロジェクトの規模**: 小規模→Zustand、中規模→Jotai、大規模→Recoil
2. **バンドルサイズ**: 重要→Jotai/Zustand、重要でない→Recoil
3. **学習コスト**: 低くしたい→Jotai/Zustand、問題ない→Recoil
4. **派生状態**: 必要→Recoil/Jotai、不要→Zustand
5. **DevTools**: 必要→Recoil、不要→Jotai/Zustand

---

## まとめ

この章では、Recoil、Jotai、Zustandを使用したグローバルステートの更新と参照について学びました。

### 学んだこと

- **Atomの概念**: 状態の最小単位、独立性と再利用性
- **Recoil**: Facebook製、SelectorやDevToolsが充実
- **Jotai**: 軽量でシンプル、Atomベース
- **Zustand**: 最小限の設定、Storeベース
- **ライブラリの選び方**: プロジェクトの要件に応じた選択

### 重要なポイント

1. **Atom**: 状態の最小単位、複数のコンポーネントで共有可能
2. **Recoil**: `useRecoilState`、`useRecoilValue`、`useSetRecoilState`で状態を管理
3. **Jotai**: `useAtom`、`useAtomValue`、`useSetAtom`で状態を管理
4. **Zustand**: `create`でStoreを作成し、フックで使用
5. **選び方**: プロジェクトの規模、要件、チームのスキルを考慮

### 使い分けの指針

- **小規模プロジェクト**: Zustand（シンプル、軽量）
- **中規模プロジェクト**: Jotai（Atomベース、柔軟）
- **大規模プロジェクト**: Recoil（Selector、DevTools）

### 次のステップ

次の章では、API連携とデータフェッチについて詳しく学びます。

---

## 演習問題

### 問題1: Recoilでのカウンター

Recoilを使用して、カウンターの状態を管理するコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
// src/atoms/counterAtom.js
import { atom } from 'recoil'

export const counterAtom = atom({
  key: 'counterAtom',
  default: 0
})
```

```jsx
// src/components/Counter.jsx
import { useRecoilState } from 'recoil'
import { counterAtom } from '../atoms/counterAtom'

function Counter() {
  const [count, setCount] = useRecoilState(counterAtom)
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>増やす</button>
      <button onClick={() => setCount(count - 1)}>減らす</button>
    </div>
  )
}

export default Counter
```
</details>

### 問題2: Jotaiでのユーザー情報

Jotaiを使用して、ユーザー情報を管理するコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
// src/atoms/userAtom.js
import { atom } from 'jotai'

export const userAtom = atom({
  name: '',
  email: ''
})
```

```jsx
// src/components/UserProfile.jsx
import { useAtom } from 'jotai'
import { userAtom } from '../atoms/userAtom'

function UserProfile() {
  const [user, setUser] = useAtom(userAtom)
  
  return (
    <div>
      <input
        value={user.name}
        onChange={(e) => setUser({ ...user, name: e.target.value })}
        placeholder="名前"
      />
      <input
        value={user.email}
        onChange={(e) => setUser({ ...user, email: e.target.value })}
        placeholder="メール"
      />
      <p>名前: {user.name}</p>
      <p>メール: {user.email}</p>
    </div>
  )
}

export default UserProfile
```
</details>

### 問題3: Zustandでのタスク管理

Zustandを使用して、タスクリストを管理するStoreとコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
// src/stores/taskStore.js
import { create } from 'zustand'

export const useTaskStore = create((set) => ({
  tasks: [],
  addTask: (task) => set((state) => ({
    tasks: [...state.tasks, task]
  })),
  removeTask: (id) => set((state) => ({
    tasks: state.tasks.filter(task => task.id !== id)
  }))
}))
```

```jsx
// src/components/TaskList.jsx
import { useState } from 'react'
import { useTaskStore } from '../stores/taskStore'

function TaskList() {
  const [input, setInput] = useState('')
  const { tasks, addTask, removeTask } = useTaskStore()
  
  const handleAdd = () => {
    if (input.trim()) {
      addTask({ id: Date.now(), text: input })
      setInput('')
    }
  }
  
  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="タスクを入力"
      />
      <button onClick={handleAdd}>追加</button>
      <ul>
        {tasks.map(task => (
          <li key={task.id}>
            {task.text}
            <button onClick={() => removeTask(task.id)}>削除</button>
          </li>
        ))}
      </ul>
    </div>
  )
}

export default TaskList
```
</details>

### 問題4: 複数のコンポーネントでの状態共有

Recoil、Jotai、またはZustandを使用して、複数のコンポーネントで同じ状態を共有してください。

<details>
<summary>解答例（Zustand）</summary>

```jsx
// src/stores/counterStore.js
import { create } from 'zustand'

export const useCounterStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 }))
}))
```

```jsx
// src/components/CounterDisplay.jsx
import { useCounterStore } from '../stores/counterStore'

function CounterDisplay() {
  const count = useCounterStore((state) => state.count)
  return <p>カウント: {count}</p>
}

export default CounterDisplay
```

```jsx
// src/components/CounterControls.jsx
import { useCounterStore } from '../stores/counterStore'

function CounterControls() {
  const { increment, decrement } = useCounterStore()
  return (
    <div>
      <button onClick={increment}>増やす</button>
      <button onClick={decrement}>減らす</button>
    </div>
  )
}

export default CounterControls
```
</details>

### 問題5: ライブラリの選び方

あなたのプロジェクトに適した状態管理ライブラリを選び、その理由を説明してください。

<details>
<summary>解答例</summary>

**小規模プロジェクトの場合（Zustand推奨）**

理由:
- バンドルサイズが最小（約1KB）
- 設定が簡単で、すぐに使える
- Storeベースで理解しやすい
- TypeScriptのサポートが充実

**中規模プロジェクトの場合（Jotai推奨）**

理由:
- Atomベースで柔軟性が高い
- バンドルサイズが小さい（約3KB）
- APIがシンプルで学習コストが低い
- 派生状態の管理が容易

**大規模プロジェクトの場合（Recoil推奨）**

理由:
- Selectorによる派生状態の管理が充実
- DevToolsによるデバッグが容易
- Facebook製で公式サポートがある
- 複雑な状態管理に対応可能
</details>

---

お疲れ様でした！次の章に進みましょう。
