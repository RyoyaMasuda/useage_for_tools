# 12-1. 実務レベルのSPAアーキテクチャ構築（堅牢なプロジェクトセットアップ）

この章では、実務レベルのReactアプリケーションを構築するための堅牢なプロジェクトセットアップについて学びます。Vite、TypeScript、UIライブラリを統合し、スケーラブルなディレクトリ構成を実現することで、保守性の高いアプリケーションを開発できるようになります。

---

## 目次

- [Vite + TypeScript + UIライブラリ (Chakra UI/MUI) の統合設定](#vite--typescript--uiライブラリ-chakra-uimui-の統合設定)
- [スケーラブルなディレクトリ構成のベストプラクティス](#スケーラブルなディレクトリ構成のベストプラクティス)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Vite + TypeScript + UIライブラリ (Chakra UI/MUI) の統合設定

### プロジェクトセットアップとは
プロジェクトセットアップは、**開発環境を構築し、必要なツールやライブラリを統合する**作業です。適切なセットアップにより、開発効率が向上し、保守性の高いコードを書けるようになります。

### 日常生活での例
- **家の建築**: 基礎工事（Vite）をして、構造（TypeScript）を組み立て、内装（UIライブラリ）を整える
- **レストランの開店準備**: 厨房設備（Vite）を整え、メニュー（TypeScript）を設計し、店内装飾（UIライブラリ）を行う
- **工場の建設**: 製造ライン（Vite）を設置し、品質管理システム（TypeScript）を構築し、作業環境（UIライブラリ）を整える

### Viteとは
Viteは、**高速な開発サーバーとビルドツール**です。従来のツールよりも高速で、開発体験が向上します。

### TypeScriptとは
TypeScriptは、**JavaScriptに型システムを追加した言語**です。型安全性により、バグを早期に発見でき、コードの保守性が向上します。

### UIライブラリとは
UIライブラリは、**再利用可能なUIコンポーネントを提供する**ライブラリです。Chakra UIやMaterial-UI（MUI）などがあり、開発効率が向上します。

### プロジェクトの作成

```bash
# Vite + React + TypeScriptでプロジェクトを作成
npm create vite@latest my-app -- --template react-ts

# プロジェクトディレクトリに移動
cd my-app

# 依存関係をインストール
npm install
```

### 実践例: Vite + TypeScriptの基本設定

```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
    plugins: [react()],
    resolve: {
        alias: {
            '@': path.resolve(__dirname, './src')
        }
    },
    server: {
        port: 3000,
        open: true
    }
});

// tsconfig.json
{
    "compilerOptions": {
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "module": "ESNext",
        "skipLibCheck": true,
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx",
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "noFallthroughCasesInSwitch": true,
        "baseUrl": ".",
        "paths": {
            "@/*": ["./src/*"]
        }
    },
    "include": ["src"],
    "references": [{ "path": "./tsconfig.node.json" }]
}
```

### Chakra UIのインストールと設定

```bash
# Chakra UIをインストール
npm install @chakra-ui/react @emotion/react @emotion/styled framer-motion
```

```typescript
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ChakraProvider } from '@chakra-ui/react';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <ChakraProvider>
            <App />
        </ChakraProvider>
    </React.StrictMode>
);

// src/App.tsx
import { Box, Heading, Button } from '@chakra-ui/react';

function App() {
    return (
        <Box p={8}>
            <Heading mb={4}>Chakra UIのサンプル</Heading>
            <Button colorScheme="blue">クリック</Button>
        </Box>
    );
}

export default App;
```

### Material-UI (MUI)のインストールと設定

```bash
# MUIをインストール
npm install @mui/material @emotion/react @emotion/styled
npm install @mui/icons-material
```

```typescript
// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import App from './App';

const theme = createTheme({
    palette: {
        primary: {
            main: '#1976d2'
        },
        secondary: {
            main: '#dc004e'
        }
    }
});

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <ThemeProvider theme={theme}>
            <CssBaseline />
            <App />
        </ThemeProvider>
    </React.StrictMode>
);

// src/App.tsx
import { Container, Typography, Button, Box } from '@mui/material';

function App() {
    return (
        <Container>
            <Box sx={{ py: 4 }}>
                <Typography variant="h4" component="h1" gutterBottom>
                    MUIのサンプル
                </Typography>
                <Button variant="contained" color="primary">
                    クリック
                </Button>
            </Box>
        </Container>
    );
}

export default App;
```

### 実践例: 統合設定ファイル

```typescript
// src/config/theme.ts (Chakra UI)
import { extendTheme } from '@chakra-ui/react';

export const theme = extendTheme({
    colors: {
        brand: {
            50: '#e3f2fd',
            100: '#bbdefb',
            200: '#90caf9',
            300: '#64b5f6',
            400: '#42a5f5',
            500: '#2196f3',
            600: '#1e88e5',
            700: '#1976d2',
            800: '#1565c0',
            900: '#0d47a1'
        }
    },
    fonts: {
        heading: 'Inter, sans-serif',
        body: 'Inter, sans-serif'
    },
    components: {
        Button: {
            defaultProps: {
                colorScheme: 'brand'
            }
        }
    }
});

// src/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ChakraProvider } from '@chakra-ui/react';
import { theme } from './config/theme';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <React.StrictMode>
        <ChakraProvider theme={theme}>
            <App />
        </ChakraProvider>
    </React.StrictMode>
);
```

### 実践例: 環境変数の設定

```typescript
// .env
VITE_API_URL=http://localhost:3000/api
VITE_APP_NAME=My App

// .env.production
VITE_API_URL=https://api.example.com
VITE_APP_NAME=My App

// src/config/env.ts
interface Env {
    apiUrl: string;
    appName: string;
}

export const env: Env = {
    apiUrl: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
    appName: import.meta.env.VITE_APP_NAME || 'My App'
};

// src/utils/api.ts
import { env } from '../config/env';

export const apiClient = {
    baseURL: env.apiUrl,
    // APIクライアントの設定
};
```

### 実践例: ESLintとPrettierの設定

```json
// .eslintrc.cjs
module.exports = {
    root: true,
    env: { browser: true, es2020: true },
    extends: [
        'eslint:recommended',
        'plugin:@typescript-eslint/recommended',
        'plugin:react-hooks/recommended',
        'plugin:react/recommended',
        'plugin:react/jsx-runtime'
    ],
    ignorePatterns: ['dist', '.eslintrc.cjs'],
    parser: '@typescript-eslint/parser',
    plugins: ['react-refresh'],
    rules: {
        'react-refresh/only-export-components': [
            'warn',
            { allowConstantExport: true }
        ],
        '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }]
    }
};

// .prettierrc
{
    "semi": true,
    "trailingComma": "es5",
    "singleQuote": true,
    "printWidth": 80,
    "tabWidth": 2,
    "useTabs": false
}

// package.json
{
    "scripts": {
        "dev": "vite",
        "build": "tsc && vite build",
        "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
        "preview": "vite preview",
        "format": "prettier --write \"src/**/*.{ts,tsx,json,css}\""
    }
}
```

---

## スケーラブルなディレクトリ構成のベストプラクティス

### ディレクトリ構成とは
ディレクトリ構成は、**プロジェクトのファイルを整理する構造**です。適切な構成により、コードの可読性と保守性が向上し、チーム開発が効率的になります。

### 日常生活での例
- **図書館の分類**: 本をジャンル別に分類し、同じ種類の本を同じ場所に配置する
- **会社の組織**: 部署ごとに分かれ、各部署内でさらに細分化する
- **学校の時間割**: 科目ごとに分類し、関連する科目を近くに配置する

### 基本的なディレクトリ構成

```
my-app/
├── public/                 # 静的ファイル
├── src/
│   ├── assets/            # 画像、フォントなどの静的リソース
│   ├── components/        # 再利用可能なコンポーネント
│   │   ├── atoms/        # 最小単位のコンポーネント
│   │   ├── molecules/    # Atomsを組み合わせたコンポーネント
│   │   ├── organisms/    # Moleculesを組み合わせたコンポーネント
│   │   └── templates/    # ページの骨組み
│   ├── pages/            # ページコンポーネント
│   ├── hooks/            # カスタムフック
│   ├── utils/            # ユーティリティ関数
│   ├── services/         # API呼び出しなどのサービス
│   ├── store/            # 状態管理（Redux、Zustandなど）
│   ├── types/            # TypeScriptの型定義
│   ├── config/           # 設定ファイル
│   ├── constants/        # 定数
│   ├── styles/           # グローバルスタイル
│   ├── App.tsx           # ルートコンポーネント
│   └── main.tsx          # エントリーポイント
├── .env                  # 環境変数
├── .eslintrc.cjs         # ESLint設定
├── .prettierrc           # Prettier設定
├── tsconfig.json         # TypeScript設定
├── vite.config.ts        # Vite設定
└── package.json          # 依存関係
```

### 実践例: 詳細なディレクトリ構成

```
src/
├── assets/
│   ├── images/
│   ├── icons/
│   └── fonts/
├── components/
│   ├── atoms/
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.test.tsx
│   │   │   └── index.ts
│   │   ├── Input/
│   │   └── Label/
│   ├── molecules/
│   │   ├── FormField/
│   │   ├── SearchBar/
│   │   └── UserCard/
│   ├── organisms/
│   │   ├── Header/
│   │   ├── Sidebar/
│   │   └── Footer/
│   └── templates/
│       ├── DashboardTemplate/
│       └── AuthTemplate/
├── pages/
│   ├── Home/
│   │   ├── Home.tsx
│   │   ├── Home.test.tsx
│   │   └── index.ts
│   ├── About/
│   ├── Login/
│   └── Dashboard/
├── hooks/
│   ├── useAuth.ts
│   ├── useUsers.ts
│   └── useProducts.ts
├── services/
│   ├── api/
│   │   ├── client.ts
│   │   ├── users.ts
│   │   └── products.ts
│   └── storage/
│       └── localStorage.ts
├── store/
│   ├── slices/
│   │   ├── authSlice.ts
│   │   └── userSlice.ts
│   └── store.ts
├── types/
│   ├── user.ts
│   ├── product.ts
│   └── api.ts
├── config/
│   ├── theme.ts
│   ├── env.ts
│   └── routes.ts
├── constants/
│   ├── routes.ts
│   └── messages.ts
├── utils/
│   ├── format.ts
│   ├── validation.ts
│   └── helpers.ts
├── styles/
│   ├── global.css
│   └── variables.css
├── App.tsx
└── main.tsx
```

### 実践例: コンポーネントの構成

```typescript
// src/components/atoms/Button/Button.tsx
import { Button as ChakraButton, ButtonProps as ChakraButtonProps } from '@chakra-ui/react';

export interface ButtonProps extends ChakraButtonProps {
    variant?: 'primary' | 'secondary' | 'danger';
}

export function Button({ variant = 'primary', children, ...props }: ButtonProps) {
    const colorScheme = {
        primary: 'blue',
        secondary: 'gray',
        danger: 'red'
    }[variant];

    return (
        <ChakraButton colorScheme={colorScheme} {...props}>
            {children}
        </ChakraButton>
    );
}

// src/components/atoms/Button/index.ts
export { Button } from './Button';
export type { ButtonProps } from './Button';

// src/components/atoms/Button/Button.test.tsx
import { render, screen } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
    it('renders correctly', () => {
        render(<Button>クリック</Button>);
        expect(screen.getByText('クリック')).toBeInTheDocument();
    });
});
```

### 実践例: ページコンポーネントの構成

```typescript
// src/pages/Home/Home.tsx
import { Box, Heading } from '@chakra-ui/react';
import { Header } from '@/components/organisms/Header';
import { Footer } from '@/components/organisms/Footer';

export function Home() {
    return (
        <Box>
            <Header />
            <Box as="main" p={8}>
                <Heading>ホームページ</Heading>
                <p>ようこそ、ホームページへ！</p>
            </Box>
            <Footer />
        </Box>
    );
}

// src/pages/Home/index.ts
export { Home } from './Home';

// src/pages/Home/Home.test.tsx
import { render, screen } from '@testing-library/react';
import { Home } from './Home';

describe('Home', () => {
    it('renders correctly', () => {
        render(<Home />);
        expect(screen.getByText('ホームページ')).toBeInTheDocument();
    });
});
```

### 実践例: カスタムフックの構成

```typescript
// src/hooks/useAuth.ts
import { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { authService } from '@/services/api/auth';

export function useAuth() {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    useEffect(() => {
        const initAuth = async () => {
            try {
                const user = await authService.getCurrentUser();
                setUser(user);
            } catch (error) {
                setUser(null);
            } finally {
                setLoading(false);
            }
        };

        initAuth();
    }, []);

    const login = async (email: string, password: string) => {
        const user = await authService.login(email, password);
        setUser(user);
        navigate('/dashboard');
    };

    const logout = async () => {
        await authService.logout();
        setUser(null);
        navigate('/login');
    };

    return {
        user,
        loading,
        login,
        logout,
        isAuthenticated: !!user
    };
}
```

### 実践例: サービス層の構成

```typescript
// src/services/api/client.ts
import axios from 'axios';
import { env } from '@/config/env';

export const apiClient = axios.create({
    baseURL: env.apiUrl,
    timeout: 10000,
    headers: {
        'Content-Type': 'application/json'
    }
});

// リクエストインターセプター
apiClient.interceptors.request.use(
    (config) => {
        const token = localStorage.getItem('token');
        if (token) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    (error) => {
        return Promise.reject(error);
    }
);

// レスポンスインターセプター
apiClient.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            localStorage.removeItem('token');
            window.location.href = '/login';
        }
        return Promise.reject(error);
    }
);

// src/services/api/users.ts
import { apiClient } from './client';
import { User } from '@/types/user';

export const userService = {
    async getUsers(): Promise<User[]> {
        const response = await apiClient.get<User[]>('/users');
        return response.data;
    },

    async getUser(id: string): Promise<User> {
        const response = await apiClient.get<User>(`/users/${id}`);
        return response.data;
    },

    async createUser(data: Omit<User, 'id'>): Promise<User> {
        const response = await apiClient.post<User>('/users', data);
        return response.data;
    },

    async updateUser(id: string, data: Partial<User>): Promise<User> {
        const response = await apiClient.put<User>(`/users/${id}`, data);
        return response.data;
    },

    async deleteUser(id: string): Promise<void> {
        await apiClient.delete(`/users/${id}`);
    }
};
```

### 実践例: 型定義の構成

```typescript
// src/types/user.ts
export interface User {
    id: string;
    name: string;
    email: string;
    age: number;
    createdAt: string;
    updatedAt: string;
}

export interface CreateUserDto {
    name: string;
    email: string;
    age: number;
}

export interface UpdateUserDto {
    name?: string;
    email?: string;
    age?: number;
}

// src/types/api.ts
export interface ApiResponse<T> {
    data: T;
    message?: string;
}

export interface ApiError {
    message: string;
    code?: string;
    errors?: Record<string, string[]>;
}

// src/types/index.ts
export * from './user';
export * from './api';
```

### 実践例: 設定ファイルの構成

```typescript
// src/config/routes.ts
export const routes = {
    home: '/',
    about: '/about',
    login: '/login',
    dashboard: '/dashboard',
    users: '/users',
    products: '/products'
} as const;

// src/config/theme.ts
import { extendTheme } from '@chakra-ui/react';

export const theme = extendTheme({
    // テーマ設定
});

// src/constants/messages.ts
export const messages = {
    errors: {
        required: 'この項目は必須です',
        email: '有効なメールアドレスを入力してください',
        minLength: '最小文字数に達していません'
    },
    success: {
        saved: '保存しました',
        deleted: '削除しました'
    }
} as const;
```

### ディレクトリ構成のベストプラクティス
1. **機能ごとに分ける**: 関連するファイルを同じディレクトリに配置
2. **階層を深くしすぎない**: 3〜4階層程度に抑える
3. **一貫性を保つ**: プロジェクト全体で同じ構成ルールを適用
4. **index.tsを使う**: エクスポートをまとめて、インポートを簡潔に
5. **テストファイルを近くに配置**: コンポーネントと同じディレクトリにテストファイルを配置

---

## まとめ

この章では、堅牢なプロジェクトセットアップについて以下のことを学びました。

### Vite + TypeScript + UIライブラリの統合設定
- **Vite**: 高速な開発サーバーとビルドツール
- **TypeScript**: 型安全性を提供する言語
- **Chakra UI / MUI**: 再利用可能なUIコンポーネントを提供
- **環境変数**: 環境ごとの設定を管理
- **ESLint / Prettier**: コードの品質と一貫性を保つ

### スケーラブルなディレクトリ構成のベストプラクティス
- **機能ごとの分離**: 関連するファイルを同じディレクトリに配置
- **Atomic Design**: Atoms、Molecules、Organisms、Templatesに分類
- **サービス層の分離**: API呼び出しをサービス層に集約
- **型定義の管理**: TypeScriptの型定義を一元管理
- **設定ファイルの整理**: テーマ、環境変数、ルートなどを整理

### プロジェクトセットアップのメリット
- **開発効率**: 適切なツールと構成により、開発が効率的になる
- **保守性**: 整理された構成により、コードの保守が容易になる
- **スケーラビリティ**: プロジェクトが大きくなっても管理しやすい
- **チーム開発**: 一貫した構成により、チーム開発が効率的になる

### 次のステップ
プロジェクトセットアップを理解したら、次のトピックに進みましょう：
- 認証機能のアーキテクチャ（12-2）
- APIクライアントの共通化（12-3）
- UIフィードバックの共通化（12-4）

---

## 演習問題

以下の問題を解いて、プロジェクトセットアップの理解を深めましょう。

### 問題1: Vite + TypeScriptプロジェクトの作成
Vite + React + TypeScriptでプロジェクトを作成し、基本的な設定を行ってください。

<details>
<summary>解答例</summary>

```bash
# プロジェクトの作成
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install

# 基本的な設定
# vite.config.tsとtsconfig.jsonを設定
```
</details>

### 問題2: Chakra UIの統合
Chakra UIをインストールし、テーマを設定して使用してください。

<details>
<summary>解答例</summary>

```bash
npm install @chakra-ui/react @emotion/react @emotion/styled framer-motion
```

```typescript
// src/main.tsx
import { ChakraProvider } from '@chakra-ui/react';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
    <ChakraProvider>
        <App />
    </ChakraProvider>
);
```
</details>

### 問題3: ディレクトリ構成の作成
Atomic Designに基づいたディレクトリ構成を作成してください。

<details>
<summary>解答例</summary>

```
src/
├── components/
│   ├── atoms/
│   ├── molecules/
│   ├── organisms/
│   └── templates/
├── pages/
├── hooks/
├── services/
├── types/
└── config/
```
</details>

### 問題4: カスタムフックの作成
ユーザー一覧を取得するカスタムフックを作成し、適切なディレクトリに配置してください。

<details>
<summary>解答例</summary>

```typescript
// src/hooks/useUsers.ts
import { useState, useEffect } from 'react';
import { userService } from '@/services/api/users';

export function useUsers() {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        userService.getUsers().then(setUsers).finally(() => setLoading(false));
    }, []);

    return { users, loading };
}
```
</details>

### 問題5: サービス層の作成
APIクライアントとユーザーサービスを作成し、適切なディレクトリに配置してください。

<details>
<summary>解答例</summary>

```typescript
// src/services/api/client.ts
import axios from 'axios';

export const apiClient = axios.create({
    baseURL: import.meta.env.VITE_API_URL
});

// src/services/api/users.ts
import { apiClient } from './client';

export const userService = {
    getUsers: () => apiClient.get('/users').then(res => res.data)
};
```
</details>

---

お疲れ様でした！次の章に進みましょう。

