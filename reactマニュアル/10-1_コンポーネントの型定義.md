# 10-1. コンポーネントの型定義

この章では、ReactとTypeScriptを組み合わせて、コンポーネントの型を定義する方法について学びます。型定義を適切に行うことで、より安全で保守しやすいコードを書けるようになります。

---

## 目次

- [Propsの型定義 (type / interface)](#propsの型定義-type--interface)
- [イベントハンドラーの型](#イベントハンドラーの型)
- [children (React.ReactNode) の型](#children-reactreactnode-の型)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Propsの型定義 (type / interface)

### Propsの型定義とは
Propsの型定義は、**コンポーネントが受け取るPropsの型を明示的に指定する**ことです。TypeScriptを使用することで、間違ったPropsを渡すとエラーになります。

### 日常生活での例
- **レシピの材料リスト**: 必要な材料とその量が決まっている
- **申込書**: 記入すべき項目とその形式が決まっている
- **契約書**: 必要な情報とその型が決まっている

### typeとinterfaceの違い

| 特徴 | type | interface |
|------|------|-----------|
| **拡張** | 交差型（&） | extends |
| **マージ** | 不可 | 可能（宣言のマージ） |
| **ユニオン型** | 可能 | 不可 |
| **プリミティブ型** | 可能 | 不可 |

### typeを使ったPropsの型定義

```typescript
type ButtonProps = {
    label: string;
    onClick: () => void;
    disabled?: boolean;
};

function Button({ label, onClick, disabled }: ButtonProps) {
    return (
        <button onClick={onClick} disabled={disabled}>
            {label}
        </button>
    );
}
```

### 実践例: typeを使ったPropsの型定義

```typescript
// src/components/Button/Button.tsx
type ButtonProps = {
    label: string;
    onClick: () => void;
    variant?: 'primary' | 'secondary' | 'danger';
    size?: 'small' | 'medium' | 'large';
    disabled?: boolean;
};

function Button({ 
    label, 
    onClick, 
    variant = 'primary',
    size = 'medium',
    disabled = false 
}: ButtonProps) {
    return (
        <button 
            onClick={onClick} 
            disabled={disabled}
            className={`btn btn-${variant} btn-${size}`}
        >
            {label}
        </button>
    );
}

export default Button;
```

### interfaceを使ったPropsの型定義

```typescript
interface ButtonProps {
    label: string;
    onClick: () => void;
    disabled?: boolean;
}

function Button({ label, onClick, disabled }: ButtonProps) {
    return (
        <button onClick={onClick} disabled={disabled}>
            {label}
        </button>
    );
}
```

### 実践例: interfaceを使ったPropsの型定義

```typescript
// src/components/UserCard/UserCard.tsx
interface UserCardProps {
    name: string;
    age: number;
    email: string;
    avatar?: string;
    onEdit?: () => void;
    onDelete?: () => void;
}

function UserCard({ 
    name, 
    age, 
    email, 
    avatar, 
    onEdit, 
    onDelete 
}: UserCardProps) {
    return (
        <div className="user-card">
            {avatar && <img src={avatar} alt={name} />}
            <h3>{name}</h3>
            <p>年齢: {age}歳</p>
            <p>メール: {email}</p>
            {onEdit && <button onClick={onEdit}>編集</button>}
            {onDelete && <button onClick={onDelete}>削除</button>}
        </div>
    );
}

export default UserCard;
```

### 実践例: 複雑なPropsの型定義

```typescript
// src/components/Form/Form.tsx
type FormField = {
    name: string;
    label: string;
    type: 'text' | 'email' | 'password' | 'number';
    required?: boolean;
    placeholder?: string;
};

interface FormProps {
    fields: FormField[];
    onSubmit: (data: Record<string, string>) => void;
    submitLabel?: string;
    className?: string;
}

function Form({ 
    fields, 
    onSubmit, 
    submitLabel = '送信',
    className 
}: FormProps) {
    const [formData, setFormData] = useState<Record<string, string>>({});
    
    const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        onSubmit(formData);
    };
    
    const handleChange = (name: string, value: string) => {
        setFormData(prev => ({ ...prev, [name]: value }));
    };
    
    return (
        <form onSubmit={handleSubmit} className={className}>
            {fields.map(field => (
                <div key={field.name}>
                    <label>
                        {field.label}
                        {field.required && <span>*</span>}
                    </label>
                    <input
                        type={field.type}
                        name={field.name}
                        value={formData[field.name] || ''}
                        onChange={(e) => handleChange(field.name, e.target.value)}
                        placeholder={field.placeholder}
                        required={field.required}
                    />
                </div>
            ))}
            <button type="submit">{submitLabel}</button>
        </form>
    );
}

export default Form;
```

### 実践例: ジェネリクスを使ったProps

```typescript
// src/components/List/List.tsx
interface ListProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
    keyExtractor: (item: T) => string | number;
    emptyMessage?: string;
}

function List<T>({ 
    items, 
    renderItem, 
    keyExtractor, 
    emptyMessage = 'アイテムがありません' 
}: ListProps<T>) {
    if (items.length === 0) {
        return <div>{emptyMessage}</div>;
    }
    
    return (
        <ul>
            {items.map(item => (
                <li key={keyExtractor(item)}>
                    {renderItem(item)}
                </li>
            ))}
        </ul>
    );
}

export default List;

// 使用例
interface User {
    id: number;
    name: string;
    email: string;
}

function UserList({ users }: { users: User[] }) {
    return (
        <List
            items={users}
            renderItem={(user) => (
                <div>
                    <h3>{user.name}</h3>
                    <p>{user.email}</p>
                </div>
            )}
            keyExtractor={(user) => user.id}
        />
    );
}
```

### 実践例: 型の拡張

```typescript
// src/components/Button/Button.tsx
interface BaseButtonProps {
    label: string;
    onClick: () => void;
    disabled?: boolean;
}

interface ButtonProps extends BaseButtonProps {
    variant?: 'primary' | 'secondary' | 'danger';
    size?: 'small' | 'medium' | 'large';
}

// HTMLのbutton要素の属性も継承
interface ExtendedButtonProps extends ButtonProps, React.ButtonHTMLAttributes<HTMLButtonElement> {}

function Button(props: ExtendedButtonProps) {
    const { label, onClick, variant = 'primary', size = 'medium', ...rest } = props;
    
    return (
        <button 
            onClick={onClick}
            className={`btn btn-${variant} btn-${size}`}
            {...rest}
        >
            {label}
        </button>
    );
}

export default Button;
```

### 実践例: 条件付き型

```typescript
// src/components/Card/Card.tsx
type CardProps = {
    title: string;
    children: React.ReactNode;
} & (
    | { clickable: true; onClick: () => void }
    | { clickable?: false; onClick?: never }
);

function Card({ title, children, clickable, onClick }: CardProps) {
    const handleClick = () => {
        if (clickable && onClick) {
            onClick();
        }
    };
    
    return (
        <div 
            className={`card ${clickable ? 'clickable' : ''}`}
            onClick={handleClick}
        >
            <h2>{title}</h2>
            {children}
        </div>
    );
}

export default Card;
```

---

## イベントハンドラーの型

### イベントハンドラーの型とは
イベントハンドラーの型は、**イベント処理関数の引数と戻り値の型を定義する**ことです。TypeScriptでは、Reactのイベント型を使用します。

### Reactのイベント型

| イベント | 型 |
|---------|-----|
| **クリック** | `React.MouseEvent<HTMLElement>` |
| **変更** | `React.ChangeEvent<HTMLInputElement>` |
| **送信** | `React.FormEvent<HTMLFormElement>` |
| **フォーカス** | `React.FocusEvent<HTMLElement>` |
| **キーボード** | `React.KeyboardEvent<HTMLElement>` |

### 基本的なイベントハンドラーの型

```typescript
function Button({ onClick }: { onClick: (e: React.MouseEvent<HTMLButtonElement>) => void }) {
    return <button onClick={onClick}>クリック</button>;
}
```

### 実践例: クリックイベントの型

```typescript
// src/components/Button/Button.tsx
interface ButtonProps {
    label: string;
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => void;
    disabled?: boolean;
}

function Button({ label, onClick, disabled }: ButtonProps) {
    return (
        <button onClick={onClick} disabled={disabled}>
            {label}
        </button>
    );
}

export default Button;

// 使用例
function App() {
    const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        console.log('クリックされました', e.currentTarget);
    };
    
    return <Button label="クリック" onClick={handleClick} />;
}
```

### 実践例: 入力イベントの型

```typescript
// src/components/Input/Input.tsx
interface InputProps {
    value: string;
    onChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    placeholder?: string;
    type?: 'text' | 'email' | 'password' | 'number';
}

function Input({ value, onChange, placeholder, type = 'text' }: InputProps) {
    return (
        <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
        />
    );
}

export default Input;

// 使用例
function Form() {
    const [email, setEmail] = useState('');
    
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        setEmail(e.target.value);
    };
    
    return (
        <Input
            type="email"
            value={email}
            onChange={handleChange}
            placeholder="メールアドレス"
        />
    );
}
```

### 実践例: フォーム送信イベントの型

```typescript
// src/components/LoginForm/LoginForm.tsx
interface LoginFormProps {
    onSubmit: (data: { email: string; password: string }) => void;
}

function LoginForm({ onSubmit }: LoginFormProps) {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');
    
    const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        onSubmit({ email, password });
    };
    
    return (
        <form onSubmit={handleSubmit}>
            <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="メールアドレス"
            />
            <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="パスワード"
            />
            <button type="submit">ログイン</button>
        </form>
    );
}

export default LoginForm;
```

### 実践例: キーボードイベントの型

```typescript
// src/components/SearchInput/SearchInput.tsx
interface SearchInputProps {
    value: string;
    onChange: (value: string) => void;
    onEnter?: () => void;
    placeholder?: string;
}

function SearchInput({ value, onChange, onEnter, placeholder }: SearchInputProps) {
    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        onChange(e.target.value);
    };
    
    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
        if (e.key === 'Enter' && onEnter) {
            onEnter();
        }
    };
    
    return (
        <input
            type="text"
            value={value}
            onChange={handleChange}
            onKeyDown={handleKeyDown}
            placeholder={placeholder}
        />
    );
}

export default SearchInput;
```

### 実践例: カスタムイベントハンドラー

```typescript
// src/components/CustomButton/CustomButton.tsx
interface CustomButtonProps {
    label: string;
    onClick: (id: number, name: string) => void;
    id: number;
    name: string;
}

function CustomButton({ label, onClick, id, name }: CustomButtonProps) {
    const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
        e.preventDefault();
        onClick(id, name);
    };
    
    return <button onClick={handleClick}>{label}</button>;
}

export default CustomButton;

// 使用例
function App() {
    const handleItemClick = (id: number, name: string) => {
        console.log(`アイテム ${id}: ${name} がクリックされました`);
    };
    
    return (
        <CustomButton
            label="アイテム1"
            onClick={handleItemClick}
            id={1}
            name="商品A"
        />
    );
}
```

### 実践例: イベントハンドラーの型エイリアス

```typescript
// src/types/events.ts
export type ButtonClickHandler = (e: React.MouseEvent<HTMLButtonElement>) => void;
export type InputChangeHandler = (e: React.ChangeEvent<HTMLInputElement>) => void;
export type FormSubmitHandler = (e: React.FormEvent<HTMLFormElement>) => void;

// src/components/Button/Button.tsx
import { ButtonClickHandler } from '../../types/events';

interface ButtonProps {
    label: string;
    onClick: ButtonClickHandler;
}

function Button({ label, onClick }: ButtonProps) {
    return <button onClick={onClick}>{label}</button>;
}

export default Button;
```

---

## children (React.ReactNode) の型

### childrenの型とは
childrenの型は、**コンポーネントが受け取る子要素の型を定義する**ことです。Reactでは、`React.ReactNode`型を使用します。

### React.ReactNodeとは
`React.ReactNode`は、**Reactがレンダリングできるすべての型**を表します。文字列、数値、要素、配列、null、undefinedなどが含まれます。

### 基本的なchildrenの型定義

```typescript
interface ContainerProps {
    children: React.ReactNode;
}

function Container({ children }: ContainerProps) {
    return <div>{children}</div>;
}
```

### 実践例: 基本的なchildrenの使用

```typescript
// src/components/Card/Card.tsx
interface CardProps {
    title: string;
    children: React.ReactNode;
}

function Card({ title, children }: CardProps) {
    return (
        <div className="card">
            <h2>{title}</h2>
            <div className="card-body">
                {children}
            </div>
        </div>
    );
}

export default Card;

// 使用例
function App() {
    return (
        <Card title="ユーザー情報">
            <p>名前: 太郎</p>
            <p>年齢: 25歳</p>
        </Card>
    );
}
```

### 実践例: オプショナルなchildren

```typescript
// src/components/Modal/Modal.tsx
interface ModalProps {
    title: string;
    isOpen: boolean;
    onClose: () => void;
    children?: React.ReactNode;
}

function Modal({ title, isOpen, onClose, children }: ModalProps) {
    if (!isOpen) return null;
    
    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="modal-content" onClick={(e) => e.stopPropagation()}>
                <div className="modal-header">
                    <h2>{title}</h2>
                    <button onClick={onClose}>×</button>
                </div>
                {children && (
                    <div className="modal-body">
                        {children}
                    </div>
                )}
            </div>
        </div>
    );
}

export default Modal;
```

### 実践例: 特定の型のchildren

```typescript
// src/components/List/List.tsx
interface ListProps {
    children: React.ReactElement | React.ReactElement[];
}

function List({ children }: ListProps) {
    return (
        <ul>
            {Array.isArray(children) 
                ? children.map((child, index) => <li key={index}>{child}</li>)
                : <li>{children}</li>
            }
        </ul>
    );
}

export default List;
```

### 実践例: 関数としてのchildren（レンダープロップ）

```typescript
// src/components/DataFetcher/DataFetcher.tsx
interface DataFetcherProps<T> {
    url: string;
    children: (data: T | null, loading: boolean, error: Error | null) => React.ReactNode;
}

function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
    const [data, setData] = useState<T | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);
    
    useEffect(() => {
        fetch(url)
            .then(res => res.json())
            .then(data => {
                setData(data);
                setLoading(false);
            })
            .catch(err => {
                setError(err);
                setLoading(false);
            });
    }, [url]);
    
    return <>{children(data, loading, error)}</>;
}

export default DataFetcher;

// 使用例
function App() {
    return (
        <DataFetcher<{ name: string; age: number }>
            url="/api/user"
        >
            {(data, loading, error) => {
                if (loading) return <div>読み込み中...</div>;
                if (error) return <div>エラー: {error.message}</div>;
                if (!data) return <div>データがありません</div>;
                
                return (
                    <div>
                        <p>名前: {data.name}</p>
                        <p>年齢: {data.age}歳</p>
                    </div>
                );
            }}
        </DataFetcher>
    );
}
```

### 実践例: 複数のchildrenスロット

```typescript
// src/components/Layout/Layout.tsx
interface LayoutProps {
    header?: React.ReactNode;
    sidebar?: React.ReactNode;
    main: React.ReactNode;
    footer?: React.ReactNode;
}

function Layout({ header, sidebar, main, footer }: LayoutProps) {
    return (
        <div className="layout">
            {header && <header className="layout-header">{header}</header>}
            <div className="layout-body">
                {sidebar && <aside className="layout-sidebar">{sidebar}</aside>}
                <main className="layout-main">{main}</main>
            </div>
            {footer && <footer className="layout-footer">{footer}</footer>}
        </div>
    );
}

export default Layout;

// 使用例
function App() {
    return (
        <Layout
            header={<h1>ヘッダー</h1>}
            sidebar={<nav>サイドバー</nav>}
            main={<div>メインコンテンツ</div>}
            footer={<p>フッター</p>}
        />
    );
}
```

### 実践例: childrenの型を制限する

```typescript
// src/components/ButtonGroup/ButtonGroup.tsx
interface ButtonGroupProps {
    children: React.ReactElement<{ variant?: string }> | React.ReactElement<{ variant?: string }>[];
}

function ButtonGroup({ children }: ButtonGroupProps) {
    return (
        <div className="button-group">
            {Array.isArray(children)
                ? children.map((child, index) => (
                    <div key={index} className="button-group-item">
                        {child}
                    </div>
                ))
                : <div className="button-group-item">{children}</div>
            }
        </div>
    );
}

export default ButtonGroup;
```

### 実践例: React.FCの使用（非推奨の理由）

```typescript
// ❌ 非推奨: React.FCを使用
const Button: React.FC<{ label: string }> = ({ label }) => {
    return <button>{label}</button>;
};

// ✅ 推奨: 通常の関数として定義
interface ButtonProps {
    label: string;
}

function Button({ label }: ButtonProps) {
    return <button>{label}</button>;
}
```

### React.FCが非推奨の理由
1. **childrenが自動的に追加される**: 不要な場合でもchildrenが含まれる
2. **型推論が弱い**: 戻り値の型推論が弱い
3. **明示的でない**: 通常の関数定義の方が明確

---

## まとめ

この章では、ReactとTypeScriptを組み合わせたコンポーネントの型定義について学びました。

### 学んだこと
- **Propsの型定義**: typeとinterfaceを使った型定義
- **イベントハンドラーの型**: Reactのイベント型を使用
- **childrenの型**: React.ReactNodeを使った型定義
- **ジェネリクス**: 再利用可能なコンポーネントの型定義

### 重要なポイント
1. **type vs interface**: プロジェクトの方針に合わせて選択
2. **イベント型**: Reactのイベント型を適切に使用
3. **React.ReactNode**: childrenの型として使用
4. **型安全性**: 型定義により、エラーを事前に発見できる

### ベストプラクティス
- **interfaceを優先**: 拡張可能な場合はinterfaceを使用
- **型エイリアス**: 複雑な型は型エイリアスで定義
- **React.FCは避ける**: 通常の関数定義を推奨
- **ジェネリクス**: 再利用可能なコンポーネントで活用

### 次のステップ
次の章では、Hooksの型定義について詳しく学びます。

---

## 演習問題

### 問題1: Propsの型定義
名前、年齢、メールアドレスを受け取るUserCardコンポーネントのPropsを型定義してください。

<details>
<summary>解答例</summary>

```typescript
interface UserCardProps {
    name: string;
    age: number;
    email: string;
}

function UserCard({ name, age, email }: UserCardProps) {
    return (
        <div>
            <h3>{name}</h3>
            <p>年齢: {age}歳</p>
            <p>メール: {email}</p>
        </div>
    );
}
```
</details>

### 問題2: イベントハンドラーの型
クリックイベントを受け取るButtonコンポーネントのPropsを型定義してください。

<details>
<summary>解答例</summary>

```typescript
interface ButtonProps {
    label: string;
    onClick: (e: React.MouseEvent<HTMLButtonElement>) => void;
}

function Button({ label, onClick }: ButtonProps) {
    return <button onClick={onClick}>{label}</button>;
}
```
</details>

### 問題3: childrenの型
childrenを受け取るContainerコンポーネントのPropsを型定義してください。

<details>
<summary>解答例</summary>

```typescript
interface ContainerProps {
    children: React.ReactNode;
}

function Container({ children }: ContainerProps) {
    return <div className="container">{children}</div>;
}
```
</details>

### 問題4: ジェネリクスを使ったProps
任意の型のアイテムを表示するListコンポーネントのPropsを型定義してください。

<details>
<summary>解答例</summary>

```typescript
interface ListProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
    keyExtractor: (item: T) => string | number;
}

function List<T>({ items, renderItem, keyExtractor }: ListProps<T>) {
    return (
        <ul>
            {items.map(item => (
                <li key={keyExtractor(item)}>
                    {renderItem(item)}
                </li>
            ))}
        </ul>
    );
}
```
</details>

### 問題5: 複合的なPropsの型定義
タイトル、children、オプショナルなonClickを受け取るCardコンポーネントのPropsを型定義してください。

<details>
<summary>解答例</summary>

```typescript
interface CardProps {
    title: string;
    children: React.ReactNode;
    onClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
}

function Card({ title, children, onClick }: CardProps) {
    return (
        <div className="card" onClick={onClick}>
            <h2>{title}</h2>
            <div className="card-body">
                {children}
            </div>
        </div>
    );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。

