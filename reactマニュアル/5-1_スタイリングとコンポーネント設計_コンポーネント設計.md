# 5-1. スタイリングとコンポーネント設計（コンポーネント設計）

この章では、Reactアプリケーションにおけるコンポーネント設計の考え方について学びます。適切なコンポーネント設計を理解することで、保守性が高く、再利用可能なコードを書けるようになります。

---

## 目次

- [Atomic Design の概念とディレクトリ構成](#atomic-design-の概念とディレクトリ構成)
- [プレゼンテーションコンポーネントとコンテナコンポーネント](#プレゼンテーションコンポーネントとコンテナコンポーネント)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## Atomic Design の概念とディレクトリ構成

### Atomic Designとは
Atomic Designは、**UIコンポーネントを原子（Atom）、分子（Molecule）、生物（Organism）、テンプレート（Template）、ページ（Page）の5つの階層に分類する**設計手法です。小さなコンポーネントから大きなコンポーネントへと段階的に組み立てることで、再利用性の高いコンポーネント設計を実現します。

### 日常生活での例
- **レゴブロック**: 小さなブロック（Atom）を組み合わせて、大きな構造物（Page）を作る
- **料理の材料**: 食材（Atom）を組み合わせて、料理（Molecule）を作り、コース料理（Organism）を構成する
- **文章の構成**: 文字（Atom）→単語（Molecule）→文（Organism）→段落（Template）→文章（Page）

### Atomic Designの5つの階層

```
1. Atoms（原子）: 最小単位のコンポーネント
2. Molecules（分子）: Atomsを組み合わせた小さなコンポーネント
3. Organisms（生物）: MoleculesやAtomsを組み合わせた大きなコンポーネント
4. Templates（テンプレート）: Organismsを配置したページの骨組み
5. Pages（ページ）: Templatesに実際のデータを流し込んだ完成形
```

### Atoms（原子）とは
Atomsは、**それ以上分割できない最小単位のコンポーネント**です。ボタン、入力フィールド、ラベルなど、単一の機能を持つコンポーネントです。

### 実践例: Atoms

```jsx
// src/components/atoms/Button.jsx
// Atom: ボタンコンポーネント
function Button({ children, onClick, variant = 'primary' }) {
    const styles = {
        primary: { backgroundColor: '#007bff', color: '#fff' },
        secondary: { backgroundColor: '#6c757d', color: '#fff' }
    };

    return (
        <button
            onClick={onClick}
            style={{
                padding: '8px 16px',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                ...styles[variant]
            }}
        >
            {children}
        </button>
    );
}

export default Button;

// src/components/atoms/Input.jsx
// Atom: 入力フィールドコンポーネント
function Input({ type = 'text', value, onChange, placeholder }) {
    return (
        <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            style={{
                padding: '8px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                width: '100%'
            }}
        />
    );
}

export default Input;

// src/components/atoms/Label.jsx
// Atom: ラベルコンポーネント
function Label({ children, htmlFor }) {
    return (
        <label
            htmlFor={htmlFor}
            style={{
                display: 'block',
                marginBottom: '4px',
                fontWeight: 'bold'
            }}
        >
            {children}
        </label>
    );
}

export default Label;
```

### Molecules（分子）とは
Moleculesは、**複数のAtomsを組み合わせた小さなコンポーネント**です。フォームフィールド、検索バー、カードなど、複数のAtomsが連携して機能するコンポーネントです。

### 実践例: Molecules

```jsx
// src/components/molecules/FormField.jsx
// Molecule: フォームフィールド（Label + Input）
import Label from '../atoms/Label';
import Input from '../atoms/Input';

function FormField({ label, id, type, value, onChange, placeholder }) {
    return (
        <div style={{ marginBottom: '16px' }}>
            <Label htmlFor={id}>{label}</Label>
            <Input
                id={id}
                type={type}
                value={value}
                onChange={onChange}
                placeholder={placeholder}
            />
        </div>
    );
}

export default FormField;

// src/components/molecules/SearchBar.jsx
// Molecule: 検索バー（Input + Button）
import Input from '../atoms/Input';
import Button from '../atoms/Button';

function SearchBar({ value, onChange, onSearch }) {
    return (
        <div style={{ display: 'flex', gap: '8px' }}>
            <Input
                value={value}
                onChange={onChange}
                placeholder="検索..."
                style={{ flex: 1 }}
            />
            <Button onClick={onSearch}>検索</Button>
        </div>
    );
}

export default SearchBar;

// src/components/molecules/UserCard.jsx
// Molecule: ユーザーカード（複数のAtomsを組み合わせ）
import Button from '../atoms/Button';

function UserCard({ name, email, onEdit, onDelete }) {
    return (
        <div style={{
            border: '1px solid #ccc',
            borderRadius: '8px',
            padding: '16px',
            marginBottom: '16px'
        }}>
            <h3>{name}</h3>
            <p>{email}</p>
            <div style={{ display: 'flex', gap: '8px', marginTop: '12px' }}>
                <Button onClick={onEdit} variant="secondary">編集</Button>
                <Button onClick={onDelete} variant="danger">削除</Button>
            </div>
        </div>
    );
}

export default UserCard;
```

### Organisms（生物）とは
Organismsは、**MoleculesやAtomsを組み合わせた大きなコンポーネント**です。ヘッダー、サイドバー、フォーム全体など、複雑な機能を持つコンポーネントです。

### 実践例: Organisms

```jsx
// src/components/organisms/Header.jsx
// Organism: ヘッダー（複数のMoleculesとAtoms）
import SearchBar from '../molecules/SearchBar';
import Button from '../atoms/Button';

function Header({ onSearch, user, onLogout }) {
    const [searchValue, setSearchValue] = useState('');

    return (
        <header style={{
            backgroundColor: '#333',
            color: '#fff',
            padding: '16px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center'
        }}>
            <h1>My App</h1>
            <SearchBar
                value={searchValue}
                onChange={(e) => setSearchValue(e.target.value)}
                onSearch={() => onSearch(searchValue)}
            />
            <div>
                <span>{user.name}</span>
                <Button onClick={onLogout} variant="secondary">ログアウト</Button>
            </div>
        </header>
    );
}

export default Header;

// src/components/organisms/UserList.jsx
// Organism: ユーザーリスト（複数のMolecules）
import UserCard from '../molecules/UserCard';

function UserList({ users, onEdit, onDelete }) {
    return (
        <div>
            <h2>ユーザー一覧</h2>
            {users.map(user => (
                <UserCard
                    key={user.id}
                    name={user.name}
                    email={user.email}
                    onEdit={() => onEdit(user.id)}
                    onDelete={() => onDelete(user.id)}
                />
            ))}
        </div>
    );
}

export default UserList;

// src/components/organisms/LoginForm.jsx
// Organism: ログインフォーム（複数のMolecules）
import FormField from '../molecules/FormField';
import Button from '../atoms/Button';

function LoginForm({ onSubmit }) {
    const [email, setEmail] = useState('');
    const [password, setPassword] = useState('');

    const handleSubmit = (e) => {
        e.preventDefault();
        onSubmit({ email, password });
    };

    return (
        <form onSubmit={handleSubmit} style={{ maxWidth: '400px', margin: '0 auto' }}>
            <FormField
                label="メールアドレス"
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="email@example.com"
            />
            <FormField
                label="パスワード"
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="パスワード"
            />
            <Button type="submit">ログイン</Button>
        </form>
    );
}

export default LoginForm;
```

### Templates（テンプレート）とは
Templatesは、**Organismsを配置したページの骨組み**です。実際のデータは含まず、レイアウトや構造を定義します。

### 実践例: Templates

```jsx
// src/components/templates/DashboardTemplate.jsx
// Template: ダッシュボードのテンプレート
import Header from '../organisms/Header';
import Sidebar from '../organisms/Sidebar';
import MainContent from '../organisms/MainContent';

function DashboardTemplate({ 
    headerProps, 
    sidebarProps, 
    mainContentProps 
}) {
    return (
        <div style={{ display: 'flex', flexDirection: 'column', minHeight: '100vh' }}>
            <Header {...headerProps} />
            <div style={{ display: 'flex', flex: 1 }}>
                <Sidebar {...sidebarProps} />
                <MainContent {...mainContentProps} />
            </div>
        </div>
    );
}

export default DashboardTemplate;

// src/components/templates/AuthTemplate.jsx
// Template: 認証ページのテンプレート
function AuthTemplate({ children }) {
    return (
        <div style={{
            minHeight: '100vh',
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            backgroundColor: '#f5f5f5'
        }}>
            <div style={{
                backgroundColor: '#fff',
                padding: '32px',
                borderRadius: '8px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                width: '100%',
                maxWidth: '400px'
            }}>
                {children}
            </div>
        </div>
    );
}

export default AuthTemplate;
```

### Pages（ページ）とは
Pagesは、**Templatesに実際のデータを流し込んだ完成形**です。実際のアプリケーションで表示されるページです。

### 実践例: Pages

```jsx
// src/pages/DashboardPage.jsx
// Page: ダッシュボードページ
import DashboardTemplate from '../components/templates/DashboardTemplate';
import UserList from '../components/organisms/UserList';

function DashboardPage() {
    const [users, setUsers] = useState([
        { id: 1, name: '太郎', email: 'taro@example.com' },
        { id: 2, name: '花子', email: 'hanako@example.com' }
    ]);

    const handleSearch = (query) => {
        console.log('検索:', query);
    };

    const handleLogout = () => {
        console.log('ログアウト');
    };

    const handleEdit = (id) => {
        console.log('編集:', id);
    };

    const handleDelete = (id) => {
        setUsers(users.filter(user => user.id !== id));
    };

    return (
        <DashboardTemplate
            headerProps={{
                onSearch: handleSearch,
                user: { name: '太郎' },
                onLogout: handleLogout
            }}
            sidebarProps={{
                items: ['ホーム', 'ユーザー', '設定']
            }}
            mainContentProps={{
                children: (
                    <UserList
                        users={users}
                        onEdit={handleEdit}
                        onDelete={handleDelete}
                    />
                )
            }}
        />
    );
}

export default DashboardPage;

// src/pages/LoginPage.jsx
// Page: ログインページ
import AuthTemplate from '../components/templates/AuthTemplate';
import LoginForm from '../components/organisms/LoginForm';

function LoginPage() {
    const handleLogin = (credentials) => {
        console.log('ログイン:', credentials);
        // 実際のログイン処理
    };

    return (
        <AuthTemplate>
            <h1 style={{ textAlign: 'center', marginBottom: '24px' }}>
                ログイン
            </h1>
            <LoginForm onSubmit={handleLogin} />
        </AuthTemplate>
    );
}

export default LoginPage;
```

### Atomic Designのディレクトリ構成

```
src/
├── components/
│   ├── atoms/           # 最小単位のコンポーネント
│   │   ├── Button.jsx
│   │   ├── Input.jsx
│   │   └── Label.jsx
│   ├── molecules/       # Atomsを組み合わせたコンポーネント
│   │   ├── FormField.jsx
│   │   ├── SearchBar.jsx
│   │   └── UserCard.jsx
│   ├── organisms/       # MoleculesやAtomsを組み合わせたコンポーネント
│   │   ├── Header.jsx
│   │   ├── UserList.jsx
│   │   └── LoginForm.jsx
│   └── templates/      # Organismsを配置したテンプレート
│       ├── DashboardTemplate.jsx
│       └── AuthTemplate.jsx
├── pages/              # Templatesにデータを流し込んだページ
│   ├── DashboardPage.jsx
│   └── LoginPage.jsx
└── App.jsx
```

### Atomic Designのメリット
1. **再利用性**: 小さなコンポーネントから組み立てるため、再利用しやすい
2. **保守性**: 各コンポーネントの役割が明確で、修正が容易
3. **一貫性**: 同じAtomsを使うことで、デザインの一貫性を保てる
4. **テスト容易性**: 小さなコンポーネント単位でテストできる
5. **スケーラビリティ**: プロジェクトが大きくなっても管理しやすい

---

## プレゼンテーションコンポーネントとコンテナコンポーネント

### プレゼンテーションコンポーネントとは
プレゼンテーションコンポーネント（Presentational Component）は、**見た目（UI）のみを担当するコンポーネント**です。Propsからデータを受け取り、表示するだけのコンポーネントです。状態管理やビジネスロジックを持たず、再利用性が高いのが特徴です。

### コンテナコンポーネントとは
コンテナコンポーネント（Container Component）は、**データの取得や状態管理、ビジネスロジックを担当するコンポーネント**です。プレゼンテーションコンポーネントにデータを渡し、イベントハンドラーを提供します。

### 日常生活での例
- **テレビとリモコン**: テレビ（プレゼンテーション）は画面を表示するだけ、リモコン（コンテナ）がチャンネルを切り替える
- **看板と看板屋**: 看板（プレゼンテーション）は情報を表示するだけ、看板屋（コンテナ）が情報を更新する
- **時計と時計職人**: 時計（プレゼンテーション）は時刻を表示するだけ、時計職人（コンテナ）が時刻を設定する

### プレゼンテーションコンポーネントの特徴
1. **見た目に集中**: UIの表示のみを担当
2. **Propsからデータを受け取る**: 親コンポーネントからデータを受け取る
3. **イベントハンドラーを受け取る**: クリックなどのイベントは、親から渡された関数を実行
4. **状態を持たない**: 自身で状態管理を行わない（表示用のローカル状態は除く）
5. **再利用性が高い**: データやロジックに依存しないため、様々な場面で使える

### 実践例: プレゼンテーションコンポーネント

```jsx
// src/components/presentational/UserCard.jsx
// プレゼンテーションコンポーネント: ユーザーカード
function UserCard({ user, onEdit, onDelete }) {
    return (
        <div style={{
            border: '1px solid #ccc',
            borderRadius: '8px',
            padding: '16px',
            marginBottom: '16px'
        }}>
            <h3>{user.name}</h3>
            <p>メール: {user.email}</p>
            <p>年齢: {user.age}歳</p>
            <div style={{ display: 'flex', gap: '8px', marginTop: '12px' }}>
                <button onClick={() => onEdit(user.id)}>編集</button>
                <button onClick={() => onDelete(user.id)}>削除</button>
            </div>
        </div>
    );
}

export default UserCard;

// src/components/presentational/UserList.jsx
// プレゼンテーションコンポーネント: ユーザーリスト
import UserCard from './UserCard';

function UserList({ users, onEdit, onDelete }) {
    if (users.length === 0) {
        return <p>ユーザーが存在しません</p>;
    }

    return (
        <div>
            <h2>ユーザー一覧 ({users.length}人)</h2>
            {users.map(user => (
                <UserCard
                    key={user.id}
                    user={user}
                    onEdit={onEdit}
                    onDelete={onDelete}
                />
            ))}
        </div>
    );
}

export default UserList;

// src/components/presentational/SearchBar.jsx
// プレゼンテーションコンポーネント: 検索バー
function SearchBar({ value, onChange, onSearch }) {
    return (
        <div style={{ display: 'flex', gap: '8px', marginBottom: '16px' }}>
            <input
                type="text"
                value={value}
                onChange={(e) => onChange(e.target.value)}
                placeholder="検索..."
                style={{
                    flex: 1,
                    padding: '8px',
                    border: '1px solid #ccc',
                    borderRadius: '4px'
                }}
            />
            <button onClick={onSearch}>検索</button>
        </div>
    );
}

export default SearchBar;
```

### コンテナコンポーネントの特徴
1. **データの取得**: APIからデータを取得する
2. **状態管理**: useStateやuseReducerで状態を管理する
3. **ビジネスロジック**: データの処理や変換を行う
4. **イベントハンドラー**: プレゼンテーションコンポーネントに渡すイベントハンドラーを定義
5. **副作用の管理**: useEffectで副作用を管理する

### 実践例: コンテナコンポーネント

```jsx
// src/containers/UserListContainer.jsx
// コンテナコンポーネント: ユーザーリストのコンテナ
import { useState, useEffect } from 'react';
import UserList from '../components/presentational/UserList';
import SearchBar from '../components/presentational/SearchBar';

function UserListContainer() {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);
    const [searchQuery, setSearchQuery] = useState('');

    // データの取得
    useEffect(() => {
        const fetchUsers = async () => {
            setLoading(true);
            try {
                // 実際のAPI呼び出しの代わりに、模擬データを使用
                await new Promise(resolve => setTimeout(resolve, 1000));
                const mockUsers = [
                    { id: 1, name: '太郎', email: 'taro@example.com', age: 25 },
                    { id: 2, name: '花子', email: 'hanako@example.com', age: 30 },
                    { id: 3, name: '次郎', email: 'jiro@example.com', age: 28 }
                ];
                setUsers(mockUsers);
            } catch (error) {
                console.error('エラー:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchUsers();
    }, []);

    // 検索処理
    const handleSearch = () => {
        console.log('検索:', searchQuery);
        // 実際の検索処理
    };

    // 編集処理
    const handleEdit = (id) => {
        console.log('編集:', id);
        // 実際の編集処理
    };

    // 削除処理
    const handleDelete = (id) => {
        setUsers(users.filter(user => user.id !== id));
    };

    // フィルタリング
    const filteredUsers = users.filter(user =>
        user.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        user.email.toLowerCase().includes(searchQuery.toLowerCase())
    );

    if (loading) {
        return <p>読み込み中...</p>;
    }

    return (
        <div>
            <SearchBar
                value={searchQuery}
                onChange={setSearchQuery}
                onSearch={handleSearch}
            />
            <UserList
                users={filteredUsers}
                onEdit={handleEdit}
                onDelete={handleDelete}
            />
        </div>
    );
}

export default UserListContainer;
```

### プレゼンテーションとコンテナの分離のメリット
1. **関心の分離**: UIとロジックを分離できる
2. **再利用性**: プレゼンテーションコンポーネントを様々な場面で再利用できる
3. **テスト容易性**: プレゼンテーションコンポーネントは簡単にテストできる
4. **保守性**: ロジックとUIを独立して修正できる
5. **チーム開発**: デザイナーと開発者が並行して作業できる

### 実践例: プレゼンテーションとコンテナの組み合わせ

```jsx
// src/components/presentational/ProductCard.jsx
// プレゼンテーションコンポーネント: 商品カード
function ProductCard({ product, onAddToCart, onViewDetails }) {
    return (
        <div style={{
            border: '1px solid #ddd',
            borderRadius: '8px',
            padding: '16px',
            marginBottom: '16px'
        }}>
            <h3>{product.name}</h3>
            <p>価格: ¥{product.price.toLocaleString()}</p>
            <p>在庫: {product.inStock ? 'あり' : 'なし'}</p>
            <div style={{ display: 'flex', gap: '8px', marginTop: '12px' }}>
                <button
                    onClick={() => onAddToCart(product.id)}
                    disabled={!product.inStock}
                >
                    カートに追加
                </button>
                <button onClick={() => onViewDetails(product.id)}>
                    詳細を見る
                </button>
            </div>
        </div>
    );
}

export default ProductCard;

// src/containers/ProductListContainer.jsx
// コンテナコンポーネント: 商品リストのコンテナ
import { useState, useEffect } from 'react';
import ProductCard from '../components/presentational/ProductCard';

function ProductListContainer() {
    const [products, setProducts] = useState([]);
    const [cart, setCart] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        // 商品データの取得
        const fetchProducts = async () => {
            setLoading(true);
            try {
                await new Promise(resolve => setTimeout(resolve, 1000));
                const mockProducts = [
                    { id: 1, name: 'ノートパソコン', price: 98000, inStock: true },
                    { id: 2, name: 'マウス', price: 2500, inStock: true },
                    { id: 3, name: 'キーボード', price: 5000, inStock: false }
                ];
                setProducts(mockProducts);
            } catch (error) {
                console.error('エラー:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchProducts();
    }, []);

    const handleAddToCart = (productId) => {
        const product = products.find(p => p.id === productId);
        if (product) {
            setCart([...cart, product]);
            alert(`${product.name}をカートに追加しました`);
        }
    };

    const handleViewDetails = (productId) => {
        console.log('商品詳細:', productId);
        // 実際の詳細ページへの遷移処理
    };

    if (loading) {
        return <p>読み込み中...</p>;
    }

    return (
        <div>
            <h2>商品一覧</h2>
            <p>カート内の商品数: {cart.length}</p>
            {products.map(product => (
                <ProductCard
                    key={product.id}
                    product={product}
                    onAddToCart={handleAddToCart}
                    onViewDetails={handleViewDetails}
                />
            ))}
        </div>
    );
}

export default ProductListContainer;
```

### ディレクトリ構成の例

```
src/
├── components/
│   └── presentational/      # プレゼンテーションコンポーネント
│       ├── UserCard.jsx
│       ├── UserList.jsx
│       ├── SearchBar.jsx
│       └── ProductCard.jsx
├── containers/              # コンテナコンポーネント
│   ├── UserListContainer.jsx
│   └── ProductListContainer.jsx
└── App.jsx
```

---

## まとめ

この章では、コンポーネント設計について以下のことを学びました。

### Atomic Designの概念とディレクトリ構成
- Atomic Designは、UIコンポーネントを5つの階層に分類する設計手法
- **Atoms**: 最小単位のコンポーネント（ボタン、入力フィールドなど）
- **Molecules**: Atomsを組み合わせた小さなコンポーネント（フォームフィールドなど）
- **Organisms**: MoleculesやAtomsを組み合わせた大きなコンポーネント（ヘッダー、フォーム全体など）
- **Templates**: Organismsを配置したページの骨組み
- **Pages**: Templatesに実際のデータを流し込んだ完成形
- 再利用性、保守性、一貫性、テスト容易性、スケーラビリティが向上する

### プレゼンテーションコンポーネントとコンテナコンポーネント
- **プレゼンテーションコンポーネント**: 見た目（UI）のみを担当するコンポーネント
- **コンテナコンポーネント**: データの取得や状態管理、ビジネスロジックを担当するコンポーネント
- 関心の分離により、再利用性、テスト容易性、保守性が向上する
- チーム開発でも並行して作業しやすくなる

### コンポーネント設計のメリット
- **再利用性**: 小さなコンポーネントから組み立てるため、再利用しやすい
- **保守性**: 各コンポーネントの役割が明確で、修正が容易
- **一貫性**: 同じコンポーネントを使うことで、デザインの一貫性を保てる
- **テスト容易性**: 小さなコンポーネント単位でテストできる
- **スケーラビリティ**: プロジェクトが大きくなっても管理しやすい

### 次のステップ
コンポーネント設計を理解したら、次のトピックに進みましょう：
- スタイリング手法（5-2）
- UIカタログ（Storybook）（5-3）
- パフォーマンス最適化とメモ化（6章）

---

## 演習問題

以下の問題を解いて、コンポーネント設計の理解を深めましょう。

### 問題1: Atomコンポーネントの作成
`Button`と`Input`のAtomコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
// src/components/atoms/Button.jsx
function Button({ children, onClick, variant = 'primary' }) {
    const styles = {
        primary: { backgroundColor: '#007bff', color: '#fff' },
        secondary: { backgroundColor: '#6c757d', color: '#fff' }
    };

    return (
        <button
            onClick={onClick}
            style={{
                padding: '8px 16px',
                border: 'none',
                borderRadius: '4px',
                cursor: 'pointer',
                ...styles[variant]
            }}
        >
            {children}
        </button>
    );
}

export default Button;

// src/components/atoms/Input.jsx
function Input({ type = 'text', value, onChange, placeholder }) {
    return (
        <input
            type={type}
            value={value}
            onChange={onChange}
            placeholder={placeholder}
            style={{
                padding: '8px',
                border: '1px solid #ccc',
                borderRadius: '4px',
                width: '100%'
            }}
        />
    );
}

export default Input;
```
</details>

### 問題2: Moleculeコンポーネントの作成
`Button`と`Input`を使って、`SearchBar`のMoleculeコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
// src/components/molecules/SearchBar.jsx
import Input from '../atoms/Input';
import Button from '../atoms/Button';

function SearchBar({ value, onChange, onSearch }) {
    return (
        <div style={{ display: 'flex', gap: '8px' }}>
            <Input
                value={value}
                onChange={onChange}
                placeholder="検索..."
                style={{ flex: 1 }}
            />
            <Button onClick={onSearch}>検索</Button>
        </div>
    );
}

export default SearchBar;
```
</details>

### 問題3: プレゼンテーションコンポーネントの作成
`UserCard`のプレゼンテーションコンポーネントを作成してください。Propsから`user`、`onEdit`、`onDelete`を受け取ります。

<details>
<summary>解答例</summary>

```jsx
// src/components/presentational/UserCard.jsx
function UserCard({ user, onEdit, onDelete }) {
    return (
        <div style={{
            border: '1px solid #ccc',
            borderRadius: '8px',
            padding: '16px',
            marginBottom: '16px'
        }}>
            <h3>{user.name}</h3>
            <p>メール: {user.email}</p>
            <p>年齢: {user.age}歳</p>
            <div style={{ display: 'flex', gap: '8px', marginTop: '12px' }}>
                <button onClick={() => onEdit(user.id)}>編集</button>
                <button onClick={() => onDelete(user.id)}>削除</button>
            </div>
        </div>
    );
}

export default UserCard;
```
</details>

### 問題4: コンテナコンポーネントの作成
`UserCard`を使った`UserListContainer`のコンテナコンポーネントを作成してください。ユーザーリストを取得し、編集・削除の処理を実装してください。

<details>
<summary>解答例</summary>

```jsx
// src/containers/UserListContainer.jsx
import { useState, useEffect } from 'react';
import UserCard from '../components/presentational/UserCard';

function UserListContainer() {
    const [users, setUsers] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        const fetchUsers = async () => {
            setLoading(true);
            try {
                await new Promise(resolve => setTimeout(resolve, 1000));
                const mockUsers = [
                    { id: 1, name: '太郎', email: 'taro@example.com', age: 25 },
                    { id: 2, name: '花子', email: 'hanako@example.com', age: 30 }
                ];
                setUsers(mockUsers);
            } catch (error) {
                console.error('エラー:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchUsers();
    }, []);

    const handleEdit = (id) => {
        console.log('編集:', id);
    };

    const handleDelete = (id) => {
        setUsers(users.filter(user => user.id !== id));
    };

    if (loading) {
        return <p>読み込み中...</p>;
    }

    return (
        <div>
            <h2>ユーザー一覧</h2>
            {users.map(user => (
                <UserCard
                    key={user.id}
                    user={user}
                    onEdit={handleEdit}
                    onDelete={handleDelete}
                />
            ))}
        </div>
    );
}

export default UserListContainer;
```
</details>

### 問題5: Organismコンポーネントの作成
`Header`のOrganismコンポーネントを作成してください。`SearchBar`と`Button`を使用し、検索とログアウトの機能を実装してください。

<details>
<summary>解答例</summary>

```jsx
// src/components/organisms/Header.jsx
import { useState } from 'react';
import SearchBar from '../molecules/SearchBar';
import Button from '../atoms/Button';

function Header({ onSearch, user, onLogout }) {
    const [searchValue, setSearchValue] = useState('');

    return (
        <header style={{
            backgroundColor: '#333',
            color: '#fff',
            padding: '16px',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center'
        }}>
            <h1>My App</h1>
            <SearchBar
                value={searchValue}
                onChange={setSearchValue}
                onSearch={() => onSearch(searchValue)}
            />
            <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                <span>{user.name}</span>
                <Button onClick={onLogout} variant="secondary">ログアウト</Button>
            </div>
        </header>
    );
}

export default Header;
```
</details>

---

お疲れ様でした！次の章に進みましょう。

