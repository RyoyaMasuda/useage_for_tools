# 6-1. 再レンダリングの仕組み

この章では、Reactの再レンダリングの仕組みについて学びます。再レンダリングがいつ発生するかを理解し、`React.memo`を使って不要な再レンダリングを防ぐ方法を学びます。再レンダリングの仕組みを理解することで、パフォーマンスの最適化ができるようになります。

---

## 目次

- [レンダリングが起きる条件](#レンダリングが起きる条件)
- [React.memo によるコンポーネントのメモ化](#reactmemo-によるコンポーネントのメモ化)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## レンダリングが起きる条件

### レンダリングとは
レンダリングは、**Reactがコンポーネントを実行して、画面に表示する内容を決定する**処理です。

### 日常生活での例
- **時計**: 時間が変わるたびに表示を更新（再レンダリング）
- **天気予報**: 天気が変わるたびに表示を更新（再レンダリング）
- **在庫表示**: 在庫数が変わるたびに表示を更新（再レンダリング）

### レンダリングが起きる条件

Reactでは、以下の場合にレンダリングが発生します：

1. **Stateが変更されたとき**
2. **Propsが変更されたとき**
3. **親コンポーネントが再レンダリングされたとき**

### 1. Stateが変更されたとき

コンポーネント内の`useState`で管理している状態が変更されると、そのコンポーネントが再レンダリングされます。

```jsx
import { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);
    
    // countが変更されると、このコンポーネントが再レンダリングされる
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
        </div>
    );
}
```

### 2. Propsが変更されたとき

親コンポーネントから渡されるPropsが変更されると、子コンポーネントが再レンダリングされます。

```jsx
function Parent() {
    const [name, setName] = useState('太郎');
    
    // nameが変更されると、Childコンポーネントが再レンダリングされる
    return <Child name={name} />;
}

function Child({ name }) {
    return <p>名前: {name}</p>;
}
```

### 3. 親コンポーネントが再レンダリングされたとき

親コンポーネントが再レンダリングされると、子コンポーネントも再レンダリングされます（Propsが変更されていなくても）。

```jsx
function Parent() {
    const [count, setCount] = useState(0);
    const [otherState, setOtherState] = useState('何か');
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            {/* otherStateが変更されても、Childは再レンダリングされる */}
            <Child name="太郎" />
        </div>
    );
}

function Child({ name }) {
    // Parentが再レンダリングされると、このコンポーネントも再レンダリングされる
    return <p>名前: {name}</p>;
}
```

### 実践例: レンダリングが起きる条件

```jsx
// src/App.jsx
import React, { useState } from 'react';

// レンダリング回数をカウントするカスタムフック
function useRenderCount(componentName) {
    const renderCount = React.useRef(0);
    renderCount.current += 1;
    console.log(`${componentName} が ${renderCount.current} 回レンダリングされました`);
    return renderCount.current;
}

// 例1: Stateが変更されたとき
function CounterExample() {
    const [count, setCount] = useState(0);
    useRenderCount('CounterExample');
    
    return (
        <div>
            <h2>例1: Stateが変更されたとき</h2>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <p>※ボタンをクリックすると再レンダリングされます</p>
        </div>
    );
}

// 例2: Propsが変更されたとき
function ParentWithProps() {
    const [name, setName] = useState('太郎');
    useRenderCount('ParentWithProps');
    
    return (
        <div>
            <h2>例2: Propsが変更されたとき</h2>
            <input 
                value={name} 
                onChange={(e) => setName(e.target.value)} 
                placeholder="名前を入力"
            />
            <ChildWithProps name={name} />
        </div>
    );
}

function ChildWithProps({ name }) {
    useRenderCount('ChildWithProps');
    return <p>名前: {name}</p>;
}

// 例3: 親コンポーネントが再レンダリングされたとき
function ParentRerender() {
    const [count, setCount] = useState(0);
    const [unrelatedState, setUnrelatedState] = useState('無関係な状態');
    useRenderCount('ParentRerender');
    
    return (
        <div>
            <h2>例3: 親コンポーネントが再レンダリングされたとき</h2>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <p>無関係な状態: {unrelatedState}</p>
            <button onClick={() => setUnrelatedState('変更')}>無関係な状態を変更</button>
            {/* Propsが変更されていなくても、ChildWithoutPropsChangeは再レンダリングされる */}
            <ChildWithoutPropsChange name="太郎" />
        </div>
    );
}

function ChildWithoutPropsChange({ name }) {
    useRenderCount('ChildWithoutPropsChange');
    return <p>名前: {name}（Propsは変更されていません）</p>;
}

// 例4: 複数のStateがある場合
function MultipleStates() {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);
    useRenderCount('MultipleStates');
    
    return (
        <div>
            <h2>例4: 複数のStateがある場合</h2>
            <p>カウント1: {count1}</p>
            <button onClick={() => setCount1(count1 + 1)}>カウント1アップ</button>
            <p>カウント2: {count2}</p>
            <button onClick={() => setCount2(count2 + 1)}>カウント2アップ</button>
            <p>※どちらのStateが変更されても再レンダリングされます</p>
        </div>
    );
}

// 例5: オブジェクトや配列のState
function ObjectState() {
    const [user, setUser] = useState({ name: '太郎', age: 25 });
    useRenderCount('ObjectState');
    
    const updateName = () => {
        // 新しいオブジェクトを作成しないと再レンダリングされない
        setUser({ ...user, name: '花子' });
    };
    
    const updateAge = () => {
        setUser({ ...user, age: user.age + 1 });
    };
    
    return (
        <div>
            <h2>例5: オブジェクトのState</h2>
            <p>名前: {user.name}</p>
            <p>年齢: {user.age}</p>
            <button onClick={updateName}>名前を変更</button>
            <button onClick={updateAge}>年齢を増やす</button>
            <p>※オブジェクトの参照が変わらないと再レンダリングされません</p>
        </div>
    );
}

// メインコンポーネント
function App() {
    return (
        <div className="app">
            <h1>レンダリングが起きる条件</h1>
            <p>コンソールを開いて、レンダリング回数を確認してください</p>
            
            <CounterExample />
            <hr />
            
            <ParentWithProps />
            <hr />
            
            <ParentRerender />
            <hr />
            
            <MultipleStates />
            <hr />
            
            <ObjectState />
        </div>
    );
}

export default App;
```

### 再レンダリングの流れ

1. **State/Propsの変更**: コンポーネントのStateやPropsが変更される
2. **再レンダリングのトリガー**: Reactが変更を検知する
3. **コンポーネントの実行**: コンポーネント関数が再実行される
4. **仮想DOMの生成**: 新しい仮想DOMが生成される
5. **差分検出**: 前回の仮想DOMと比較する（Reconciliation）
6. **実際のDOM更新**: 変更があった部分だけ実際のDOMを更新する

### 注意点: 不要な再レンダリング

親コンポーネントが再レンダリングされると、**Propsが変更されていなくても子コンポーネントも再レンダリングされます**。これがパフォーマンスの問題になる場合があります。

```jsx
// ⚠️ 問題: 親が再レンダリングされると、子も再レンダリングされる
function Parent() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            {/* nameは変更されていないのに、Childも再レンダリングされる */}
            <Child name="太郎" />
        </div>
    );
}

function Child({ name }) {
    // 親が再レンダリングされると、このコンポーネントも再レンダリングされる
    return <p>名前: {name}</p>;
}
```

---

## React.memo によるコンポーネントのメモ化

### React.memoとは
`React.memo`は、**コンポーネントをメモ化（キャッシュ）して、Propsが変更されていない場合は再レンダリングをスキップする**機能です。

### 日常生活での例
- **写真のキャッシュ**: 同じ写真は再ダウンロードしない（メモ化）
- **計算結果の保存**: 同じ計算は再計算しない（メモ化）
- **レシピの保存**: 同じレシピは再検索しない（メモ化）

### React.memoの基本構文

```jsx
import { memo } from 'react';

const MemoizedComponent = memo(function Component(props) {
    // コンポーネントの内容
});

// または
const MemoizedComponent = memo(Component);
```

### 基本的な使い方

```jsx
import { memo } from 'react';

function Child({ name }) {
    console.log('Childがレンダリングされました');
    return <p>名前: {name}</p>;
}

// React.memoでラップする
const MemoizedChild = memo(Child);

function Parent() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            {/* nameが変更されない限り、MemoizedChildは再レンダリングされない */}
            <MemoizedChild name="太郎" />
        </div>
    );
}
```

### React.memoの動作

1. **Propsの比較**: 前回のPropsと現在のPropsを比較する
2. **変更がない場合**: 再レンダリングをスキップする
3. **変更がある場合**: 通常通り再レンダリングする

### 実践例: React.memoの使用

```jsx
// src/App.jsx
import React, { useState, memo } from 'react';

// レンダリング回数をカウントするカスタムフック
function useRenderCount(componentName) {
    const renderCount = React.useRef(0);
    renderCount.current += 1;
    console.log(`${componentName} が ${renderCount.current} 回レンダリングされました`);
    return renderCount.current;
}

// 例1: メモ化されていないコンポーネント
function UnmemoizedChild({ name }) {
    useRenderCount('UnmemoizedChild');
    return <p>名前: {name}（メモ化されていません）</p>;
}

// 例2: メモ化されたコンポーネント
const MemoizedChild = memo(function MemoizedChild({ name }) {
    useRenderCount('MemoizedChild');
    return <p>名前: {name}（メモ化されています）</p>;
});

function ParentExample() {
    const [count, setCount] = useState(0);
    const [name, setName] = useState('太郎');
    useRenderCount('ParentExample');
    
    return (
        <div>
            <h2>React.memoの比較</h2>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <input 
                value={name} 
                onChange={(e) => setName(e.target.value)} 
                placeholder="名前を変更"
            />
            <UnmemoizedChild name={name} />
            <MemoizedChild name={name} />
            <p>※カウントを変更すると、UnmemoizedChildは再レンダリングされますが、MemoizedChildは再レンダリングされません（nameが変更されない限り）</p>
        </div>
    );
}

// 例3: オブジェクトのProps
function UnmemoizedObjectChild({ user }) {
    useRenderCount('UnmemoizedObjectChild');
    return <p>名前: {user.name}, 年齢: {user.age}</p>;
}

const MemoizedObjectChild = memo(function MemoizedObjectChild({ user }) {
    useRenderCount('MemoizedObjectChild');
    return <p>名前: {user.name}, 年齢: {user.age}</p>;
});

function ObjectPropsExample() {
    const [count, setCount] = useState(0);
    const [user, setUser] = useState({ name: '太郎', age: 25 });
    useRenderCount('ObjectPropsExample');
    
    return (
        <div>
            <h2>オブジェクトのProps</h2>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <button onClick={() => setUser({ ...user, age: user.age + 1 })}>
                年齢を増やす
            </button>
            <UnmemoizedObjectChild user={user} />
            <MemoizedObjectChild user={user} />
            <p>※オブジェクトの参照が変わると、両方とも再レンダリングされます</p>
        </div>
    );
}

// 例4: カスタム比較関数
function CustomComparisonChild({ name, age }) {
    useRenderCount('CustomComparisonChild');
    return <p>名前: {name}, 年齢: {age}</p>;
}

// カスタム比較関数を指定
const MemoizedCustomChild = memo(CustomComparisonChild, (prevProps, nextProps) => {
    // nameが同じなら再レンダリングしない（ageの変更は無視）
    return prevProps.name === nextProps.name;
});

function CustomComparisonExample() {
    const [name, setName] = useState('太郎');
    const [age, setAge] = useState(25);
    useRenderCount('CustomComparisonExample');
    
    return (
        <div>
            <h2>カスタム比較関数</h2>
            <input 
                value={name} 
                onChange={(e) => setName(e.target.value)} 
                placeholder="名前を変更"
            />
            <button onClick={() => setAge(age + 1)}>年齢を増やす</button>
            <MemoizedCustomChild name={name} age={age} />
            <p>※nameが変更されない限り、再レンダリングされません（ageの変更は無視）</p>
        </div>
    );
}

// 例5: リストアイテムのメモ化
function ListItem({ item, onDelete }) {
    useRenderCount(`ListItem-${item.id}`);
    return (
        <div>
            <span>{item.name}</span>
            <button onClick={() => onDelete(item.id)}>削除</button>
        </div>
    );
}

const MemoizedListItem = memo(ListItem);

function ListExample() {
    const [items, setItems] = useState([
        { id: 1, name: 'アイテム1' },
        { id: 2, name: 'アイテム2' },
        { id: 3, name: 'アイテム3' }
    ]);
    const [count, setCount] = useState(0);
    useRenderCount('ListExample');
    
    const handleDelete = (id) => {
        setItems(items.filter(item => item.id !== id));
    };
    
    return (
        <div>
            <h2>リストアイテムのメモ化</h2>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <ul>
                {items.map(item => (
                    <MemoizedListItem 
                        key={item.id} 
                        item={item} 
                        onDelete={handleDelete}
                    />
                ))}
            </ul>
            <p>※カウントを変更しても、リストアイテムは再レンダリングされません（itemとonDeleteが変更されない限り）</p>
        </div>
    );
}

// メインコンポーネント
function App() {
    return (
        <div className="app">
            <h1>React.memoによるコンポーネントのメモ化</h1>
            <p>コンソールを開いて、レンダリング回数を確認してください</p>
            
            <ParentExample />
            <hr />
            
            <ObjectPropsExample />
            <hr />
            
            <CustomComparisonExample />
            <hr />
            
            <ListExample />
        </div>
    );
}

export default App;
```

### React.memoの注意点

#### 1. 浅い比較（Shallow Comparison）

`React.memo`は、Propsを**浅く比較**します。オブジェクトや配列の参照が変わると、再レンダリングされます。

```jsx
// ⚠️ 問題: 毎回新しいオブジェクトが作成される
function Parent() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            {/* 毎回新しいオブジェクトが作成されるため、再レンダリングされる */}
            <MemoizedChild user={{ name: '太郎', age: 25 }} />
        </div>
    );
}

// ✅ 解決策: オブジェクトを変数に格納
function Parent() {
    const [count, setCount] = useState(0);
    const user = { name: '太郎', age: 25 }; // コンポーネント外に定義
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <MemoizedChild user={user} />
        </div>
    );
}
```

#### 2. 関数のProps

関数をPropsとして渡す場合、親コンポーネントが再レンダリングされるたびに新しい関数が作成されるため、メモ化が効かない場合があります。

```jsx
// ⚠️ 問題: 毎回新しい関数が作成される
function Parent() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            {/* 毎回新しい関数が作成されるため、再レンダリングされる */}
            <MemoizedChild onUpdate={() => console.log('更新')} />
        </div>
    );
}
```

この問題を解決するには、`useCallback`を使います（次の章で詳しく学びます）。

### React.memoを使うべき場合

1. **重い計算を行うコンポーネント**: レンダリングに時間がかかるコンポーネント
2. **頻繁に再レンダリングされる親の子**: 親が頻繁に再レンダリングされる場合
3. **Propsが変更されにくいコンポーネント**: 同じPropsで何度もレンダリングされる場合

### React.memoを使わない方が良い場合

1. **軽量なコンポーネント**: レンダリングが軽いコンポーネント
2. **Propsが頻繁に変わるコンポーネント**: Propsがよく変わる場合、メモ化の効果が薄い
3. **比較のコストが高い場合**: カスタム比較関数が複雑な場合

---

## まとめ

この章では、Reactの再レンダリングの仕組みと`React.memo`によるメモ化について学びました。

### 学んだこと
- **レンダリングが起きる条件**: Stateの変更、Propsの変更、親コンポーネントの再レンダリング
- **React.memo**: Propsが変更されていない場合に再レンダリングをスキップする機能
- **浅い比較**: React.memoはPropsを浅く比較する
- **注意点**: オブジェクトや関数のPropsに注意が必要

### 重要なポイント
1. **再レンダリングの条件**: State、Props、親コンポーネントの変更
2. **React.memo**: 不要な再レンダリングを防ぐ
3. **浅い比較**: オブジェクトや配列の参照を比較する
4. **使い分け**: 重いコンポーネントや頻繁に再レンダリングされる場合に使用

### 使い分けの目安
- **React.memoを使う**: 重い計算を行うコンポーネント、頻繁に再レンダリングされる親の子
- **React.memoを使わない**: 軽量なコンポーネント、Propsが頻繁に変わるコンポーネント

### 次のステップ
次の章では、フックによるメモ化（`useCallback`と`useMemo`）について詳しく学びます。これらを組み合わせることで、より効果的なパフォーマンス最適化ができるようになります。

---

## 演習問題

### 問題1: レンダリングの確認
Stateが変更されたときに再レンダリングされることを確認するコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
import { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);
    
    console.log('Counterがレンダリングされました');
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
        </div>
    );
}
```
</details>

### 問題2: Propsの変更による再レンダリング
親コンポーネントからPropsを受け取り、Propsが変更されたときに再レンダリングされることを確認するコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
import { useState } from 'react';

function Parent() {
    const [name, setName] = useState('太郎');
    
    return (
        <div>
            <input 
                value={name} 
                onChange={(e) => setName(e.target.value)} 
            />
            <Child name={name} />
        </div>
    );
}

function Child({ name }) {
    console.log('Childがレンダリングされました');
    return <p>名前: {name}</p>;
}
```
</details>

### 問題3: React.memoの基本使用
`React.memo`を使って、Propsが変更されていない場合に再レンダリングをスキップするコンポーネントを作成してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, memo } from 'react';

function Parent() {
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <MemoizedChild name="太郎" />
        </div>
    );
}

function Child({ name }) {
    console.log('Childがレンダリングされました');
    return <p>名前: {name}</p>;
}

const MemoizedChild = memo(Child);
```
</details>

### 問題4: リストアイテムのメモ化
リストアイテムを`React.memo`でメモ化し、親が再レンダリングされてもアイテムが再レンダリングされないようにしてください。

<details>
<summary>解答例</summary>

```jsx
import { useState, memo } from 'react';

function ListItem({ item }) {
    console.log(`ListItem ${item.id} がレンダリングされました`);
    return <li>{item.name}</li>;
}

const MemoizedListItem = memo(ListItem);

function List() {
    const [items] = useState([
        { id: 1, name: 'アイテム1' },
        { id: 2, name: 'アイテム2' },
        { id: 3, name: 'アイテム3' }
    ]);
    const [count, setCount] = useState(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <ul>
                {items.map(item => (
                    <MemoizedListItem key={item.id} item={item} />
                ))}
            </ul>
        </div>
    );
}
```
</details>

### 問題5: カスタム比較関数
`React.memo`にカスタム比較関数を指定し、特定のPropsが変更された場合のみ再レンダリングするようにしてください。

<details>
<summary>解答例</summary>

```jsx
import { useState, memo } from 'react';

function UserCard({ name, age }) {
    console.log('UserCardがレンダリングされました');
    return (
        <div>
            <p>名前: {name}</p>
            <p>年齢: {age}</p>
        </div>
    );
}

// カスタム比較関数: nameが同じなら再レンダリングしない
const MemoizedUserCard = memo(UserCard, (prevProps, nextProps) => {
    return prevProps.name === nextProps.name;
});

function App() {
    const [name, setName] = useState('太郎');
    const [age, setAge] = useState(25);
    
    return (
        <div>
            <input 
                value={name} 
                onChange={(e) => setName(e.target.value)} 
            />
            <button onClick={() => setAge(age + 1)}>年齢を増やす</button>
            <MemoizedUserCard name={name} age={age} />
        </div>
    );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。


