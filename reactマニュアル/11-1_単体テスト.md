# 11-1. 単体テスト

この章では、Reactコンポーネントの単体テストについて学びます。VitestとReact Testing Libraryを使用して、コンポーネントの動作をテストできるようになります。

---

## 目次

- [テスト環境の構築 (Vitest)](#テスト環境の構築-vitest)
- [コンポーネントのレンダリングテスト](#コンポーネントのレンダリングテスト)
- [ユーザー操作のシミュレーション](#ユーザー操作のシミュレーション)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## テスト環境の構築 (Vitest)

### Vitestとは
Vitestは、**Viteベースの高速なテストフレームワーク**です。Viteプロジェクトと統合されており、非常に高速にテストを実行できます。

### Vitestの主な特徴
- **高速**: Viteの高速なビルドシステムを活用
- **Vite統合**: Viteプロジェクトとシームレスに統合
- **TypeScript対応**: TypeScriptを標準でサポート
- **モダンなAPI**: Jest互換のAPIを提供

### インストール

```bash
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

### 必要なパッケージの説明
- **vitest**: テストフレームワーク
- **@testing-library/react**: Reactコンポーネントのテスト用ライブラリ
- **@testing-library/jest-dom**: DOM要素のマッチャー
- **@testing-library/user-event**: ユーザー操作のシミュレーション
- **jsdom**: DOM環境のシミュレーション

### vite.config.jsの設定

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.js',
  },
})
```

### セットアップファイルの作成

```javascript
// src/test/setup.js
import '@testing-library/jest-dom'
```

### package.jsonの設定

```json
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:coverage": "vitest --coverage"
  }
}
```

### 実践例: 完全なセットアップ

```bash
# パッケージのインストール
npm install -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event jsdom
```

```javascript
// vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.js',
    css: true,
  },
})
```

```javascript
// src/test/setup.js
import '@testing-library/jest-dom'
```

```json
// package.json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:run": "vitest run",
    "test:coverage": "vitest --coverage"
  }
}
```

---

## コンポーネントのレンダリングテスト

### レンダリングテストとは
レンダリングテストは、**コンポーネントが正しく表示されるかを確認する**テストです。

### 基本的なレンダリングテスト

```jsx
// src/components/Button.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Button from './Button'

describe('Button', () => {
  it('ボタンがレンダリングされる', () => {
    render(<Button label="クリック" />)
    expect(screen.getByText('クリック')).toBeInTheDocument()
  })
})
```

### render関数
`render`関数は、**コンポーネントをテスト環境にレンダリングする**関数です。

### screenオブジェクト
`screen`オブジェクトは、**レンダリングされたコンポーネントにアクセスする**ためのオブジェクトです。

### 実践例: 基本的なレンダリングテスト

```jsx
// src/components/Greeting.jsx
function Greeting({ name }) {
  return <h1>こんにちは、{name}さん！</h1>
}

export default Greeting
```

```jsx
// src/components/Greeting.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Greeting from './Greeting'

describe('Greeting', () => {
  it('名前が表示される', () => {
    render(<Greeting name="太郎" />)
    expect(screen.getByText('こんにちは、太郎さん！')).toBeInTheDocument()
  })
  
  it('異なる名前でも正しく表示される', () => {
    render(<Greeting name="花子" />)
    expect(screen.getByText('こんにちは、花子さん！')).toBeInTheDocument()
  })
})
```

### 実践例: 複数の要素のテスト

```jsx
// src/components/UserCard.jsx
function UserCard({ name, age, email }) {
  return (
    <div>
      <h2>{name}</h2>
      <p>年齢: {age}歳</p>
      <p>メール: {email}</p>
    </div>
  )
}

export default UserCard
```

```jsx
// src/components/UserCard.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import UserCard from './UserCard'

describe('UserCard', () => {
  it('ユーザー情報が正しく表示される', () => {
    render(<UserCard name="太郎" age={25} email="taro@example.com" />)
    
    expect(screen.getByText('太郎')).toBeInTheDocument()
    expect(screen.getByText('年齢: 25歳')).toBeInTheDocument()
    expect(screen.getByText('メール: taro@example.com')).toBeInTheDocument()
  })
})
```

### 実践例: 条件付きレンダリングのテスト

```jsx
// src/components/ConditionalRender.jsx
function ConditionalRender({ isVisible, message }) {
  if (!isVisible) {
    return null
  }
  
  return <div>{message}</div>
}

export default ConditionalRender
```

```jsx
// src/components/ConditionalRender.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import ConditionalRender from './ConditionalRender'

describe('ConditionalRender', () => {
  it('isVisibleがtrueのときにメッセージが表示される', () => {
    render(<ConditionalRender isVisible={true} message="表示されます" />)
    expect(screen.getByText('表示されます')).toBeInTheDocument()
  })
  
  it('isVisibleがfalseのときに何も表示されない', () => {
    render(<ConditionalRender isVisible={false} message="表示されません" />)
    expect(screen.queryByText('表示されません')).not.toBeInTheDocument()
  })
})
```

### 実践例: リストのレンダリングテスト

```jsx
// src/components/ItemList.jsx
function ItemList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  )
}

export default ItemList
```

```jsx
// src/components/ItemList.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import ItemList from './ItemList'

describe('ItemList', () => {
  it('アイテムのリストが表示される', () => {
    const items = ['りんご', 'バナナ', 'オレンジ']
    render(<ItemList items={items} />)
    
    expect(screen.getByText('りんご')).toBeInTheDocument()
    expect(screen.getByText('バナナ')).toBeInTheDocument()
    expect(screen.getByText('オレンジ')).toBeInTheDocument()
  })
  
  it('空のリストの場合は何も表示されない', () => {
    render(<ItemList items={[]} />)
    const list = screen.queryByRole('list')
    expect(list).toBeInTheDocument()
    expect(list?.children.length).toBe(0)
  })
})
```

---

## ユーザー操作のシミュレーション

### ユーザー操作のシミュレーションとは
ユーザー操作のシミュレーションは、**ボタンクリックや入力などのユーザー操作をテストで再現する**ことです。

### @testing-library/user-event
`@testing-library/user-event`は、**ユーザー操作をシミュレーションする**ライブラリです。

### 基本的な使い方

```jsx
import userEvent from '@testing-library/user-event'

const user = userEvent.setup()
await user.click(button)
```

### 実践例: ボタンクリックのテスト

```jsx
// src/components/Counter.jsx
import { useState } from 'react'

function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>増やす</button>
      <button onClick={() => setCount(count - 1)}>減らす</button>
      <button onClick={() => setCount(0)}>リセット</button>
    </div>
  )
}

export default Counter
```

```jsx
// src/components/Counter.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Counter from './Counter'

describe('Counter', () => {
  it('初期値が0で表示される', () => {
    render(<Counter />)
    expect(screen.getByText('カウント: 0')).toBeInTheDocument()
  })
  
  it('増やすボタンをクリックするとカウントが増える', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    const incrementButton = screen.getByText('増やす')
    await user.click(incrementButton)
    
    expect(screen.getByText('カウント: 1')).toBeInTheDocument()
  })
  
  it('減らすボタンをクリックするとカウントが減る', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    const decrementButton = screen.getByText('減らす')
    await user.click(decrementButton)
    
    expect(screen.getByText('カウント: -1')).toBeInTheDocument()
  })
  
  it('リセットボタンをクリックするとカウントが0になる', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    // まずカウントを増やす
    await user.click(screen.getByText('増やす'))
    await user.click(screen.getByText('増やす'))
    
    // リセット
    await user.click(screen.getByText('リセット'))
    
    expect(screen.getByText('カウント: 0')).toBeInTheDocument()
  })
})
```

### 実践例: 入力フィールドのテスト

```jsx
// src/components/Input.jsx
import { useState } from 'react'

function Input({ label, onChange }) {
  const [value, setValue] = useState('')
  
  const handleChange = (e) => {
    const newValue = e.target.value
    setValue(newValue)
    if (onChange) {
      onChange(newValue)
    }
  }
  
  return (
    <div>
      <label>{label}</label>
      <input
        type="text"
        value={value}
        onChange={handleChange}
        placeholder="入力してください"
      />
    </div>
  )
}

export default Input
```

```jsx
// src/components/Input.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Input from './Input'

describe('Input', () => {
  it('入力フィールドがレンダリングされる', () => {
    render(<Input label="名前" />)
    expect(screen.getByLabelText('名前')).toBeInTheDocument()
  })
  
  it('入力すると値が更新される', async () => {
    const user = userEvent.setup()
    render(<Input label="名前" />)
    
    const input = screen.getByLabelText('名前')
    await user.type(input, '太郎')
    
    expect(input).toHaveValue('太郎')
  })
  
  it('onChangeコールバックが呼び出される', async () => {
    const user = userEvent.setup()
    const handleChange = vi.fn()
    render(<Input label="名前" onChange={handleChange} />)
    
    const input = screen.getByLabelText('名前')
    await user.type(input, '太郎')
    
    expect(handleChange).toHaveBeenCalledWith('太郎')
  })
})
```

### 実践例: フォーム送信のテスト

```jsx
// src/components/ContactForm.jsx
import { useState } from 'react'

function ContactForm({ onSubmit }) {
  const [name, setName] = useState('')
  const [email, setEmail] = useState('')
  const [message, setMessage] = useState('')
  
  const handleSubmit = (e) => {
    e.preventDefault()
    if (onSubmit) {
      onSubmit({ name, email, message })
    }
    // フォームをリセット
    setName('')
    setEmail('')
    setMessage('')
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>名前</label>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
      </div>
      <div>
        <label>メールアドレス</label>
        <input
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
      </div>
      <div>
        <label>メッセージ</label>
        <textarea
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
      </div>
      <button type="submit">送信</button>
    </form>
  )
}

export default ContactForm
```

```jsx
// src/components/ContactForm.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import ContactForm from './ContactForm'

describe('ContactForm', () => {
  it('フォームがレンダリングされる', () => {
    render(<ContactForm />)
    
    expect(screen.getByLabelText('名前')).toBeInTheDocument()
    expect(screen.getByLabelText('メールアドレス')).toBeInTheDocument()
    expect(screen.getByLabelText('メッセージ')).toBeInTheDocument()
    expect(screen.getByText('送信')).toBeInTheDocument()
  })
  
  it('フォーム送信時にonSubmitが呼び出される', async () => {
    const user = userEvent.setup()
    const handleSubmit = vi.fn()
    render(<ContactForm onSubmit={handleSubmit} />)
    
    // フォームに入力
    await user.type(screen.getByLabelText('名前'), '太郎')
    await user.type(screen.getByLabelText('メールアドレス'), 'taro@example.com')
    await user.type(screen.getByLabelText('メッセージ'), 'テストメッセージ')
    
    // フォームを送信
    await user.click(screen.getByText('送信'))
    
    expect(handleSubmit).toHaveBeenCalledWith({
      name: '太郎',
      email: 'taro@example.com',
      message: 'テストメッセージ'
    })
  })
  
  it('フォーム送信後に入力がクリアされる', async () => {
    const user = userEvent.setup()
    render(<ContactForm />)
    
    const nameInput = screen.getByLabelText('名前')
    const emailInput = screen.getByLabelText('メールアドレス')
    const messageInput = screen.getByLabelText('メッセージ')
    
    // フォームに入力
    await user.type(nameInput, '太郎')
    await user.type(emailInput, 'taro@example.com')
    await user.type(messageInput, 'テストメッセージ')
    
    // フォームを送信
    await user.click(screen.getByText('送信'))
    
    // 入力がクリアされていることを確認
    expect(nameInput).toHaveValue('')
    expect(emailInput).toHaveValue('')
    expect(messageInput).toHaveValue('')
  })
})
```

### 実践例: チェックボックスのテスト

```jsx
// src/components/Checkbox.jsx
import { useState } from 'react'

function Checkbox({ label, onChange }) {
  const [checked, setChecked] = useState(false)
  
  const handleChange = (e) => {
    const newChecked = e.target.checked
    setChecked(newChecked)
    if (onChange) {
      onChange(newChecked)
    }
  }
  
  return (
    <label>
      <input
        type="checkbox"
        checked={checked}
        onChange={handleChange}
      />
      {label}
    </label>
  )
}

export default Checkbox
```

```jsx
// src/components/Checkbox.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Checkbox from './Checkbox'

describe('Checkbox', () => {
  it('チェックボックスがレンダリングされる', () => {
    render(<Checkbox label="同意する" />)
    expect(screen.getByLabelText('同意する')).toBeInTheDocument()
  })
  
  it('クリックするとチェック状態が変わる', async () => {
    const user = userEvent.setup()
    render(<Checkbox label="同意する" />)
    
    const checkbox = screen.getByLabelText('同意する')
    expect(checkbox).not.toBeChecked()
    
    await user.click(checkbox)
    expect(checkbox).toBeChecked()
    
    await user.click(checkbox)
    expect(checkbox).not.toBeChecked()
  })
  
  it('onChangeコールバックが呼び出される', async () => {
    const user = userEvent.setup()
    const handleChange = vi.fn()
    render(<Checkbox label="同意する" onChange={handleChange} />)
    
    const checkbox = screen.getByLabelText('同意する')
    await user.click(checkbox)
    
    expect(handleChange).toHaveBeenCalledWith(true)
  })
})
```

### 実践例: セレクトボックスのテスト

```jsx
// src/components/Select.jsx
import { useState } from 'react'

function Select({ options, onChange }) {
  const [value, setValue] = useState('')
  
  const handleChange = (e) => {
    const newValue = e.target.value
    setValue(newValue)
    if (onChange) {
      onChange(newValue)
    }
  }
  
  return (
    <select value={value} onChange={handleChange}>
      <option value="">選択してください</option>
      {options.map(option => (
        <option key={option.value} value={option.value}>
          {option.label}
        </option>
      ))}
    </select>
  )
}

export default Select
```

```jsx
// src/components/Select.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Select from './Select'

describe('Select', () => {
  const options = [
    { value: 'option1', label: 'オプション1' },
    { value: 'option2', label: 'オプション2' },
    { value: 'option3', label: 'オプション3' }
  ]
  
  it('セレクトボックスがレンダリングされる', () => {
    render(<Select options={options} />)
    expect(screen.getByRole('combobox')).toBeInTheDocument()
  })
  
  it('オプションが選択できる', async () => {
    const user = userEvent.setup()
    render(<Select options={options} />)
    
    const select = screen.getByRole('combobox')
    await user.selectOptions(select, 'option1')
    
    expect(select).toHaveValue('option1')
  })
  
  it('onChangeコールバックが呼び出される', async () => {
    const user = userEvent.setup()
    const handleChange = vi.fn()
    render(<Select options={options} onChange={handleChange} />)
    
    const select = screen.getByRole('combobox')
    await user.selectOptions(select, 'option2')
    
    expect(handleChange).toHaveBeenCalledWith('option2')
  })
})
```

---

## まとめ

この章では、Reactコンポーネントの単体テストについて学びました。

### 学んだこと
- テスト環境の構築: VitestとReact Testing Libraryのセットアップ
- コンポーネントのレンダリングテスト: コンポーネントが正しく表示されるかを確認
- ユーザー操作のシミュレーション: ボタンクリック、入力、フォーム送信などの操作をテスト

### 重要なポイント
1. **Vitest**: Viteベースの高速なテストフレームワーク
2. **render**: コンポーネントをテスト環境にレンダリング
3. **screen**: レンダリングされたコンポーネントにアクセス
4. **userEvent**: ユーザー操作をシミュレーション
5. **テストの構造**: describe、it、expectを使用

### 次のステップ
次の章では、モックと非同期テストについて詳しく学びます。

---

## 演習問題

### 問題1: 基本的なレンダリングテスト
`Button`コンポーネントを作成し、`label`というPropsを受け取って表示するテストを書いてください。

<details>
<summary>解答例</summary>

```jsx
// src/components/Button.jsx
function Button({ label }) {
  return <button>{label}</button>
}

export default Button
```

```jsx
// src/components/Button.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Button from './Button'

describe('Button', () => {
  it('ラベルが表示される', () => {
    render(<Button label="クリック" />)
    expect(screen.getByText('クリック')).toBeInTheDocument()
  })
})
```
</details>

### 問題2: ボタンクリックのテスト
`Counter`コンポーネントを作成し、ボタンをクリックするとカウントが増えることをテストしてください。

<details>
<summary>解答例</summary>

```jsx
// src/components/Counter.jsx
import { useState } from 'react'

function Counter() {
  const [count, setCount] = useState(0)
  
  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>増やす</button>
    </div>
  )
}

export default Counter
```

```jsx
// src/components/Counter.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Counter from './Counter'

describe('Counter', () => {
  it('ボタンをクリックするとカウントが増える', async () => {
    const user = userEvent.setup()
    render(<Counter />)
    
    const button = screen.getByText('増やす')
    await user.click(button)
    
    expect(screen.getByText('カウント: 1')).toBeInTheDocument()
  })
})
```
</details>

### 問題3: 入力フィールドのテスト
`Input`コンポーネントを作成し、入力すると値が更新されることをテストしてください。

<details>
<summary>解答例</summary>

```jsx
// src/components/Input.jsx
import { useState } from 'react'

function Input({ label }) {
  const [value, setValue] = useState('')
  
  return (
    <div>
      <label>{label}</label>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
    </div>
  )
}

export default Input
```

```jsx
// src/components/Input.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Input from './Input'

describe('Input', () => {
  it('入力すると値が更新される', async () => {
    const user = userEvent.setup()
    render(<Input label="名前" />)
    
    const input = screen.getByLabelText('名前')
    await user.type(input, '太郎')
    
    expect(input).toHaveValue('太郎')
  })
})
```
</details>

### 問題4: 条件付きレンダリングのテスト
`ConditionalComponent`コンポーネントを作成し、条件に応じて表示/非表示が切り替わることをテストしてください。

<details>
<summary>解答例</summary>

```jsx
// src/components/ConditionalComponent.jsx
function ConditionalComponent({ isVisible, message }) {
  if (!isVisible) {
    return null
  }
  
  return <div>{message}</div>
}

export default ConditionalComponent
```

```jsx
// src/components/ConditionalComponent.test.jsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import ConditionalComponent from './ConditionalComponent'

describe('ConditionalComponent', () => {
  it('isVisibleがtrueのときに表示される', () => {
    render(<ConditionalComponent isVisible={true} message="表示されます" />)
    expect(screen.getByText('表示されます')).toBeInTheDocument()
  })
  
  it('isVisibleがfalseのときに表示されない', () => {
    render(<ConditionalComponent isVisible={false} message="表示されません" />)
    expect(screen.queryByText('表示されません')).not.toBeInTheDocument()
  })
})
```
</details>

### 問題5: フォーム送信のテスト
`Form`コンポーネントを作成し、フォーム送信時にonSubmitが呼び出されることをテストしてください。

<details>
<summary>解答例</summary>

```jsx
// src/components/Form.jsx
import { useState } from 'react'

function Form({ onSubmit }) {
  const [value, setValue] = useState('')
  
  const handleSubmit = (e) => {
    e.preventDefault()
    if (onSubmit) {
      onSubmit(value)
    }
    setValue('')
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
      />
      <button type="submit">送信</button>
    </form>
  )
}

export default Form
```

```jsx
// src/components/Form.test.jsx
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Form from './Form'

describe('Form', () => {
  it('フォーム送信時にonSubmitが呼び出される', async () => {
    const user = userEvent.setup()
    const handleSubmit = vi.fn()
    render(<Form onSubmit={handleSubmit} />)
    
    const input = screen.getByRole('textbox')
    await user.type(input, 'テスト')
    await user.click(screen.getByText('送信'))
    
    expect(handleSubmit).toHaveBeenCalledWith('テスト')
  })
})
```
</details>

---

お疲れ様でした！次の章に進みましょう。

