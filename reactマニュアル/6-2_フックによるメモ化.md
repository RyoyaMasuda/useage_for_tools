# 6-2. フックによるメモ化

この章では、Reactのフック（useCallbackとuseMemo）を使ったメモ化について学びます。メモ化を理解することで、不要な再計算や再レンダリングを防ぎ、パフォーマンスを最適化できるようになります。

---

## 目次

- [useCallback (関数のメモ化)](#usecallback-関数のメモ化)
- [useMemo (計算結果のメモ化)](#usememo-計算結果のメモ化)
- [まとめ](#まとめ)
- [演習問題](#演習問題)

---

## useCallback (関数のメモ化)

### useCallbackとは
useCallbackは、**関数をメモ化して、依存配列の値が変更されない限り同じ関数参照を返す**フックです。子コンポーネントに渡す関数をメモ化することで、不要な再レンダリングを防げます。

### 日常生活での例
- **レシピの保存**: 同じレシピ（関数）を何度も使うとき、毎回作り直さずに保存しておく（メモ化）
- **電話番号の記憶**: よく使う電話番号（関数）を覚えておく（メモ化）
- **計算式の保存**: 同じ計算式（関数）を何度も使うとき、保存しておく（メモ化）

### useCallbackの基本構文

```jsx
import { useCallback } from 'react';

const memoizedCallback = useCallback(
    () => {
        // 関数の処理
    },
    [依存配列]
);
```

### useCallbackの動作

1. **依存配列の値が変更されない場合**: 前回と同じ関数参照を返す
2. **依存配列の値が変更された場合**: 新しい関数を作成して返す

### 実践例: useCallbackの使用

```jsx
// src/App.jsx
import React, { useState, useCallback, memo } from 'react';

// 例1: 基本的なuseCallback
function BasicUseCallback() {
    const [count, setCount] = useState(0);
    const [otherState, setOtherState] = useState(0);
    
    // useCallbackで関数をメモ化
    const handleIncrement = useCallback(() => {
        setCount(prev => prev + 1);
    }, []); // 依存配列が空なので、常に同じ関数参照
    
    // useCallbackなし（毎回新しい関数が作成される）
    const handleDecrement = () => {
        setCount(prev => prev - 1);
    };
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>その他の状態: {otherState}</p>
            <button onClick={handleIncrement}>増やす（メモ化）</button>
            <button onClick={handleDecrement}>減らす（メモ化なし）</button>
            <button onClick={() => setOtherState(otherState + 1)}>
                その他の状態を変更
            </button>
        </div>
    );
}

// 例2: 依存配列を使ったuseCallback
function UseCallbackWithDependency() {
    const [count, setCount] = useState(0);
    const [multiplier, setMultiplier] = useState(2);
    
    // multiplierが変更されたときのみ新しい関数を作成
    const handleMultiply = useCallback(() => {
        setCount(prev => prev * multiplier);
    }, [multiplier]); // multiplierを依存配列に指定
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>倍数: {multiplier}</p>
            <button onClick={handleMultiply}>倍数をかける</button>
            <button onClick={() => setMultiplier(multiplier + 1)}>
                倍数を増やす
            </button>
        </div>
    );
}

// 例3: 子コンポーネントに渡す関数のメモ化
const ChildComponent = memo(function ChildComponent({ onButtonClick, label }) {
    console.log(`${label}がレンダリングされました`);
    return <button onClick={onButtonClick}>{label}</button>;
});

function ParentWithCallback() {
    const [count1, setCount1] = useState(0);
    const [count2, setCount2] = useState(0);
    
    // useCallbackでメモ化（count1が変更されない限り同じ関数参照）
    const handleClick1 = useCallback(() => {
        setCount1(prev => prev + 1);
    }, []); // 依存配列が空なので常に同じ関数
    
    // useCallbackなし（毎回新しい関数が作成される）
    const handleClick2 = () => {
        setCount2(prev => prev + 1);
    };
    
    return (
        <div>
            <p>カウント1: {count1}</p>
            <p>カウント2: {count2}</p>
            <ChildComponent 
                onButtonClick={handleClick1} 
                label="ボタン1（メモ化）"
            />
            <ChildComponent 
                onButtonClick={handleClick2} 
                label="ボタン2（メモ化なし）"
            />
            <p>※カウント2を変更すると、ボタン2のコンポーネントのみ再レンダリングされます</p>
        </div>
    );
}

// 例4: イベントハンドラーでのuseCallback
function EventHandlerWithCallback() {
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    
    // useCallbackでメモ化
    const handleNameChange = useCallback((e) => {
        setName(e.target.value);
    }, []);
    
    const handleEmailChange = useCallback((e) => {
        setEmail(e.target.value);
    }, []);
    
    const handleSubmit = useCallback((e) => {
        e.preventDefault();
        console.log('送信:', { name, email });
    }, [name, email]); // nameとemailを依存配列に指定
    
    return (
        <form onSubmit={handleSubmit}>
            <input
                value={name}
                onChange={handleNameChange}
                placeholder="名前"
            />
            <input
                type="email"
                value={email}
                onChange={handleEmailChange}
                placeholder="メールアドレス"
            />
            <button type="submit">送信</button>
        </form>
    );
}

// 例5: カスタムフックでのuseCallback
function useCounter(initialValue = 0) {
    const [count, setCount] = useState(initialValue);
    
    const increment = useCallback(() => {
        setCount(prev => prev + 1);
    }, []);
    
    const decrement = useCallback(() => {
        setCount(prev => prev - 1);
    }, []);
    
    const reset = useCallback(() => {
        setCount(initialValue);
    }, [initialValue]);
    
    return { count, increment, decrement, reset };
}

function CustomHookExample() {
    const { count, increment, decrement, reset } = useCounter(0);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={increment}>増やす</button>
            <button onClick={decrement}>減らす</button>
            <button onClick={reset}>リセット</button>
        </div>
    );
}

// 例6: 配列操作でのuseCallback
function ArrayOperationsWithCallback() {
    const [items, setItems] = useState(['アイテム1', 'アイテム2']);
    const [newItem, setNewItem] = useState('');
    
    // useCallbackでメモ化
    const handleAdd = useCallback(() => {
        if (newItem.trim()) {
            setItems(prev => [...prev, newItem]);
            setNewItem('');
        }
    }, [newItem]); // newItemを依存配列に指定
    
    const handleRemove = useCallback((index) => {
        setItems(prev => prev.filter((_, i) => i !== index));
    }, []); // 依存配列が空なので常に同じ関数
    
    return (
        <div>
            <input
                value={newItem}
                onChange={(e) => setNewItem(e.target.value)}
                placeholder="新しいアイテム"
            />
            <button onClick={handleAdd}>追加</button>
            <ul>
                {items.map((item, index) => (
                    <li key={index}>
                        {item}
                        <button onClick={() => handleRemove(index)}>削除</button>
                    </li>
                ))}
            </ul>
        </div>
    );
}

// メインコンポーネント
function App() {
    return (
        <div className="app">
            <h1>useCallback (関数のメモ化)</h1>
            <BasicUseCallback />
            <hr />
            <UseCallbackWithDependency />
            <hr />
            <ParentWithCallback />
            <hr />
            <EventHandlerWithCallback />
            <hr />
            <CustomHookExample />
            <hr />
            <ArrayOperationsWithCallback />
        </div>
    );
}

export default App;
```

### useCallbackを使うべき場合

1. **子コンポーネントに渡す関数**: React.memoでメモ化された子コンポーネントに渡す関数
2. **依存配列に含める関数**: useEffectやuseMemoの依存配列に含める関数
3. **カスタムフックで返す関数**: カスタムフックから返す関数

### useCallbackを使わない方が良い場合

1. **軽量な関数**: 関数の作成コストが低い場合
2. **依存配列が頻繁に変わる関数**: 依存配列が頻繁に変わる場合、メモ化の効果が薄い
3. **単純なイベントハンドラー**: 子コンポーネントに渡さない単純なイベントハンドラー

---

## useMemo (計算結果のメモ化)

### useMemoとは
useMemoは、**計算結果をメモ化して、依存配列の値が変更されない限り同じ値を返す**フックです。重い計算をメモ化することで、不要な再計算を防げます。

### 日常生活での例
- **計算結果の保存**: 同じ計算を何度もするとき、結果を保存しておく（メモ化）
- **レシピの完成品**: 同じ材料で作った料理（計算結果）を保存しておく（メモ化）
- **検索結果のキャッシュ**: 同じ検索条件の結果（計算結果）を保存しておく（メモ化）

### useMemoの基本構文

```jsx
import { useMemo } from 'react';

const memoizedValue = useMemo(
    () => {
        // 計算処理
        return 計算結果;
    },
    [依存配列]
);
```

### useMemoの動作

1. **依存配列の値が変更されない場合**: 前回の計算結果を返す
2. **依存配列の値が変更された場合**: 計算を実行して新しい結果を返す

### 実践例: useMemoの使用

```jsx
// src/App.jsx
import React, { useState, useMemo } from 'react';

// 重い計算をシミュレート
function heavyCalculation(n) {
    console.log('重い計算を実行中...');
    let result = 0;
    for (let i = 0; i < n * 1000000; i++) {
        result += i;
    }
    return result;
}

// 例1: 基本的なuseMemo
function BasicUseMemo() {
    const [count, setCount] = useState(100);
    const [otherState, setOtherState] = useState(0);
    
    // useMemoで計算結果をメモ化
    const expensiveValue = useMemo(() => {
        return heavyCalculation(count);
    }, [count]); // countが変更されたときのみ再計算
    
    // useMemoなし（毎回計算が実行される）
    const unMemoizedValue = heavyCalculation(count);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>その他の状態: {otherState}</p>
            <p>メモ化された値: {expensiveValue}</p>
            <p>メモ化されていない値: {unMemoizedValue}</p>
            <button onClick={() => setCount(count + 10)}>カウントを増やす</button>
            <button onClick={() => setOtherState(otherState + 1)}>
                その他の状態を変更
            </button>
            <p>※その他の状態を変更しても、メモ化された値は再計算されません</p>
        </div>
    );
}

// 例2: 配列のフィルタリングとソート
function FilterAndSortWithMemo() {
    const [items, setItems] = useState([
        { id: 1, name: 'りんご', price: 100 },
        { id: 2, name: 'バナナ', price: 80 },
        { id: 3, name: 'オレンジ', price: 120 },
        { id: 4, name: 'ぶどう', price: 200 }
    ]);
    const [filter, setFilter] = useState('');
    const [sortBy, setSortBy] = useState('name');
    
    // useMemoでフィルタリングとソートをメモ化
    const filteredAndSortedItems = useMemo(() => {
        console.log('フィルタリングとソートを実行中...');
        let result = [...items];
        
        // フィルタリング
        if (filter) {
            result = result.filter(item => 
                item.name.toLowerCase().includes(filter.toLowerCase())
            );
        }
        
        // ソート
        result.sort((a, b) => {
            if (sortBy === 'name') {
                return a.name.localeCompare(b.name);
            } else if (sortBy === 'price') {
                return a.price - b.price;
            }
            return 0;
        });
        
        return result;
    }, [items, filter, sortBy]); // items、filter、sortByが変更されたときのみ再計算
    
    return (
        <div>
            <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                placeholder="検索"
            />
            <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
                <option value="name">名前でソート</option>
                <option value="price">価格でソート</option>
            </select>
            <ul>
                {filteredAndSortedItems.map(item => (
                    <li key={item.id}>
                        {item.name} - ¥{item.price}
                    </li>
                ))}
            </ul>
        </div>
    );
}

// 例3: オブジェクトのメモ化
function ObjectMemoization() {
    const [count, setCount] = useState(0);
    const [name, setName] = useState('太郎');
    
    // useMemoでオブジェクトをメモ化
    const user = useMemo(() => {
        return {
            id: count,
            name: name,
            displayName: `${name} (ID: ${count})`
        };
    }, [count, name]); // countまたはnameが変更されたときのみ再作成
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>名前: {name}</p>
            <p>ユーザー: {user.displayName}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <input
                value={name}
                onChange={(e) => setName(e.target.value)}
                placeholder="名前"
            />
        </div>
    );
}

// 例4: 配列のメモ化
function ArrayMemoization() {
    const [count, setCount] = useState(5);
    
    // useMemoで配列をメモ化
    const numbers = useMemo(() => {
        console.log('配列を生成中...');
        return Array.from({ length: count }, (_, i) => i + 1);
    }, [count]); // countが変更されたときのみ再生成
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>数値配列: {numbers.join(', ')}</p>
            <button onClick={() => setCount(count + 1)}>カウントを増やす</button>
        </div>
    );
}

// 例5: 複雑な計算のメモ化
function ComplexCalculation() {
    const [numbers, setNumbers] = useState([1, 2, 3, 4, 5]);
    const [multiplier, setMultiplier] = useState(2);
    
    // useMemoで複雑な計算をメモ化
    const statistics = useMemo(() => {
        console.log('統計を計算中...');
        const sum = numbers.reduce((acc, num) => acc + num, 0);
        const average = sum / numbers.length;
        const max = Math.max(...numbers);
        const min = Math.min(...numbers);
        const multiplied = numbers.map(num => num * multiplier);
        
        return {
            sum,
            average,
            max,
            min,
            multiplied
        };
    }, [numbers, multiplier]); // numbersまたはmultiplierが変更されたときのみ再計算
    
    return (
        <div>
            <p>数値: {numbers.join(', ')}</p>
            <p>倍数: {multiplier}</p>
            <p>合計: {statistics.sum}</p>
            <p>平均: {statistics.average}</p>
            <p>最大値: {statistics.max}</p>
            <p>最小値: {statistics.min}</p>
            <p>倍数をかけた値: {statistics.multiplied.join(', ')}</p>
            <button onClick={() => setNumbers([...numbers, numbers.length + 1])}>
                数値を追加
            </button>
            <button onClick={() => setMultiplier(multiplier + 1)}>
                倍数を増やす
            </button>
        </div>
    );
}

// 例6: 条件付きメモ化
function ConditionalMemoization() {
    const [count, setCount] = useState(0);
    const [enabled, setEnabled] = useState(true);
    
    // useMemoで条件付き計算をメモ化
    const result = useMemo(() => {
        if (!enabled) {
            return 0;
        }
        console.log('計算を実行中...');
        return count * 2;
    }, [count, enabled]); // countまたはenabledが変更されたときのみ再計算
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>有効: {enabled ? 'はい' : 'いいえ'}</p>
            <p>結果: {result}</p>
            <button onClick={() => setCount(count + 1)}>カウントアップ</button>
            <button onClick={() => setEnabled(!enabled)}>
                {enabled ? '無効化' : '有効化'}
            </button>
        </div>
    );
}

// メインコンポーネント
function App() {
    return (
        <div className="app">
            <h1>useMemo (計算結果のメモ化)</h1>
            <BasicUseMemo />
            <hr />
            <FilterAndSortWithMemo />
            <hr />
            <ObjectMemoization />
            <hr />
            <ArrayMemoization />
            <hr />
            <ComplexCalculation />
            <hr />
            <ConditionalMemoization />
        </div>
    );
}

export default App;
```

### useMemoを使うべき場合

1. **重い計算**: 計算コストが高い処理
2. **配列のフィルタリング・ソート**: 大きな配列のフィルタリングやソート
3. **オブジェクトや配列の作成**: 子コンポーネントに渡すオブジェクトや配列
4. **条件付き計算**: 条件によって結果が変わる計算

### useMemoを使わない方が良い場合

1. **軽量な計算**: 計算コストが低い処理
2. **プリミティブ値**: 文字列や数値などのプリミティブ値
3. **依存配列が頻繁に変わる計算**: 依存配列が頻繁に変わる場合、メモ化の効果が薄い

### useCallbackとuseMemoの使い分け

| 特徴 | useCallback | useMemo |
|------|-------------|---------|
| 対象 | 関数 | 値（計算結果） |
| 用途 | 関数の参照を保持 | 計算結果を保持 |
| 使用例 | 子コンポーネントに渡す関数 | 重い計算の結果 |

---

## まとめ

この章では、Reactのフックによるメモ化（useCallbackとuseMemo）について学びました。

### 学んだこと
- **useCallback**: 関数をメモ化して、同じ関数参照を返す
- **useMemo**: 計算結果をメモ化して、同じ値を返す
- **依存配列**: メモ化の条件を制御
- **使い分け**: useCallbackとuseMemoの適切な使い分け

### 重要なポイント
1. **useCallback**: 子コンポーネントに渡す関数や、依存配列に含める関数をメモ化
2. **useMemo**: 重い計算や、配列・オブジェクトの作成をメモ化
3. **依存配列**: 正しく設定して、不要な再計算を防ぐ
4. **使い分け**: 関数にはuseCallback、値にはuseMemoを使用
5. **パフォーマンス**: 適切に使用することで、パフォーマンスを最適化

### 使い分けの目安
- **useCallback**: 関数をメモ化したい場合、子コンポーネントに渡す関数
- **useMemo**: 計算結果をメモ化したい場合、重い計算や配列・オブジェクトの作成

### 次のステップ
メモ化を理解することで、不要な再計算や再レンダリングを防ぎ、パフォーマンスを最適化できるようになります。次の章では、レンダリングの計測について詳しく学びます。

---

## 演習問題

### 問題1: 基本的なuseCallback
useCallbackを使って、カウントを増やす関数をメモ化してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, useCallback } from 'react';

function App() {
    const [count, setCount] = useState(0);
    
    const handleIncrement = useCallback(() => {
        setCount(prev => prev + 1);
    }, []);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <button onClick={handleIncrement}>増やす</button>
        </div>
    );
}
```
</details>

### 問題2: 依存配列を使ったuseCallback
useCallbackを使って、依存配列に値を指定して関数をメモ化してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, useCallback } from 'react';

function App() {
    const [count, setCount] = useState(0);
    const [multiplier, setMultiplier] = useState(2);
    
    const handleMultiply = useCallback(() => {
        setCount(prev => prev * multiplier);
    }, [multiplier]);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>倍数: {multiplier}</p>
            <button onClick={handleMultiply}>倍数をかける</button>
            <button onClick={() => setMultiplier(multiplier + 1)}>
                倍数を増やす
            </button>
        </div>
    );
}
```
</details>

### 問題3: 基本的なuseMemo
useMemoを使って、重い計算の結果をメモ化してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, useMemo } from 'react';

function heavyCalculation(n) {
    let result = 0;
    for (let i = 0; i < n * 1000000; i++) {
        result += i;
    }
    return result;
}

function App() {
    const [count, setCount] = useState(100);
    
    const result = useMemo(() => {
        return heavyCalculation(count);
    }, [count]);
    
    return (
        <div>
            <p>カウント: {count}</p>
            <p>結果: {result}</p>
            <button onClick={() => setCount(count + 10)}>カウントを増やす</button>
        </div>
    );
}
```
</details>

### 問題4: 配列のフィルタリングとuseMemo
useMemoを使って、配列のフィルタリング結果をメモ化してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, useMemo } from 'react';

function App() {
    const [items, setItems] = useState([
        { id: 1, name: 'りんご', price: 100 },
        { id: 2, name: 'バナナ', price: 80 },
        { id: 3, name: 'オレンジ', price: 120 }
    ]);
    const [filter, setFilter] = useState('');
    
    const filteredItems = useMemo(() => {
        return items.filter(item => 
            item.name.toLowerCase().includes(filter.toLowerCase())
        );
    }, [items, filter]);
    
    return (
        <div>
            <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                placeholder="検索"
            />
            <ul>
                {filteredItems.map(item => (
                    <li key={item.id}>{item.name} - ¥{item.price}</li>
                ))}
            </ul>
        </div>
    );
}
```
</details>

### 問題5: useCallbackとuseMemoの組み合わせ
useCallbackとuseMemoを組み合わせて、パフォーマンスを最適化してください。

<details>
<summary>解答例</summary>

```jsx
import { useState, useCallback, useMemo, memo } from 'react';

const ChildComponent = memo(function ChildComponent({ items, onItemClick }) {
    return (
        <ul>
            {items.map(item => (
                <li key={item.id} onClick={() => onItemClick(item.id)}>
                    {item.name}
                </li>
            ))}
        </ul>
    );
});

function App() {
    const [items, setItems] = useState([
        { id: 1, name: 'アイテム1' },
        { id: 2, name: 'アイテム2' },
        { id: 3, name: 'アイテム3' }
    ]);
    const [filter, setFilter] = useState('');
    
    // useMemoでフィルタリング結果をメモ化
    const filteredItems = useMemo(() => {
        return items.filter(item => 
            item.name.toLowerCase().includes(filter.toLowerCase())
        );
    }, [items, filter]);
    
    // useCallbackで関数をメモ化
    const handleItemClick = useCallback((id) => {
        console.log(`アイテム${id}がクリックされました`);
    }, []);
    
    return (
        <div>
            <input
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                placeholder="検索"
            />
            <ChildComponent 
                items={filteredItems} 
                onItemClick={handleItemClick}
            />
        </div>
    );
}
```
</details>

---

お疲れ様でした！次の章に進みましょう。


